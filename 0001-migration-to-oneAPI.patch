From 2c2496a1763f8fba1a428b1b237641dbba198df5 Mon Sep 17 00:00:00 2001
From: wangyon1 <yong4.wang@intel.com>
Date: Tue, 2 Feb 2021 15:08:51 +0800
Subject: [PATCH 1/4] migration to oneAPI

---
 .../Beamformer/HilbertFirEnvelope.dp.cpp      |  132 +++
 .../SupraLib/Beamformer/HilbertFirEnvelope.h  |   44 +
 .../SupraLib/Beamformer/LogCompressor.dp.cpp  |   90 ++
 .../src/SupraLib/Beamformer/LogCompressor.h   |   32 +
 .../SupraLib/Beamformer/RxBeamformerCommon.h  |   62 +
 .../Beamformer/RxBeamformerCommon.h.yaml      |   72 ++
 .../Beamformer/RxBeamformerCuda.dp.cpp        |  559 +++++++++
 .../SupraLib/Beamformer/RxBeamformerCuda.h    |   81 ++
 .../Beamformer/RxBeamformerParameters.h       |  109 ++
 .../RxSampleBeamformerDelayAndStdDev.h        |  245 ++++
 .../RxSampleBeamformerDelayAndStdDev.h.yaml   |   46 +
 .../RxSampleBeamformerDelayAndSum.h           |  186 +++
 .../RxSampleBeamformerDelayAndSum.h.yaml      |   30 +
 .../Beamformer/RxSampleBeamformerTestSignal.h |  137 +++
 .../RxSampleBeamformerTestSignal.h.yaml       |   30 +
 .../SupraLib/Beamformer/ScanConverter.dp.cpp  |  931 +++++++++++++++
 .../src/SupraLib/Beamformer/ScanConverter.h   |   68 ++
 oneapi/src/SupraLib/Beamformer/USRawData.h    |   84 ++
 oneapi/src/SupraLib/Beamformer/USTransducer.h |  125 ++
 .../src/SupraLib/Beamformer/WindowFunction.h  |  150 +++
 .../SupraLib/Beamformer/WindowFunction.h.yaml |  160 +++
 oneapi/src/SupraLib/Container.h               |  329 +++++
 oneapi/src/SupraLib/Container.h.yaml          |  779 ++++++++++++
 .../src/SupraLib/ContainerFactory.cpp.dp.cpp  |  290 +++++
 oneapi/src/SupraLib/ContainerFactory.h        |   79 ++
 oneapi/src/SupraLib/ContainerFactory.h.yaml   |   22 +
 oneapi/src/SupraLib/RecordObject.h            |   62 +
 oneapi/src/SupraLib/USImage.h                 |  133 +++
 oneapi/src/SupraLib/USImageProperties.h       |  208 ++++
 oneapi/src/SupraLib/utilities/DataType.h      |   90 ++
 oneapi/src/SupraLib/utilities/DataType.h.yaml |   30 +
 .../src/SupraLib/utilities/FirFilterFactory.h |  238 ++++
 .../utilities/FirFilterFactory.h.yaml         |   56 +
 oneapi/src/SupraLib/utilities/Logging.h       |  330 ++++++
 oneapi/src/SupraLib/utilities/cudaUtility.h   |  168 +++
 .../src/SupraLib/utilities/cudaUtility.h.yaml |  311 +++++
 oneapi/src/SupraLib/utilities/utility.h       |  216 ++++
 oneapi/src/SupraLib/utilities/utility.h.yaml  |   22 +
 oneapi/src/SupraLib/vec.h                     |  412 +++++++
 oneapi/src/SupraLib/vec.h.yaml                | 1056 +++++++++++++++++
 .../Beamformer/HilbertFirEnvelope.dp.cpp      |  132 +++
 src/SupraLib/Beamformer/LogCompressor.dp.cpp  |   90 ++
 src/SupraLib/Beamformer/RxBeamformerCommon.h  |   20 +-
 .../Beamformer/RxBeamformerCuda.dp.cpp        |  627 ++++++++++
 .../RxSampleBeamformerDelayAndStdDev.h        |   10 +-
 .../RxSampleBeamformerDelayAndSum.h           |    6 +-
 .../Beamformer/RxSampleBeamformerTestSignal.h |    6 +-
 src/SupraLib/Beamformer/ScanConverter.dp.cpp  |  937 +++++++++++++++
 src/SupraLib/Beamformer/WindowFunction.h      |   36 +-
 src/SupraLib/Container.h                      |  120 +-
 src/SupraLib/ContainerFactory.cpp.dp.cpp      |  290 +++++
 src/SupraLib/ContainerFactory.h               |    4 +-
 src/SupraLib/utilities/DataType.h             |    6 +-
 src/SupraLib/utilities/FirFilterFactory.h     |   11 +-
 src/SupraLib/utilities/cudaUtility.h          |   54 +-
 src/SupraLib/utilities/utility.h              |    2 +
 src/SupraLib/vec.h                            |  168 ++-
 57 files changed, 10526 insertions(+), 197 deletions(-)
 create mode 100644 oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp
 create mode 100644 oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/LogCompressor.dp.cpp
 create mode 100644 oneapi/src/SupraLib/Beamformer/LogCompressor.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxBeamformerCommon.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxBeamformerCommon.h.yaml
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxBeamformerParameters.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h.yaml
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h.yaml
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h.yaml
 create mode 100644 oneapi/src/SupraLib/Beamformer/ScanConverter.dp.cpp
 create mode 100644 oneapi/src/SupraLib/Beamformer/ScanConverter.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/USRawData.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/USTransducer.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/WindowFunction.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/WindowFunction.h.yaml
 create mode 100644 oneapi/src/SupraLib/Container.h
 create mode 100644 oneapi/src/SupraLib/Container.h.yaml
 create mode 100644 oneapi/src/SupraLib/ContainerFactory.cpp.dp.cpp
 create mode 100644 oneapi/src/SupraLib/ContainerFactory.h
 create mode 100644 oneapi/src/SupraLib/ContainerFactory.h.yaml
 create mode 100644 oneapi/src/SupraLib/RecordObject.h
 create mode 100644 oneapi/src/SupraLib/USImage.h
 create mode 100644 oneapi/src/SupraLib/USImageProperties.h
 create mode 100644 oneapi/src/SupraLib/utilities/DataType.h
 create mode 100644 oneapi/src/SupraLib/utilities/DataType.h.yaml
 create mode 100644 oneapi/src/SupraLib/utilities/FirFilterFactory.h
 create mode 100644 oneapi/src/SupraLib/utilities/FirFilterFactory.h.yaml
 create mode 100644 oneapi/src/SupraLib/utilities/Logging.h
 create mode 100644 oneapi/src/SupraLib/utilities/cudaUtility.h
 create mode 100644 oneapi/src/SupraLib/utilities/cudaUtility.h.yaml
 create mode 100644 oneapi/src/SupraLib/utilities/utility.h
 create mode 100644 oneapi/src/SupraLib/utilities/utility.h.yaml
 create mode 100644 oneapi/src/SupraLib/vec.h
 create mode 100644 oneapi/src/SupraLib/vec.h.yaml
 create mode 100644 src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp
 create mode 100644 src/SupraLib/Beamformer/LogCompressor.dp.cpp
 create mode 100644 src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp
 create mode 100644 src/SupraLib/Beamformer/ScanConverter.dp.cpp
 create mode 100644 src/SupraLib/ContainerFactory.cpp.dp.cpp

diff --git a/oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp b/oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp
new file mode 100644
index 0000000..f2823f9
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp
@@ -0,0 +1,132 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2019, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "HilbertFirEnvelope.h"
+#include <utilities/utility.h>
+#include <utilities/FirFilterFactory.h>
+
+#include <dpct/dpl_utils.hpp>
+#include <oneapi/dpl/execution>
+#include <oneapi/dpl/algorithm>
+
+#include <algorithm>
+
+using namespace std;
+
+namespace supra
+{
+	template <typename InputType, typename OutputType>
+	void kernelFilterDemodulation(
+		const InputType* __restrict__ signal,
+		const HilbertFirEnvelope::WorkType * __restrict__ filter,
+		OutputType * __restrict__ out,
+		const int numSamples,
+		const int numScanlines,
+		const int filterLength,
+		sycl::nd_item<3> item_ct1) {
+		int scanlineIdx = item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2);
+		int sampleIdx = item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1);
+
+		if (scanlineIdx < numScanlines && sampleIdx < numSamples)
+		{
+			HilbertFirEnvelope::WorkType accumulator = 0;
+			
+			int startPoint = sampleIdx - filterLength / 2;
+			int endPoint = sampleIdx + filterLength / 2;
+			int currentFilterElement = 0;
+			for (int currentSample = startPoint;
+				currentSample <= endPoint;
+				currentSample++, currentFilterElement++)
+			{
+				if (currentSample >= 0 && currentSample < numSamples)
+				{
+					HilbertFirEnvelope::WorkType sample = static_cast<HilbertFirEnvelope::WorkType>(signal[scanlineIdx + currentSample*numScanlines]);
+					HilbertFirEnvelope::WorkType filterElement = filter[currentFilterElement];
+					accumulator += sample*filterElement;
+				}
+			}
+
+			HilbertFirEnvelope::WorkType signalValue = static_cast<HilbertFirEnvelope::WorkType>(signal[scanlineIdx + sampleIdx*numScanlines]);
+			out[ scanlineIdx + sampleIdx * numScanlines ] = sycl::sqrt(squ(signalValue) + squ(accumulator));
+		}
+
+	}
+
+	HilbertFirEnvelope::HilbertFirEnvelope(size_t filterLength)
+		: m_filterLength(filterLength)
+		, m_hilbertFilter(nullptr)
+	{
+		prepareFilter();
+	}
+
+	HilbertFirEnvelope::~HilbertFirEnvelope()
+	{
+	}
+
+	void HilbertFirEnvelope::prepareFilter()
+	{
+		m_hilbertFilter = FirFilterFactory::createFilter<float>(
+			m_filterLength,
+			FirFilterFactory::FilterTypeHilbertTransformer,
+			FirFilterFactory::FilterWindowHamming);
+		m_hilbertFilter = make_shared<Container<float> >(LocationGpu, *m_hilbertFilter);
+	}
+
+	template<typename InputType, typename OutputType>
+	shared_ptr<Container<OutputType> > HilbertFirEnvelope::demodulate(
+		const shared_ptr<const Container<InputType>>& inImageData,
+		int numScanlines, int numSamples)
+	{
+		auto pEnv = make_shared<Container<OutputType> >(LocationGpu, inImageData->getStream(), numScanlines*numSamples);
+		sycl::range<3> blockSizeFilter(1, 8, 16);
+		sycl::range<3> gridSizeFilter(1, static_cast<unsigned int>((numSamples + blockSizeFilter[ 1 ] - 1) / blockSizeFilter[ 1 ]),
+									  static_cast<unsigned int>((numScanlines + blockSizeFilter[ 2 ] - 1) / blockSizeFilter[ 2 ]));
+
+		/*
+		DPCT1049:27: The workgroup size passed to the SYCL kernel may exceed the limit. To get the device limit, query info::device::max_work_group_size. Adjust the workgroup size if needed.
+		*/
+				inImageData->getStream()->submit([ & ](sycl::handler& cgh) {
+						auto inImageData_get_ct0 = inImageData->get();
+						auto m_hilbertFilter_get_ct1 = m_hilbertFilter->get();
+						auto pEnv_get_ct2 = pEnv->get();
+						auto m_filterLength_ct5 = ( int )m_filterLength;
+
+						cgh.parallel_for(sycl::nd_range<3>(gridSizeFilter * blockSizeFilter, blockSizeFilter), [ = ](sycl::nd_item<3> item_ct1) {
+								kernelFilterDemodulation(inImageData_get_ct0, m_hilbertFilter_get_ct1, pEnv_get_ct2, numSamples, numScanlines, m_filterLength_ct5, item_ct1);
+						});
+				});
+		/*
+		DPCT1010:26: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+
+		return pEnv;
+	}
+
+	template 
+	shared_ptr<Container<int16_t> > HilbertFirEnvelope::demodulate<int16_t, int16_t>(
+		const shared_ptr<const Container<int16_t> >& inImageData,
+		int numScanlines, int numSamples);
+	template
+		shared_ptr<Container<int16_t> > HilbertFirEnvelope::demodulate<float, int16_t>(
+			const shared_ptr<const Container<float> >& inImageData,
+			int numScanlines, int numSamples);
+	template
+		shared_ptr<Container<float> > HilbertFirEnvelope::demodulate<int16_t, float>(
+			const shared_ptr<const Container<int16_t> >& inImageData,
+			int numScanlines, int numSamples);
+	template
+		shared_ptr<Container<float> > HilbertFirEnvelope::demodulate<float, float>(
+			const shared_ptr<const Container<float> >& inImageData,
+			int numScanlines, int numSamples);
+}
\ No newline at end of file
diff --git a/oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.h b/oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.h
new file mode 100644
index 0000000..b76d74e
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.h
@@ -0,0 +1,44 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2019, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __HILBERTFIRENVELOPE_H__
+#define __HILBERTFIRENVELOPE_H__
+
+#include "Container.h"
+
+#include <memory>
+
+namespace supra
+{
+	class HilbertFirEnvelope
+	{
+	public:
+		typedef float WorkType;
+
+		HilbertFirEnvelope(size_t filterLength);
+		~HilbertFirEnvelope();
+
+		template<typename InputType, typename OutputType>
+		std::shared_ptr<Container<OutputType> >
+			demodulate(
+				const std::shared_ptr<const Container<InputType> >& inImageData,
+				int numScanlines, int numSamples);
+
+	private:
+		void prepareFilter();
+
+		size_t m_filterLength;
+
+		std::shared_ptr<Container<WorkType> > m_hilbertFilter;
+	};
+}
+
+#endif //!__HILBERTFIRENVELOPE_H__
diff --git a/oneapi/src/SupraLib/Beamformer/LogCompressor.dp.cpp b/oneapi/src/SupraLib/Beamformer/LogCompressor.dp.cpp
new file mode 100644
index 0000000..7389daf
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/LogCompressor.dp.cpp
@@ -0,0 +1,90 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "LogCompressor.h"
+
+#include <dpct/dpl_utils.hpp>
+#include <oneapi/dpl/execution>
+#include <oneapi/dpl/algorithm>
+#include <cmath>
+
+using namespace std;
+
+namespace supra
+{
+	template <typename In, typename Out, typename WorkType>
+	/*
+	DPCT1044:29: thrust::unary_function was removed because std::unary_function has been deprecated in C++11. You may need to remove references to typedefs from thrust::unary_function in the class
+	definition.
+	*/
+	struct thrustLogcompress {
+		WorkType _inScale;
+		WorkType _scaleOverDenominator;
+
+		// Thrust functor that computes
+		// signal = log10(1 + a*signal)./log10(1 + a) 
+		// of the downscaled (_inMax) input signal
+		thrustLogcompress(double dynamicRange, In inMax, Out outMax, double scale)
+			: _inScale(static_cast<WorkType>(dynamicRange / inMax))
+			, _scaleOverDenominator(static_cast<WorkType>(scale * outMax / log10(dynamicRange + 1)))
+		{};
+
+		Out operator()(const In& a) const
+		{
+			WorkType val = log10(abs(static_cast<WorkType>(a))*_inScale + (WorkType)1) * _scaleOverDenominator;
+			return clampCast<Out>(val);
+		}
+	};
+
+	template <typename InputType, typename OutputType>
+	shared_ptr<Container<OutputType> > LogCompressor::compress(const shared_ptr<const Container<InputType>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax)
+	{
+		size_t width = size.x;
+		size_t height = size.y;
+		size_t depth = size.z;
+
+		auto pComprGpu = make_shared<Container<OutputType> >(LocationGpu, inImageData->getStream(), width*height*depth);
+
+		OutputType outMax;
+		if (std::is_integral<OutputType>::value)
+		{
+			outMax = std::numeric_limits<OutputType>::max();
+		}
+		else if (std::is_floating_point<OutputType>::value)
+		{
+			outMax = static_cast<OutputType>(255.0);
+		}
+
+		thrustLogcompress<InputType, OutputType, WorkType> c(sycl::pow<double>(10, (dynamicRange / 20)), static_cast<InputType>(inMax), outMax, scale);
+		std::transform(thrust::cuda::par.on(inImageData->getStream()), inImageData->get(), inImageData->get() + (width * height * depth), pComprGpu->get(), c);
+		/*
+		DPCT1010:28: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+
+		return pComprGpu;
+	}
+
+	template
+	shared_ptr<Container<uint8_t> > LogCompressor::compress<int16_t, uint8_t>(const shared_ptr<const Container<int16_t> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<uint8_t> > LogCompressor::compress<float, uint8_t>(const shared_ptr<const Container<float> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<uint8_t> > LogCompressor::compress<uint8_t, uint8_t>(const shared_ptr<const Container<uint8_t> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<float> > LogCompressor::compress<int16_t, float>(const shared_ptr<const Container<int16_t> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<float> > LogCompressor::compress<float, float>(const shared_ptr<const Container<float> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<float> > LogCompressor::compress<uint8_t, float>(const shared_ptr<const Container<uint8_t> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+}
\ No newline at end of file
diff --git a/oneapi/src/SupraLib/Beamformer/LogCompressor.h b/oneapi/src/SupraLib/Beamformer/LogCompressor.h
new file mode 100644
index 0000000..fe9481e
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/LogCompressor.h
@@ -0,0 +1,32 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __LOGCOMPRESSOR_H__
+#define __LOGCOMPRESSOR_H__
+
+#include "USImage.h"
+
+#include <memory>
+
+namespace supra
+{
+	class LogCompressor
+	{
+	public:
+		typedef float WorkType;
+
+		template<typename InputType, typename OutputType>
+		std::shared_ptr<Container<OutputType> >
+			compress(const std::shared_ptr<const Container<InputType> > & inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	};
+}
+
+#endif //!__LOGCOMPRESSOR_H__
diff --git a/oneapi/src/SupraLib/Beamformer/RxBeamformerCommon.h b/oneapi/src/SupraLib/Beamformer/RxBeamformerCommon.h
new file mode 100644
index 0000000..1527995
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxBeamformerCommon.h
@@ -0,0 +1,62 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __RXBEAMFORMERCOMMON_H__
+#define __RXBEAMFORMERCOMMON_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "WindowFunction.h"
+
+//TODO ALL ELEMENT/SCANLINE Y positons are actually Z! Change all variable names accordingly
+namespace supra
+{
+
+	template <typename T>
+	inline T computeAperture_D(T F, T z)
+	{
+		return z / (2 * F);
+	}
+
+	template <typename T>
+	inline T computeDelayDTSPACE_D(T dirX, T dirY, T dirZ, T x_element, T x, T z)
+	{
+		return sqrt((x_element - (x + dirX*z))*
+			(x_element - (x + dirX*z)) +
+			(dirY*z)*(dirY*z)) + z;
+	}
+
+	template <typename T>
+	inline T computeDelayDTSPACE3D_D(T dirX, T dirY, T dirZ, T x_element, T z_element, T x, T z, T d)
+	{
+		return sqrt(
+			squ(x_element - (x + dirX*d)) +
+			squ(z_element - (z + dirZ*d)) +
+			squ(dirY*d)) + d;
+	}
+
+	// distance has to be normalized to [-1, 1] (inclusive)
+	inline WindowFunctionGpu::ElementType
+		computeWindow3D(const WindowFunctionGpu& windowFunction, const vec2f& distance)
+	{
+		return sycl::sqrt(windowFunction.get(distance.x) * windowFunction.get(distance.y));
+	}
+
+
+	// distance has to be normalized to [-1, 1] (inclusive)
+	inline WindowFunctionGpu::ElementType
+		computeWindow3DShared(const WindowFunctionGpu& windowFunction, const WindowFunctionGpu::ElementType * __restrict__ sharedData, const vec2f& distance)
+	{
+		return sycl::sqrt(windowFunction.getShared(sharedData, distance.x) * windowFunction.getShared(sharedData, distance.y));
+	}
+}
+
+#endif //!__RXBEAMFORMERCOMMON_H__
\ No newline at end of file
diff --git a/oneapi/src/SupraLib/Beamformer/RxBeamformerCommon.h.yaml b/oneapi/src/SupraLib/Beamformer/RxBeamformerCommon.h.yaml
new file mode 100644
index 0000000..90d29af
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxBeamformerCommon.h.yaml
@@ -0,0 +1,72 @@
+---
+MainSourceFile:  '/home/wangyon1/projects/supra-projects/golden/supra/oneapi/src/SupraLib/Beamformer/RxBeamformerCommon.h'
+Replacements:
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxBeamformerCommon.h'
+    Offset:          549
+    Length:          0
+    ReplacementText: '#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxBeamformerCommon.h'
+    Offset:          714
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxBeamformerCommon.h'
+    Offset:          815
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxBeamformerCommon.h'
+    Offset:          1036
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxBeamformerCommon.h'
+    Offset:          1316
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxBeamformerCommon.h'
+    Offset:          1462
+    Length:          72
+    ReplacementText: 'sycl::sqrt(windowFunction.get(distance.x)*
+				windowFunction.get(distance.y))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxBeamformerCommon.h'
+    Offset:          1599
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxBeamformerCommon.h'
+    Offset:          1815
+    Length:          108
+    ReplacementText: 'sycl::sqrt(windowFunction.getShared(sharedData, distance.x)*
+				windowFunction.getShared(sharedData, distance.y))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+...
diff --git a/oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp b/oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp
new file mode 100644
index 0000000..0973fad
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp
@@ -0,0 +1,559 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "RxBeamformerCuda.h"
+#include "USImage.h"
+#include "USRawData.h"
+#include "RxSampleBeamformerDelayAndSum.h"
+#include "RxSampleBeamformerDelayAndStdDev.h"
+#include "RxSampleBeamformerTestSignal.h"
+#include "RxBeamformerCommon.h"
+#include "utilities/cudaUtility.h"
+
+//TODO ALL ELEMENT/SCANLINE Y positons are actually Z! Change all variable names accordingly
+namespace supra
+{
+	RxBeamformerCuda::RxBeamformerCuda(const RxBeamformerParameters & parameters)
+		: m_windowFunction(nullptr)
+	{
+  dpct::device_ext& dev_ct1 = dpct::get_current_device();
+  sycl::queue&	  q_ct1 = dev_ct1.default_queue();
+		m_lastSeenDt = 0;
+		m_numRxScanlines = parameters.getNumRxScanlines();
+		m_rxScanlineLayout = parameters.getRxScanlineLayout();
+
+		m_is3D = (m_rxScanlineLayout.x > 1 && m_rxScanlineLayout.y > 1);
+		m_speedOfSoundMMperS = parameters.getSpeedOfSoundMMperS();
+		m_rxNumDepths = parameters.getRxNumDepths();
+
+		// create and fill new buffers
+		m_pRxDepths = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationGpu, &q_ct1, parameters.getRxDepths()));
+
+		m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D>>(new Container<ScanlineRxParameters3D>(LocationGpu, &q_ct1, parameters.getRxScanlines()));
+
+		m_pRxElementXs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationGpu, &q_ct1, parameters.getRxElementXs()));
+		m_pRxElementYs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationGpu, &q_ct1, parameters.getRxElementYs()));
+	}
+
+	RxBeamformerCuda::~RxBeamformerCuda()
+	{
+	}
+
+	void RxBeamformerCuda::convertToDtSpace(double dt, double speedOfSoundMMperS, size_t numTransducerElements) const
+	{
+		if (m_lastSeenDt != dt || m_speedOfSoundMMperS != speedOfSoundMMperS)
+		{
+			double oldFactor = 1;
+			double oldFactorTime = 1;
+			if (m_lastSeenDt != 0 && m_speedOfSoundMMperS != 0)
+			{
+				oldFactor = 1 / (m_speedOfSoundMMperS * m_lastSeenDt);
+				oldFactorTime = 1 / m_lastSeenDt;
+			}
+
+			double factor = 1 / oldFactor / (speedOfSoundMMperS * dt);
+			double factorTime = 1 / oldFactorTime / dt;
+
+			m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D> >(new Container<ScanlineRxParameters3D>(LocationHost, *m_pRxScanlines));
+			for (size_t i = 0; i < m_numRxScanlines; i++)
+			{
+				ScanlineRxParameters3D p = m_pRxScanlines->get()[i];
+				p.position = p.position*factor;
+				for (size_t k = 0; k < std::extent<decltype(p.txWeights)>::value; k++)
+				{
+					p.txParameters[k].initialDelay *= factorTime;
+				}
+				p.maxElementDistance = p.maxElementDistance*factor;
+				m_pRxScanlines->get()[i] = p;
+			}
+			m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D> >(new Container<ScanlineRxParameters3D>(LocationGpu, *m_pRxScanlines));
+
+			m_pRxDepths = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationHost, *m_pRxDepths));
+			for (size_t i = 0; i < m_rxNumDepths; i++)
+			{
+				m_pRxDepths->get()[i] = static_cast<LocationType>(m_pRxDepths->get()[i] * factor);
+			}
+			m_pRxDepths = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationGpu, *m_pRxDepths));
+
+			m_pRxElementXs = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationHost, *m_pRxElementXs));
+			m_pRxElementYs = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationHost, *m_pRxElementYs));
+			for (size_t i = 0; i < numTransducerElements; i++)
+			{
+				m_pRxElementXs->get()[i] = static_cast<LocationType>(m_pRxElementXs->get()[i] * factor);
+				m_pRxElementYs->get()[i] = static_cast<LocationType>(m_pRxElementYs->get()[i] * factor);
+			}
+			m_pRxElementXs = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationGpu, *m_pRxElementXs));
+			m_pRxElementYs = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationGpu, *m_pRxElementYs));
+
+			m_lastSeenDt = dt;
+			m_speedOfSoundMMperS = speedOfSoundMMperS;
+		}
+	}
+
+	template <class SampleBeamformer, bool interpolateRFlines, bool interpolateBetweenTransmits, unsigned int maxNumElements, unsigned int maxNumFunctionElements, typename RFType, typename ResultType, typename LocationType>
+	
+		void rxBeamformingDTSPACE3DKernel(
+			uint32_t numTransducerElements,
+			vec2T<uint32_t> elementLayout,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const RFType* __restrict__ RF,
+			uint32_t numTxScanlines,
+			uint32_t numRxScanlines,
+			const ScanlineRxParameters3D* __restrict__ scanlinesDT,
+			uint32_t numDs,
+			const LocationType* __restrict__ dsDT,
+			const LocationType* __restrict__ x_elemsDT,
+			const LocationType* __restrict__ z_elemsDT,
+			LocationType speedOfSound,
+			LocationType dt,
+			uint32_t additionalOffset,
+			LocationType F,
+			const WindowFunctionGpu windowFunction,
+			ResultType* __restrict__ s,
+			sycl::nd_item<3> item_ct1,
+			LocationType *x_elemsDTsh,
+			LocationType *z_elemsDTsh,
+			WindowFunction::ElementType *functionShared)
+	{
+
+		//fetch element positions to shared memory
+		for (int threadId = (item_ct1.get_local_id(1) * item_ct1.get_local_range().get(2)) + item_ct1.get_local_id(2);	//@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+			 threadId < maxNumElements && threadId < numTransducerElements;
+			 threadId += item_ct1.get_local_range().get(2) * item_ct1.get_local_range().get(1))	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		{
+			x_elemsDTsh[threadId] = x_elemsDT[threadId];
+			z_elemsDTsh[threadId] = z_elemsDT[threadId];
+		}
+		for (int threadId = (item_ct1.get_local_id(1) * item_ct1.get_local_range().get(2)) + item_ct1.get_local_id(2);	//@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+			 threadId < maxNumFunctionElements && threadId < windowFunction.numElements();
+			 threadId += item_ct1.get_local_range().get(2) * item_ct1.get_local_range().get(1))	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		{
+			functionShared[threadId] = windowFunction.getDirect(threadId);
+		}
+		item_ct1.barrier();	 //@suppress("Function cannot be resolved")
+
+		int r = item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1);			 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		int scanlineIdx = item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2);	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+
+		if (r < numDs && scanlineIdx < numRxScanlines)
+		{
+			LocationType d = dsDT[r];
+			//TODO should this also depend on the angle?
+			LocationType aDT = squ(computeAperture_D(F, d*dt*speedOfSound) / speedOfSound / dt);
+			ScanlineRxParameters3D scanline = scanlinesDT[scanlineIdx];
+
+			LocationType scanline_x = scanline.position.x;
+			LocationType scanline_z = scanline.position.z;
+			LocationType dirX = scanline.direction.x;
+			LocationType dirY = scanline.direction.y;
+			LocationType dirZ = scanline.direction.z;
+			vec2f maxElementDistance = static_cast<vec2f>(scanline.maxElementDistance);
+			vec2f invMaxElementDistance = vec2f{ 1.0f, 1.0f } / min(vec2f{ sqrt(aDT), sqrt(aDT) }, maxElementDistance);
+
+			float sInterp = 0.0f;
+
+			int highestWeightIndex;
+			if (!interpolateBetweenTransmits)
+			{
+				highestWeightIndex = 0;
+				float highestWeight = scanline.txWeights[0];
+				for (int k = 1; k < std::extent<decltype(scanline.txWeights)>::value; k++)
+				{
+					if (scanline.txWeights[k] > highestWeight)
+					{
+						highestWeight = scanline.txWeights[k];
+						highestWeightIndex = k;
+					}
+				}
+			}
+
+			// now iterate over all four txScanlines to interpolate beamformed scanlines from those transmits
+			for (int k = (interpolateBetweenTransmits ? 0 : highestWeightIndex);
+				(interpolateBetweenTransmits && k < std::extent<decltype(scanline.txWeights)>::value) ||
+				(!interpolateBetweenTransmits && k == highestWeightIndex);
+				k++)
+			{
+				if (scanline.txWeights[k] > 0.0)
+				{
+					ScanlineRxParameters3D::TransmitParameters txParams = scanline.txParameters[k];
+					uint32_t txScanlineIdx = txParams.txScanlineIdx;
+					if (txScanlineIdx >= numTxScanlines)
+					{
+						//ERROR!
+						return;
+					}
+					float sLocal = 0.0f;
+					
+					sLocal = SampleBeamformer::template sampleBeamform3D<interpolateRFlines, RFType, float, LocationType>(
+						txParams, RF, elementLayout, numReceivedChannels, numTimesteps,
+						x_elemsDTsh, z_elemsDTsh, scanline_x, scanline_z, dirX, dirY, dirZ,
+						aDT, d, invMaxElementDistance, speedOfSound, dt, additionalOffset, &windowFunction, functionShared);
+
+					if (interpolateBetweenTransmits)
+					{
+						sInterp += static_cast<float>(scanline.txWeights[k])* sLocal;
+					}
+					else
+					{
+						sInterp += sLocal;
+					}
+				}
+			}
+			s[scanlineIdx + r * numRxScanlines] = clampCast<ResultType>(sInterp);
+		}
+	}
+
+	template <class SampleBeamformer, bool interpolateRFlines, bool interpolateBetweenTransmits, typename RFType, typename ResultType, typename LocationType>
+	
+		void rxBeamformingDTSPACEKernel(
+			size_t numTransducerElements,
+			size_t numReceivedChannels,
+			size_t numTimesteps,
+			const RFType* __restrict__ RF,
+			size_t numTxScanlines,
+			size_t numRxScanlines,
+			const ScanlineRxParameters3D* __restrict__ scanlinesDT,
+			size_t numDs,
+			const LocationType* __restrict__ dsDT,
+			const LocationType* __restrict__ x_elemsDT,
+			LocationType speedOfSound,
+			LocationType dt,
+			uint32_t additionalOffset,
+			LocationType F,
+			const WindowFunctionGpu windowFunction,
+			ResultType* __restrict__ s,
+			sycl::nd_item<3> item_ct1)
+	{
+		int r = item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1);			 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		int scanlineIdx = item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2);	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		if (r < numDs && scanlineIdx < numRxScanlines)
+		{
+			LocationType d = dsDT[r];
+			//TODO should this also depend on the angle?
+			LocationType aDT = computeAperture_D(F, d*dt*speedOfSound) / speedOfSound / dt;
+			ScanlineRxParameters3D scanline = scanlinesDT[scanlineIdx];
+			LocationType scanline_x = scanline.position.x;
+			LocationType dirX = scanline.direction.x;
+			LocationType dirY = scanline.direction.y;
+			LocationType dirZ = scanline.direction.z;
+			LocationType maxElementDistance = static_cast<LocationType>(scanline.maxElementDistance.x);
+			LocationType		   invMaxElementDistance = 1 / std::min(aDT, maxElementDistance);
+
+			float sInterp = 0.0f;
+
+			int highestWeightIndex;
+			if (!interpolateBetweenTransmits)
+			{
+				highestWeightIndex = 0;
+				float highestWeight = scanline.txWeights[0];
+				for (int k = 1; k < std::extent<decltype(scanline.txWeights)>::value; k++)
+				{
+					if (scanline.txWeights[k] > highestWeight)
+					{
+						highestWeight = scanline.txWeights[k];
+						highestWeightIndex = k;
+					}
+				}
+			}
+
+			// now iterate over all four txScanlines to interpolate beamformed scanlines from those transmits
+			for (int k = (interpolateBetweenTransmits ? 0 : highestWeightIndex);
+				(interpolateBetweenTransmits && k < std::extent<decltype(scanline.txWeights)>::value) ||
+				(!interpolateBetweenTransmits && k == highestWeightIndex);
+				k++)
+			{
+				if (scanline.txWeights[k] > 0.0)
+				{
+					ScanlineRxParameters3D::TransmitParameters txParams = scanline.txParameters[k];
+					uint32_t txScanlineIdx = txParams.txScanlineIdx;
+					if (txScanlineIdx >= numTxScanlines)
+					{
+						//ERROR!
+						return;
+					}
+
+					float sLocal = 0.0f;
+					sLocal = SampleBeamformer::template sampleBeamform2D<interpolateRFlines, RFType, float, LocationType>(
+						txParams, RF, numTransducerElements, numReceivedChannels, numTimesteps,
+						x_elemsDT, scanline_x, dirX, dirY, dirZ,
+						aDT, d, invMaxElementDistance, speedOfSound, dt, additionalOffset, &windowFunction);
+
+					if (interpolateBetweenTransmits)
+					{
+						sInterp += static_cast<float>(scanline.txWeights[k])* sLocal;
+					}
+					else
+					{
+						sInterp += sLocal;
+					}
+				}
+			}
+			s[scanlineIdx + r * numRxScanlines] = clampCast<ResultType>(sInterp);
+		}
+	}
+
+	template <class SampleBeamformer, unsigned int maxWindowFunctionNumel, typename RFType, typename ResultType, typename LocationType>
+	void rxBeamformingDTspaceCuda3D(bool interpolateRFlines, bool interpolateBetweenTransmits, size_t numTransducerElements, vec2s elementLayout, size_t numReceivedChannels, size_t numTimesteps,
+									const RFType* RF, size_t numTxScanlines, size_t numRxScanlines, const ScanlineRxParameters3D* scanlines, size_t numZs, const LocationType* zs,
+									const LocationType* x_elems, const LocationType* y_elems, LocationType speedOfSound, LocationType dt, uint32_t additionalOffset, LocationType F,
+									const WindowFunctionGpu windowFunction, sycl::queue* stream, ResultType* s)
+	{
+		sycl::range<3> blockSize(1, 256, 1);
+		sycl::range<3> gridSize(1, static_cast<unsigned int>((numZs + blockSize[ 1 ] - 1) / blockSize[ 1 ]), static_cast<unsigned int>((numRxScanlines + blockSize[ 2 ] - 1) / blockSize[ 2 ]));
+
+		if (interpolateRFlines)
+		{
+			if (interpolateBetweenTransmits)
+			{
+				rxBeamformingDTSPACE3DKernel<SampleBeamformer, true, true, 1024, maxWindowFunctionNumel> << <gridSize, blockSize, 0, stream>> > (
+					(uint32_t)numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout),
+					(uint32_t)numReceivedChannels, (uint32_t)numTimesteps, RF,
+					(uint32_t)numTxScanlines, (uint32_t)numRxScanlines, scanlines,
+					(uint32_t)numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s);
+			}
+			else {
+				rxBeamformingDTSPACE3DKernel<SampleBeamformer, true, false, 1024, maxWindowFunctionNumel> << <gridSize, blockSize, 0, stream>> > (
+					(uint32_t)numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout),
+					(uint32_t)numReceivedChannels, (uint32_t)numTimesteps, RF,
+					(uint32_t)numTxScanlines, (uint32_t)numRxScanlines, scanlines,
+					(uint32_t)numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s);
+			}
+		}
+		else {
+			if (interpolateBetweenTransmits)
+			{
+				rxBeamformingDTSPACE3DKernel<SampleBeamformer, false, true, 1024, maxWindowFunctionNumel> << <gridSize, blockSize, 0, stream>> > (
+					(uint32_t)numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout),
+					(uint32_t)numReceivedChannels, (uint32_t)numTimesteps, RF,
+					(uint32_t)numTxScanlines, (uint32_t)numRxScanlines, scanlines,
+					(uint32_t)numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s);
+			}
+			else {
+				rxBeamformingDTSPACE3DKernel<SampleBeamformer, false, false, 1024, maxWindowFunctionNumel> << <gridSize, blockSize, 0, stream>> > (
+					(uint32_t)numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout),
+					(uint32_t)numReceivedChannels, (uint32_t)numTimesteps, RF,
+					(uint32_t)numTxScanlines, (uint32_t)numRxScanlines, scanlines,
+					(uint32_t)numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s);
+			}
+		}
+		/*
+		DPCT1010:30: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+	}
+
+	template <class SampleBeamformer, typename RFType, typename ResultType, typename LocationType>
+	void rxBeamformingDTspaceCuda(bool interpolateRFlines, bool interpolateBetweenTransmits, size_t numTransducerElements, size_t numReceivedChannels, size_t numTimesteps, const RFType* RF,
+								  size_t numTxScanlines, size_t numRxScanlines, const ScanlineRxParameters3D* scanlines, size_t numZs, const LocationType* zs, const LocationType* x_elems,
+								  LocationType speedOfSound, LocationType dt, uint32_t additionalOffset, LocationType F, const WindowFunctionGpu windowFunction, sycl::queue* stream, ResultType* s)
+	{
+		sycl::range<3> blockSize(1, 256, 1);
+		sycl::range<3> gridSize(1, static_cast<unsigned int>((numZs + blockSize[ 1 ] - 1) / blockSize[ 1 ]), static_cast<unsigned int>((numRxScanlines + blockSize[ 2 ] - 1) / blockSize[ 2 ]));
+		if (interpolateRFlines)
+		{
+			if (interpolateBetweenTransmits)
+			{
+				rxBeamformingDTSPACEKernel<SampleBeamformer, true, true> << <gridSize, blockSize, 0, stream>> > (
+					numTransducerElements, numReceivedChannels, numTimesteps, RF,
+					numTxScanlines, numRxScanlines, scanlines,
+					numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s);
+			}
+			else {
+				rxBeamformingDTSPACEKernel<SampleBeamformer, true, false> << <gridSize, blockSize, 0, stream>> > (
+					numTransducerElements, numReceivedChannels, numTimesteps, RF,
+					numTxScanlines, numRxScanlines, scanlines,
+					numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s);
+			}
+		}
+		else {
+			if (interpolateBetweenTransmits)
+			{
+				rxBeamformingDTSPACEKernel<SampleBeamformer, false, true> << <gridSize, blockSize, 0, stream>> > (
+					numTransducerElements, numReceivedChannels, numTimesteps, RF,
+					numTxScanlines, numRxScanlines, scanlines,
+					numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s);
+			}
+			else {
+				rxBeamformingDTSPACEKernel<SampleBeamformer, false, false> <<<gridSize, blockSize, 0, stream>>> (
+					numTransducerElements, numReceivedChannels, numTimesteps, RF,
+					numTxScanlines, numRxScanlines, scanlines,
+					numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s);
+			}
+		}
+		/*
+		DPCT1010:31: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+	}
+
+	template <typename ChannelDataType, typename ImageDataType>
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const
+	{
+		//Ensure the raw-data are on the gpu
+		auto gRawData = rawData->getData<ChannelDataType>();
+		if (!gRawData->isGPU() && !gRawData->isBoth())
+		{
+			gRawData = std::make_shared<Container<ChannelDataType> >(LocationGpu, *gRawData);
+		}
+
+		size_t numelOut = m_numRxScanlines*m_rxNumDepths;
+		shared_ptr<Container<ImageDataType> > pData = std::make_shared<Container<ImageDataType> >(ContainerLocation::LocationGpu, gRawData->getStream(), numelOut);
+
+		double dt = 1.0 / rawData->getSamplingFrequency();
+
+		if (!m_windowFunction || m_windowFunction->getType() != windowType || m_windowFunction->getParameter() != windowParameter)
+		{
+			m_windowFunction = std::unique_ptr<WindowFunction>(new WindowFunction(windowType, windowParameter, m_windowFunctionNumEntries));
+		}
+
+		auto beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndSum, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+		auto beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndSum, ChannelDataType, ImageDataType, LocationType>;
+		switch (sampleBeamformer)
+		{
+		case DelayAndSum:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndSum, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndSum, ChannelDataType, ImageDataType, LocationType>;
+			break;
+		case DelayAndStdDev:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndStdDev, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndStdDev, ChannelDataType, ImageDataType, LocationType>;
+			break;
+		case TestSignal:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerTestSignal, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerTestSignal, ChannelDataType, ImageDataType, LocationType>;
+			break;
+		case INVALID:
+		default:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndSum, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndSum, ChannelDataType, ImageDataType, LocationType>;
+		}
+
+
+		convertToDtSpace(dt, speedOfSoundMMperS, rawData->getNumElements());
+		if (m_is3D)
+		{
+			beamformingFunction3D(
+				true,
+				interpolateBetweenTransmits,
+				rawData->getNumElements(),
+				rawData->getElementLayout(),
+				rawData->getNumReceivedChannels(),
+				rawData->getNumSamples(),
+				gRawData->get(),
+				rawData->getNumScanlines(), // numTxScanlines
+				m_numRxScanlines,			// numRxScanlines
+				m_pRxScanlines->get(),
+				m_rxNumDepths, m_pRxDepths->get(),
+				m_pRxElementXs->get(),
+				m_pRxElementYs->get(),
+				static_cast<LocationType>(m_speedOfSoundMMperS),
+				static_cast<LocationType>(dt),
+				additionalOffset,
+				static_cast<LocationType>(fNumber),
+				*(m_windowFunction->getGpu()),
+				gRawData->getStream(),
+				pData->get()
+				);
+		}
+		else {
+			beamformingFunction2D(
+				true,
+				interpolateBetweenTransmits,
+				rawData->getNumElements(),
+				rawData->getNumReceivedChannels(),
+				rawData->getNumSamples(),
+				gRawData->get(),
+				rawData->getNumScanlines(), // numTxScanlines
+				m_numRxScanlines,			// numRxScanlines
+				m_pRxScanlines->get(),
+				m_rxNumDepths, m_pRxDepths->get(),
+				m_pRxElementXs->get(),
+				static_cast<LocationType>(m_speedOfSoundMMperS),
+				static_cast<LocationType>(dt),
+				additionalOffset,
+				static_cast<LocationType>(fNumber),
+				*(m_windowFunction->getGpu()),
+				gRawData->getStream(),
+				pData->get()
+				);
+		}
+
+		if (rawData->getImageProperties() != m_lastSeenImageProperties)
+		{
+			m_lastSeenImageProperties = rawData->getImageProperties();
+			shared_ptr<USImageProperties> newProps = std::make_shared<USImageProperties>(*m_lastSeenImageProperties);
+			newProps->setScanlineLayout(m_rxScanlineLayout);
+			newProps->setNumSamples(m_rxNumDepths);
+			newProps->setImageState(USImageProperties::RF);
+			m_editedImageProperties = std::const_pointer_cast<const USImageProperties>(newProps);
+		}
+
+		auto retImage = std::make_shared<USImage>(
+			vec2s{ m_numRxScanlines, m_rxNumDepths },
+			pData,
+			m_editedImageProperties,
+			rawData->getReceiveTimestamp(),
+			rawData->getSyncTimestamp());
+
+		return retImage;
+	}
+
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<int16_t, int16_t>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<int16_t, float>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<float, int16_t>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<float, float>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+}
\ No newline at end of file
diff --git a/oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.h b/oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.h
new file mode 100644
index 0000000..5d9f3cf
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.h
@@ -0,0 +1,81 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __RXBEAMFORMERCUDA_H__
+#define __RXBEAMFORMERCUDA_H__
+
+#include "USImage.h"
+#include "WindowFunction.h"
+#include "RxBeamformerParameters.h"
+
+#include <memory>
+
+namespace supra
+{
+	struct ScanlineRxParameters3D;
+	class USRawData;
+
+	using std::shared_ptr;
+
+	class RxBeamformerCuda
+	{
+	public:
+		enum RxSampleBeamformer {
+			DelayAndSum,
+			DelayAndStdDev,
+			TestSignal,
+			INVALID
+		};
+
+		RxBeamformerCuda(const RxBeamformerParameters& parameters);
+		~RxBeamformerCuda();
+
+		// perform the receive beamforming
+		template <typename ChannelDataType, typename ImageDataType>
+		shared_ptr<USImage> performRxBeamforming(
+			RxSampleBeamformer sampleBeamformer,
+			shared_ptr<const USRawData> rawData,
+			double fNumber,
+			double speedOfSoundMMperS,
+			WindowType windowType,
+			WindowFunction::ElementType windowParameters,
+			bool interpolateBetweenTransmits,
+			int32_t additionalOffset) const;
+
+	private:
+		typedef RxBeamformerParameters::LocationType LocationType;
+
+		void convertToDtSpace(double dt, double speedOfSoundMMperS, size_t numTransducerElements) const;
+
+		// Imaging parameters
+		size_t m_numRxScanlines;
+		vec2s m_rxScanlineLayout;
+
+		// prepared Rx parameters
+		mutable std::unique_ptr<Container<LocationType> > m_pRxDepths;
+		mutable std::unique_ptr<Container<ScanlineRxParameters3D> > m_pRxScanlines;
+		mutable std::unique_ptr<Container<LocationType> > m_pRxElementXs;
+		mutable std::unique_ptr<Container<LocationType> > m_pRxElementYs;
+		size_t m_rxNumDepths;
+
+		mutable double m_speedOfSoundMMperS;
+		mutable double m_lastSeenDt;
+		mutable shared_ptr<const USImageProperties> m_lastSeenImageProperties;
+		mutable shared_ptr<const USImageProperties> m_editedImageProperties;
+
+		bool m_is3D;
+
+		static constexpr size_t m_windowFunctionNumEntries = 64;
+		mutable std::unique_ptr<WindowFunction> m_windowFunction;
+	};
+}
+
+#endif //!__RXBEAMFORMERCUDA_H__
diff --git a/oneapi/src/SupraLib/Beamformer/RxBeamformerParameters.h b/oneapi/src/SupraLib/Beamformer/RxBeamformerParameters.h
new file mode 100644
index 0000000..cf17ab3
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxBeamformerParameters.h
@@ -0,0 +1,109 @@
+// ================================================================================================
+// 
+// Copyright (C) 2017, Rüdiger Göbl - all rights reserved
+// Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.
+//
+//          Rüdiger Göbl
+//          Email r.goebl@tum.de
+//          Chair for Computer Aided Medical Procedures
+//          Technische Universität München
+//          Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License, version 2.1, as published by the Free Software Foundation.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this program.  If not, see
+// <http://www.gnu.org/licenses/>.
+//
+// ================================================================================================
+
+#ifndef __RXBEAMFORMERPARAMETERS_H__
+#define __RXBEAMFORMERPARAMETERS_H__
+
+#include "USTransducer.h"
+#include <memory>
+
+namespace supra
+{
+	struct ScanlineRxParameters3D;
+	class USRawData;
+
+	class RxBeamformerParameters
+	{
+	public:
+		typedef float LocationType;
+
+		RxBeamformerParameters(
+			std::shared_ptr<std::vector<std::vector<ScanlineRxParameters3D> > > rxParameters,
+			size_t numDepths,
+			double depth,
+			double speedOfSoundMMperS,
+			const USTransducer* pTransducer);
+
+		RxBeamformerParameters(
+			size_t numRxScanlines,
+			vec2s rxScanlineLayout,
+			double speedOfSoundMMperS,
+			const std::vector<LocationType> & rxDepths,
+			const std::vector<ScanlineRxParameters3D> & rxScanlines,
+			const std::vector<LocationType> & rxElementXs,
+			const std::vector<LocationType> & rxElementYs,
+			size_t rxNumDepths)
+			: m_rxScanlineLayout(rxScanlineLayout)
+			, m_numRxScanlines(numRxScanlines)
+			, m_speedOfSoundMMperS(speedOfSoundMMperS)
+			, m_rxNumDepths(rxNumDepths)
+			, m_rxDepths(rxDepths)
+			, m_rxScanlines(rxScanlines)
+			, m_rxElementXs(rxElementXs)
+			, m_rxElementYs(rxElementYs) {};
+
+		size_t getNumRxScanlines() const { return m_numRxScanlines; }
+		vec2s getRxScanlineLayout() const { return m_rxScanlineLayout; }
+		double getSpeedOfSoundMMperS() const { return m_speedOfSoundMMperS; }
+		const std::vector<LocationType> & getRxDepths() const { return m_rxDepths; }
+		const std::vector<ScanlineRxParameters3D> & getRxScanlines() const { return m_rxScanlines; }
+		const std::vector<LocationType> & getRxElementXs() const { return m_rxElementXs; }
+		const std::vector<LocationType> & getRxElementYs() const { return m_rxElementYs; }
+		size_t getRxNumDepths() const { return m_rxNumDepths; }
+
+
+		bool operator== (const RxBeamformerParameters& b) const
+		{
+			return
+				m_numRxScanlines == b.m_numRxScanlines &&
+				m_rxScanlineLayout == b.m_rxScanlineLayout &&
+				m_speedOfSoundMMperS == b.m_speedOfSoundMMperS &&
+				m_rxDepths == b.m_rxDepths &&
+				m_rxScanlines == b.m_rxScanlines &&
+				m_rxElementXs == b.m_rxElementXs &&
+				m_rxElementYs == b.m_rxElementYs &&
+				m_rxNumDepths == b.m_rxNumDepths;
+		}
+
+		void writeMetaDataForMock(std::string filename, std::shared_ptr<const USRawData> rawData) const;
+		static std::shared_ptr<USRawData> readMetaDataForMock(const std::string & mockMetadataFilename);
+		static std::shared_ptr<USRawData> readMetaDataForMockAscii(const std::string & mockAsciiMetadataFilename);
+		static std::shared_ptr<USRawData> readMetaDataForMockJson(const std::string & mockJsonMetadataFilename);
+		
+	private:
+
+		size_t m_numRxScanlines;
+		vec2s m_rxScanlineLayout;
+		double m_speedOfSoundMMperS;
+		std::vector<LocationType> m_rxDepths;
+		std::vector<ScanlineRxParameters3D> m_rxScanlines;
+		std::vector<LocationType> m_rxElementXs;
+		std::vector<LocationType> m_rxElementYs;
+		size_t m_rxNumDepths;
+	};
+}
+
+#endif //!__RXBEAMFORMERPARAMETERS_H__
diff --git a/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h
new file mode 100644
index 0000000..d72079d
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h
@@ -0,0 +1,245 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2017, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __RXSAMPLEBEAMFORMERDELAYANDSTDDEV_H__
+#define __RXSAMPLEBEAMFORMERDELAYANDSTDDEV_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "USImageProperties.h"
+#include "WindowFunction.h"
+#include "RxBeamformerCommon.h"
+
+#include "RxSampleBeamformerDelayAndSum.h"
+
+// Beamformer accoring to
+//
+// R.S.Bandaru, A.R.Sornes, J.Hermans, E.Samset, and J.D’Hooge, 
+// “Delay and Standard Deviation Beamforming to Enhance Specular Reflections in Ultrasound Imaging,”
+// IEEE Trans.Ultrason.Ferroelectr.Freq.Control, vol. 63, no. 12, 2016.
+//
+// with the modification of calculating the std dev for the real channel data, 
+// instead of IQ as proposed in the article.
+
+//TODO ALL ELEMENT/SCANLINE Y positons are actually Z! Change all variable names accordingly
+namespace supra
+{
+	class RxSampleBeamformerDelayAndStdDev
+	{
+	public:
+		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
+		static ResultType sampleBeamform3D(
+			ScanlineRxParameters3D::TransmitParameters txParams,
+			const RFType* RF,
+			vec2T<uint32_t> elementLayout,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const LocationType* x_elemsDTsh,
+			const LocationType* z_elemsDTsh,
+			LocationType scanline_x,
+			LocationType scanline_z,
+			LocationType dirX,
+			LocationType dirY,
+			LocationType dirZ,
+			LocationType aDT,
+			LocationType depth,
+			vec2f invMaxElementDistance,
+			LocationType speedOfSound,
+			LocationType dt,
+			int32_t additionalOffset,
+			const WindowFunctionGpu* windowFunction,
+			const WindowFunction::ElementType* functionShared
+		)
+		{
+			float value = 0.0f;
+			float sd = 0.0f;
+			float weightAcum = 0.0f;
+			int numAdds = 0;
+			LocationType initialDelay = txParams.initialDelay;
+			uint32_t txScanlineIdx = txParams.txScanlineIdx;
+
+			ResultType mean = RxSampleBeamformerDelayAndSum::sampleBeamform3D<interpolateRFlines, RFType, ResultType, LocationType>(
+				txParams,
+				RF,
+				elementLayout,
+				numReceivedChannels,
+				numTimesteps,
+				x_elemsDTsh,
+				z_elemsDTsh,
+				scanline_x,
+				scanline_z,
+				dirX,
+				dirY,
+				dirZ,
+				aDT,
+				depth,
+				invMaxElementDistance,
+				speedOfSound,
+				dt,
+				additionalOffset,
+				windowFunction,
+				functionShared);
+
+			for (uint32_t elemIdxX = txParams.firstActiveElementIndex.x; elemIdxX < txParams.lastActiveElementIndex.x; elemIdxX++)
+			{
+				for (uint32_t elemIdxY = txParams.firstActiveElementIndex.y; elemIdxY < txParams.lastActiveElementIndex.y; elemIdxY++)
+				{
+					uint32_t elemIdx = elemIdxX + elemIdxY*elementLayout.x;
+					uint32_t  channelIdx = elemIdx % numReceivedChannels;
+					LocationType x_elem = x_elemsDTsh[elemIdx];
+					LocationType z_elem = z_elemsDTsh[elemIdx];
+
+					if ((squ(x_elem - scanline_x) + squ(z_elem - scanline_z)) <= aDT)
+					{
+						vec2f elementScanlineDistance = { x_elem - scanline_x, z_elem - scanline_z };
+						float weight = computeWindow3DShared(*windowFunction, functionShared, elementScanlineDistance * invMaxElementDistance);
+						weightAcum += weight;
+						numAdds++;
+						if (interpolateRFlines)
+						{
+							LocationType delayf = initialDelay +
+								computeDelayDTSPACE3D_D(dirX, dirY, dirZ, x_elem, z_elem, scanline_x, scanline_z, depth) + additionalOffset;
+							uint32_t delay = static_cast<uint32_t>(::floor(delayf));
+							delayf -= delay;
+							if (delay < (numTimesteps - 1))
+							{
+								value = 
+									weight * ((1.0f - delayf) * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps] +
+										delayf  * RF[(delay + 1) + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps]);
+							}
+							else if (delay < numTimesteps && delayf == 0.0)
+							{
+								value = weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+							}
+						}
+						else
+						{
+							uint32_t delay = static_cast<uint32_t>(::round(
+								initialDelay + computeDelayDTSPACE3D_D(dirX, dirY, dirZ, x_elem, z_elem, scanline_x, scanline_z, depth)) + additionalOffset);
+							if (delay < numTimesteps)
+							{
+								value = weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+							}
+						}
+
+						sd += squ(value - mean);
+					}
+				}
+			}
+			if (numAdds > 0)
+			{
+				return sycl::sqrt(sd) / weightAcum * numAdds;
+			}
+			else
+			{
+				return 0;
+			}
+		}
+
+		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
+		static ResultType sampleBeamform2D(
+			ScanlineRxParameters3D::TransmitParameters txParams,
+			const RFType* RF,
+			uint32_t numTransducerElements,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const LocationType* x_elemsDT,
+			LocationType scanline_x,
+			LocationType dirX,
+			LocationType dirY,
+			LocationType dirZ,
+			LocationType aDT,
+			LocationType depth,
+			LocationType invMaxElementDistance,
+			LocationType speedOfSound,
+			LocationType dt,
+			int32_t additionalOffset,
+			const WindowFunctionGpu* windowFunction
+		)
+		{
+			float value = 0.0f;
+			float sd = 0.0f;
+			float weightAcum = 0.0f;
+			int numAdds = 0;
+			LocationType initialDelay = txParams.initialDelay;
+			uint32_t txScanlineIdx = txParams.txScanlineIdx;
+
+			ResultType mean = RxSampleBeamformerDelayAndSum::sampleBeamform2D<interpolateRFlines, RFType, ResultType, LocationType>(
+				txParams,
+				RF,
+				numTransducerElements,
+				numReceivedChannels,
+				numTimesteps,
+				x_elemsDT,
+				scanline_x,
+				dirX,
+				dirY,
+				dirZ,
+				aDT,
+				depth,
+				invMaxElementDistance,
+				speedOfSound,
+				dt,
+				additionalOffset,
+				windowFunction);
+
+			for (int32_t elemIdxX = txParams.firstActiveElementIndex.x; elemIdxX < txParams.lastActiveElementIndex.x; elemIdxX++)
+			{
+				int32_t  channelIdx = elemIdxX % numReceivedChannels;
+				LocationType x_elem = x_elemsDT[elemIdxX];
+				if (abs(x_elem - scanline_x) <= aDT)
+				{
+					float weight = windowFunction->get((x_elem - scanline_x) * invMaxElementDistance);
+					weightAcum += weight;
+					numAdds++;
+					if (interpolateRFlines)
+					{
+						LocationType delayf = initialDelay +
+							computeDelayDTSPACE_D(dirX, dirY, dirZ, x_elem, scanline_x, depth) + additionalOffset;
+						int32_t delay = static_cast<int32_t>(floor(delayf));
+						delayf -= delay;
+						if (delay < (numTimesteps - 1))
+						{
+							value =
+								weight * ((1.0f - delayf) * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps] +
+									delayf  * RF[(delay + 1) + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps]);
+						}
+						else if (delay < numTimesteps && delayf == 0.0)
+						{
+							value = weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+						}
+					}
+					else
+					{
+						int32_t delay = static_cast<int32_t>(round(
+							initialDelay + computeDelayDTSPACE_D(dirX, dirY, dirZ, x_elem, scanline_x, depth)) + additionalOffset);
+						if (delay < numTimesteps)
+						{
+							value = weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+						}
+					}
+
+					sd += squ(value - mean);
+				}
+			}
+			if (numAdds > 0)
+			{
+				return sycl::sqrt(sd) / weightAcum * numAdds;
+			}
+			else
+			{
+				return 0;
+			}
+		}
+	};
+}
+
+#endif //!__RXSAMPLEBEAMFORMERDELAYANDSTDDEV_H__
diff --git a/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h.yaml b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h.yaml
new file mode 100644
index 0000000..4b203bd
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h.yaml
@@ -0,0 +1,46 @@
+---
+MainSourceFile:  '/home/wangyon1/projects/supra-projects/golden/supra/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h'
+Replacements:
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h'
+    Offset:          577
+    Length:          0
+    ReplacementText: '#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h'
+    Offset:          1385
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h'
+    Offset:          4750
+    Length:          8
+    ReplacementText: 'sycl::sqrt(sd)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h'
+    Offset:          4932
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h'
+    Offset:          7652
+    Length:          8
+    ReplacementText: 'sycl::sqrt(sd)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+...
diff --git a/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h
new file mode 100644
index 0000000..0684605
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h
@@ -0,0 +1,186 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2017, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __RXSAMPLEBEAMFORMERDELAYANDSUM_H__
+#define __RXSAMPLEBEAMFORMERDELAYANDSUM_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "USImageProperties.h"
+#include "WindowFunction.h"
+#include "RxBeamformerCommon.h"
+
+//TODO ALL ELEMENT/SCANLINE Y positons are actually Z! Change all variable names accordingly
+namespace supra
+{
+	class RxSampleBeamformerDelayAndSum
+	{
+	public:
+		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
+		static ResultType sampleBeamform3D(
+			ScanlineRxParameters3D::TransmitParameters txParams,
+			const RFType* RF,
+			vec2T<uint32_t> elementLayout,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const LocationType* x_elemsDTsh,
+			const LocationType* z_elemsDTsh,
+			LocationType scanline_x,
+			LocationType scanline_z,
+			LocationType dirX,
+			LocationType dirY,
+			LocationType dirZ,
+			LocationType aDT,
+			LocationType depth,
+			vec2f invMaxElementDistance,
+			LocationType speedOfSound,
+			LocationType dt,
+			int32_t additionalOffset,
+			const WindowFunctionGpu* windowFunction,
+			const WindowFunction::ElementType* functionShared
+		)
+		{
+			float sample = 0.0f;
+			float weightAcum = 0.0f;
+			int numAdds = 0;
+			LocationType initialDelay = txParams.initialDelay;
+			uint32_t txScanlineIdx = txParams.txScanlineIdx;
+			for (uint32_t elemIdxX = txParams.firstActiveElementIndex.x; elemIdxX < txParams.lastActiveElementIndex.x; elemIdxX++)
+			{
+				for (uint32_t elemIdxY = txParams.firstActiveElementIndex.y; elemIdxY < txParams.lastActiveElementIndex.y; elemIdxY++)
+				{
+					uint32_t elemIdx = elemIdxX + elemIdxY*elementLayout.x;
+					uint32_t  channelIdx = elemIdx % numReceivedChannels;
+					LocationType x_elem = x_elemsDTsh[elemIdx];
+					LocationType z_elem = z_elemsDTsh[elemIdx];
+
+					if ((squ(x_elem - scanline_x) + squ(z_elem - scanline_z)) <= aDT)
+					{
+						vec2f elementScanlineDistance = { x_elem - scanline_x, z_elem - scanline_z };
+						float weight = computeWindow3DShared(*windowFunction, functionShared, elementScanlineDistance * invMaxElementDistance);
+						weightAcum += weight;
+						numAdds++;
+						if (interpolateRFlines)
+						{
+							LocationType delayf = initialDelay +
+								computeDelayDTSPACE3D_D(dirX, dirY, dirZ, x_elem, z_elem, scanline_x, scanline_z, depth) + additionalOffset;
+							uint32_t delay = static_cast<uint32_t>(::floor(delayf));
+							delayf -= delay;
+							if (delay < (numTimesteps - 1))
+							{
+								sample +=
+									weight * ((1.0f - delayf) * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps] +
+										delayf  * RF[(delay + 1) + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps]);
+							}
+							else if (delay < numTimesteps && delayf == 0.0)
+							{
+								sample += weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+							}
+						}
+						else
+						{
+							uint32_t delay = static_cast<uint32_t>(::round(
+								initialDelay + computeDelayDTSPACE3D_D(dirX, dirY, dirZ, x_elem, z_elem, scanline_x, scanline_z, depth)) + additionalOffset);
+							if (delay < numTimesteps)
+							{
+								sample += weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+							}
+						}
+					}
+				}
+			}
+			if (numAdds > 0)
+			{
+				return sample / weightAcum * numAdds;
+			}
+			else
+			{
+				return 0;
+			}
+		}
+
+		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
+		static ResultType sampleBeamform2D(
+			ScanlineRxParameters3D::TransmitParameters txParams,
+			const RFType* RF,
+			uint32_t numTransducerElements,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const LocationType* x_elemsDT,
+			LocationType scanline_x,
+			LocationType dirX,
+			LocationType dirY,
+			LocationType dirZ,
+			LocationType aDT,
+			LocationType depth,
+			LocationType invMaxElementDistance,
+			LocationType speedOfSound,
+			LocationType dt,
+			int32_t additionalOffset,
+			const WindowFunctionGpu* windowFunction
+		)
+		{
+			float sample = 0.0f;
+			float weightAcum = 0.0f;
+			int numAdds = 0;
+			LocationType initialDelay = txParams.initialDelay;
+			uint32_t txScanlineIdx = txParams.txScanlineIdx;
+
+			for (int32_t elemIdxX = txParams.firstActiveElementIndex.x; elemIdxX < txParams.lastActiveElementIndex.x; elemIdxX++)
+			{
+				int32_t  channelIdx = elemIdxX % numReceivedChannels;
+				LocationType x_elem = x_elemsDT[elemIdxX];
+				if (abs(x_elem - scanline_x) <= aDT)
+				{
+					float weight = windowFunction->get((x_elem - scanline_x) * invMaxElementDistance);
+					weightAcum += weight;
+					numAdds++;
+					if (interpolateRFlines)
+					{
+						LocationType delayf = initialDelay +
+							computeDelayDTSPACE_D(dirX, dirY, dirZ, x_elem, scanline_x, depth) + additionalOffset;
+						int32_t delay = static_cast<int32_t>(floor(delayf));
+						delayf -= delay;
+						if (delay < (numTimesteps - 1))
+						{
+							sample +=
+								weight * ((1.0f - delayf) * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps] +
+									delayf  * RF[(delay + 1) + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps]);
+						}
+						else if (delay < numTimesteps && delayf == 0.0)
+						{
+							sample += weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+						}
+					}
+					else
+					{
+						int32_t delay = static_cast<int32_t>(round(
+							initialDelay + computeDelayDTSPACE_D(dirX, dirY, dirZ, x_elem, scanline_x, depth)) + additionalOffset);
+						if (delay < numTimesteps)
+						{
+							sample += weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+						}
+					}
+				}
+			}
+			if (numAdds > 0)
+			{
+				return sample / weightAcum * numAdds;
+			}
+			else
+			{
+				return 0;
+			}
+		}
+	};
+}
+
+#endif //!__RXSAMPLEBEAMFORMERDELAYANDSUM_H__
diff --git a/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h.yaml b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h.yaml
new file mode 100644
index 0000000..28066a6
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h.yaml
@@ -0,0 +1,30 @@
+---
+MainSourceFile:  '/home/wangyon1/projects/supra-projects/golden/supra/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h'
+Replacements:
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h'
+    Offset:          571
+    Length:          0
+    ReplacementText: '#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h'
+    Offset:          930
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h'
+    Offset:          3987
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+...
diff --git a/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h
new file mode 100644
index 0000000..9b44dc3
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h
@@ -0,0 +1,137 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2017, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __RXSAMPLEBEAMFORMERTESTSIGNAL_H__
+#define __RXSAMPLEBEAMFORMERTESTSIGNAL_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "USImageProperties.h"
+#include "WindowFunction.h"
+#include "RxBeamformerCommon.h"
+
+//TODO ALL ELEMENT/SCANLINE Y positons are actually Z! Change all variable names accordingly
+namespace supra
+{
+	class RxSampleBeamformerTestSignal
+	{
+	public:
+		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
+		static ResultType sampleBeamform3D(
+			ScanlineRxParameters3D::TransmitParameters txParams,
+			const RFType* RF,
+			vec2T<uint32_t> elementLayout,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const LocationType* x_elemsDTsh,
+			const LocationType* z_elemsDTsh,
+			LocationType scanline_x,
+			LocationType scanline_z,
+			LocationType dirX,
+			LocationType dirY,
+			LocationType dirZ,
+			LocationType aDT,
+			LocationType depth,
+			vec2f invMaxElementDistance,
+			LocationType speedOfSound,
+			LocationType dt,
+			int32_t additionalOffset,
+			const WindowFunctionGpu* windowFunction,
+			const WindowFunction::ElementType* functionShared
+		)
+		{
+			constexpr float cylinderSpacing = 6; //[mm]
+			constexpr float cylinderDiameter = 2; //[mm]
+			constexpr float cylinderDepth = 30; //[mm]
+			constexpr int numCylindersHalf = 3;
+
+			float sample = 0.0f;
+
+			vec3f point{ scanline_x + dirX*depth, dirY*depth, scanline_z + dirZ*depth };
+			point = point *dt*speedOfSound; // bring point position back from dt space to world space
+			//check for all cylinders
+			// cylinders along z axis
+			for (int cylinderNo = -numCylindersHalf; cylinderNo <= numCylindersHalf; cylinderNo++)
+			{
+				vec3f cylinderCenter = vec3f{ cylinderNo * cylinderSpacing, cylinderDepth, 0 };
+				vec3f pointInPlane = point;
+				pointInPlane.z = 0;
+				float distance = norm(pointInPlane - cylinderCenter);
+				if (distance <= cylinderDiameter)
+				{
+					sample = 1000;
+				}
+			}
+			// cylinders along x axis
+			for (int cylinderNo = -numCylindersHalf; cylinderNo <= numCylindersHalf; cylinderNo++)
+			{
+				vec3f cylinderCenter = vec3f{ 0, cylinderDepth,  cylinderNo * cylinderSpacing };
+				vec3f pointInPlane = point;
+				pointInPlane.x = 0;
+				float distance = norm(pointInPlane - cylinderCenter);
+				if (distance <= cylinderDiameter)
+				{
+					sample = 1000;
+				}
+			}
+
+			return sample;
+		}
+
+		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
+		static ResultType sampleBeamform2D(
+			ScanlineRxParameters3D::TransmitParameters txParams,
+			const RFType* RF,
+			uint32_t numTransducerElements,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const LocationType* x_elemsDT,
+			LocationType scanline_x,
+			LocationType dirX,
+			LocationType dirY,
+			LocationType dirZ,
+			LocationType aDT,
+			LocationType depth,
+			LocationType invMaxElementDistance,
+			LocationType speedOfSound,
+			LocationType dt,
+			int32_t additionalOffset,
+			const WindowFunctionGpu* windowFunction
+		)
+		{
+			constexpr float cylinderSpacing = 6; //[mm]
+			constexpr float cylinderDiameter = 2; //[mm]
+			constexpr float cylinderDepth = 30; //[mm]
+			constexpr int numCylindersHalf = 3;
+
+			float sample = 0.0f;
+
+			vec3f point{ scanline_x + dirX*depth, dirY*depth, dirZ*depth };
+			point = point *dt*speedOfSound; // bring point position back from dt space to world space
+			//check for all cylinders
+			// cylinders along z axis
+			for (int cylinderNo = -numCylindersHalf; cylinderNo <= numCylindersHalf; cylinderNo++)
+			{
+				vec3f cylinderCenter = vec3f{ cylinderNo * cylinderSpacing, cylinderDepth, 0 };
+				vec3f pointInPlane = point;
+				pointInPlane.z = 0;
+				float distance = norm(pointInPlane - cylinderCenter);
+				if (distance <= cylinderDiameter)
+				{
+					sample = 1000;
+				}
+			}
+			return sample;
+		}
+	};
+}
+
+#endif //!__RXSAMPLEBEAMFORMERTESTSIGNAL_H__
diff --git a/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h.yaml b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h.yaml
new file mode 100644
index 0000000..921a583
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h.yaml
@@ -0,0 +1,30 @@
+---
+MainSourceFile:  '/home/wangyon1/projects/supra-projects/golden/supra/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h'
+Replacements:
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h'
+    Offset:          569
+    Length:          0
+    ReplacementText: '#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h'
+    Offset:          927
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h'
+    Offset:          2925
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+...
diff --git a/oneapi/src/SupraLib/Beamformer/ScanConverter.dp.cpp b/oneapi/src/SupraLib/Beamformer/ScanConverter.dp.cpp
new file mode 100644
index 0000000..fb8fc72
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/ScanConverter.dp.cpp
@@ -0,0 +1,931 @@
+// ================================================================================================
+// 
+// Copyright (C) 2016, Rüdiger Göbl - all rights reserved
+// Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.
+//
+//          Rüdiger Göbl
+//          Email r.goebl@tum.de
+//          Chair for Computer Aided Medical Procedures
+//          Technische Universität München
+//          Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License, version 2.1, as published by the Free Software Foundation.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this program.  If not, see
+// <http://www.gnu.org/licenses/>.
+//
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "ScanConverter.h"
+#include <cassert>
+#include <utilities/cudaUtility.h>
+#include <utilities/Logging.h>
+
+#include <dpct/dpl_utils.hpp>
+#include <oneapi/dpl/execution>
+#include <oneapi/dpl/algorithm>
+#include <cmath>
+
+using namespace std;
+
+namespace supra
+{
+	class ScanConverterInternals {
+	public:
+		typedef ScanConverter::IndexType IndexType;
+		typedef ScanConverter::WeightType WeightType;
+
+		static constexpr double m_tetrahedronTestDistanceThreshold = 1e-9;
+		static constexpr int m_mappingMaxIterations = ScanConverter::m_mappingMaxIterations;
+		static constexpr double m_mappingDistanceThreshold = ScanConverter::m_mappingDistanceThreshold;
+
+		template <typename Tf, typename Ti>
+		static void computeParametersVoxel3D(
+			const Tf &sampleDistance,
+			const vec2T<Ti> &scanlineLayout,
+			const int &scanlineIdxX,
+			const int &scanlineIdxY,
+			const vec3T<Tf> &s1,
+			const vec3T<Tf> &e1,
+			const vec3T<Tf> &s2,
+			const vec3T<Tf> &e2,
+			const vec3T<Tf> &s3,
+			const vec3T<Tf> &e3,
+			const vec3T<Tf> &s4,
+			const vec3T<Tf> &e4,
+			const vec3T<Tf> &scanline1Pos,
+			const vec3T<Tf> &scanline1Dir,
+			const vec3T<Tf> &scanline2Pos,
+			const vec3T<Tf> &scanline2Dir,
+			const vec3T<Tf> &scanline3Pos,
+			const vec3T<Tf> &scanline3Dir,
+			const vec3T<Tf> &scanline4Pos,
+			const vec3T<Tf> &scanline4Dir,
+			const Tf &startDepth,
+			const Tf &endDepth,
+			const vec3T<Ti> &imageSize,
+			const vec3T<Ti> &voxel,
+			const vec3T<Tf> &voxelPos,
+			uint8_t* __restrict__ maskBuf,
+			uint32_t* __restrict__ sampleIdxBuf,
+			float* __restrict__ weightXBuf,
+			float* __restrict__ weightYBuf,
+			float* __restrict__ weightZBuf
+		)
+		{
+			if (pointInsideTetrahedron(s1, s2, s3, e1, voxelPos) ||
+				pointInsideTetrahedron(s2, s4, s3, e4, voxelPos) ||
+				pointInsideTetrahedron(s2, e1, e2, e4, voxelPos) ||
+				pointInsideTetrahedron(s3, e3, e1, e4, voxelPos) ||
+				pointInsideTetrahedron(s2, s3, e1, e4, voxelPos))
+			{
+
+				thrust::pair<vec3T<Tf>, bool> params = mapToParameters3D<Tf, Ti>(
+					scanline1Pos,
+					scanline2Pos,
+					scanline3Pos,
+					scanline4Pos,
+					scanline1Dir,
+					scanline2Dir,
+					scanline3Dir,
+					scanline4Dir,
+					startDepth, endDepth, voxelPos);
+
+				if (params.second)
+				{
+					size_t voxelIndex = voxel.x + voxel.y*imageSize.x + voxel.z*imageSize.x*imageSize.y;
+					maskBuf[voxelIndex] = 1;
+
+					Tf t1 = params.first.x;
+					Tf t2 = params.first.y;
+					Tf d = params.first.z + 0;
+
+					IndexType  sampleIdxScanline = static_cast<IndexType>(sycl::floor(d / sampleDistance));
+					WeightType weightY = static_cast<WeightType>(d / sampleDistance - sampleIdxScanline);
+					WeightType weightX = static_cast<WeightType>(t1);
+					WeightType weightZ = static_cast<WeightType>(t2);
+
+					IndexType sampleIdx = static_cast<IndexType>(sampleIdxScanline*scanlineLayout.x*scanlineLayout.y +
+						scanlineIdxX + scanlineIdxY*scanlineLayout.x);
+
+					sampleIdxBuf[voxelIndex] = sampleIdx;
+					weightXBuf[voxelIndex] = weightX;
+					weightYBuf[voxelIndex] = weightY;
+					weightZBuf[voxelIndex] = weightZ;
+				}
+			}
+		}
+
+		/**
+		 * Tests whether point p lies within the tetrahedron defined by a, b, c, d.
+		 *
+		 * For the test, the barycentric coordinates of p are computed and checked for equal sign.
+		 */
+		template <typename Tf>
+		static bool pointInsideTetrahedron(const vec3T<Tf> & a, const vec3T<Tf> & b, const vec3T<Tf> & c, const vec3T<Tf> & d, const vec3T<Tf> & p)
+		{
+			Tf w0 = barycentricCoordinate3D(a, b, c, d);
+
+			Tf w1 = barycentricCoordinate3D(p, b, c, d);
+			Tf w2 = barycentricCoordinate3D(a, p, c, d);
+			Tf w3 = barycentricCoordinate3D(a, b, p, d);
+			Tf w4 = barycentricCoordinate3D(a, b, c, p);
+
+			return w0 > 0 &&
+				w1 >= -m_tetrahedronTestDistanceThreshold &&
+				w2 >= -m_tetrahedronTestDistanceThreshold &&
+				w3 >= -m_tetrahedronTestDistanceThreshold &&
+				w4 >= -m_tetrahedronTestDistanceThreshold;
+		}
+
+		template <typename Tf>
+		static Tf barycentricCoordinate3D(const vec3T<Tf> & a, const vec3T<Tf> & b, const vec3T<Tf> & c, const vec3T<Tf> & p)
+		{
+			//computes the determinant of 
+			//[a_x, a_y, a_z, 1]
+			//[b_x, b_y, b_z, 1]
+			//[c_x, c_y, c_z, 1]
+			//[p_x, p_y, p_z, 1]
+
+			// reducing 12 multiplications per compute
+			const Tf axby = a.x*b.y;
+			const Tf cypz = c.y*p.z;
+			const Tf axbz = a.x*b.z;
+			const Tf czpy = c.z*p.y;
+			const Tf aybx = a.y*b.x;
+			const Tf cxpz = c.x*p.z;
+			const Tf aybz = a.y*b.z;
+			const Tf czpx = c.z*p.x;
+			const Tf azbx = a.z*b.x;
+			const Tf cxpy = c.x*p.y;
+			const Tf azby = a.z*b.y;
+			const Tf cypx = c.y*p.x;
+
+			return 
+				(axby-aybx)*(c.z-p.z) + (aybz-azby)*(c.x-p.x) +
+				(azbx-axbz)*(c.y-p.y) + (cypz-czpy)*(a.x-b.x) -
+				(cxpz-czpx)*(a.y-b.y) + (cxpy-cypx)*(a.z-b.z);
+			// reducing 18 multiplications with the updated return statement per compute 			
+		}
+
+		template <typename Tf>
+		static vec3T<Tf> pointPlaneConnection(const vec3T<Tf> & a, const vec3T<Tf> & na, const vec3T<Tf> & x)
+		{
+			return dot(na, (x - a))*na;
+		}
+
+		template <typename Tf, typename Ti>
+		static thrust::pair<vec3T<Tf>, bool> mapToParameters3D(
+			const vec3T<Tf> & a,
+			const vec3T<Tf> & ax,
+			const vec3T<Tf> & ay,
+			const vec3T<Tf> & axy,
+			const vec3T<Tf> & da,
+			const vec3T<Tf> & dax,
+			const vec3T<Tf> & day,
+			const vec3T<Tf> & daxy,
+			Tf startDepth,
+			Tf endDepth,
+			const vec3T<Tf> & x)
+		{
+			vec3T<Tf> normalXLow = normalize(cross(da, (ay + day) - a));
+			vec3T<Tf> normalYLow = normalize(cross((ax + dax) - a, da));
+			vec3T<Tf> normalXHigh = normalize(cross(dax, (axy + daxy) - ax));
+			vec3T<Tf> normalYHigh = normalize(cross((axy + daxy) - ay, day));
+
+			//find t via binary search
+			vec2T<Tf> lowT = { 0, 0 };
+			vec2T<Tf> highT = { 1, 1 };
+			vec3T<Tf> lowConnX = pointPlaneConnection(a, normalXLow, x);
+			vec3T<Tf> highConnX = pointPlaneConnection(ax, normalXHigh, x);
+			vec3T<Tf> lowConnY = pointPlaneConnection(a, normalYLow, x);
+			vec3T<Tf> highConnY = pointPlaneConnection(ay, normalYHigh, x);
+			vec2T<Tf> lowDist = { norm(lowConnX), norm(lowConnY) };
+			vec2T<Tf> highDist = { norm(highConnX), norm(highConnY) };
+
+			if (dot(lowConnX, highConnX) > 0 || dot(lowConnY, highConnY) > 0)
+			{
+				return thrust::pair<vec3T<Tf>, bool>(vec3T<Tf>{ 0, 0, 0 }, false);
+			}
+
+			vec2T<Tf> dist = { 1e10, 1e10 };
+			vec2T<Tf> t = (highT - lowT) / 2 + lowT;
+			vec3T<Tf> planeBaseX1;
+			vec3T<Tf> planeBaseY1;
+			vec3T<Tf> planeBaseX2;
+			vec3T<Tf> planeBaseY2;
+			for (int numIter = 0; numIter < m_mappingMaxIterations &&
+				(dist.x > m_mappingDistanceThreshold || dist.y > m_mappingDistanceThreshold); numIter++)
+			{
+				t = (1 - highDist / (highDist + lowDist))*highT + (1 - lowDist / (highDist + lowDist))*lowT;
+
+				planeBaseX1 = (1 - t.x)*a + t.x*ax;
+				planeBaseX2 = (1 - t.x)*ay + t.x*axy;
+				planeBaseY1 = (1 - t.y)*a + t.y*ay;
+				planeBaseY2 = (1 - t.y)*ax + t.y*axy;
+				vec3T<Tf> dir = slerp3(slerp3(da, dax, t.x), slerp3(day, daxy, t.x), t.y);
+				vec3T<Tf> normal_x = normalize(cross(dir, planeBaseX2 - planeBaseX1));
+				vec3T<Tf> normal_y = normalize(cross(planeBaseY2 - planeBaseY1, dir));
+
+				vec3T<Tf> connX = pointPlaneConnection(planeBaseX1, normal_x, x);
+				vec3T<Tf> connY = pointPlaneConnection(planeBaseY1, normal_y, x);
+
+				dist.x = norm(connX);
+				dist.y = norm(connY);
+
+				if (dot(highConnX, connX) > M_EPS)
+				{
+					highT.x = t.x;
+					highConnX = connX;
+					highDist.x = dist.x;
+				}
+				else if (dot(lowConnX, connX) > M_EPS)
+				{
+					lowT.x = t.x;
+					lowConnX = connX;
+					lowDist.x = dist.x;
+				}
+
+				if (dot(highConnY, connY) > M_EPS)
+				{
+					highT.y = t.y;
+					highConnY = connY;
+					highDist.y = dist.y;
+				}
+				else if (dot(lowConnY, connY) > M_EPS)
+				{
+					lowT.y = t.y;
+					lowConnY = connY;
+					lowDist.y = dist.y;
+				}
+			}
+
+			vec3T<Tf> lineBase = (1 - t.y)*planeBaseX1 + t.y*planeBaseX2;
+			Tf d = norm(x - lineBase);
+
+			return thrust::pair<vec3T<Tf>, bool>(vec3T<Tf>{ t.x, t.y, d }, true);
+		}
+	};
+
+	template <typename Tf, typename Ti>
+	void
+		
+		computeParameterBB3D(
+			const Tf sampleDistance,
+			const vec2T<Ti> scanlineLayout,
+			const int scanlineIdxX,
+			const int scanlineIdxY,
+			const vec3T<Tf> s1,
+			const vec3T<Tf> e1,
+			const vec3T<Tf> s2,
+			const vec3T<Tf> e2,
+			const vec3T<Tf> s3,
+			const vec3T<Tf> e3,
+			const vec3T<Tf> s4,
+			const vec3T<Tf> e4,
+			const vec3T<Tf> scanline1Pos,
+			const vec3T<Tf> scanline1Dir,
+			const vec3T<Tf> scanline2Pos,
+			const vec3T<Tf> scanline2Dir,
+			const vec3T<Tf> scanline3Pos,
+			const vec3T<Tf> scanline3Dir,
+			const vec3T<Tf> scanline4Pos,
+			const vec3T<Tf> scanline4Dir,
+			const Tf startDepth,
+			const Tf endDepth,
+			const vec3T<Ti> imageSize,
+			const vec3T<Tf> bbMin,
+			const vec3T<Ti> tetMinVoxel,
+			const vec3T<Ti> tetMaxVoxel,
+			const Tf resolution,
+			uint8_t* __restrict__ maskBuf,
+			uint32_t* __restrict__ sampleIdxBuf,
+			float* __restrict__ weightXBuf,
+			float* __restrict__ weightYBuf,
+			float* __restrict__ weightZBuf
+		,
+			sycl::nd_item<3> item_ct1)
+	{
+		vec3T<Ti> voxel = vec3T<Ti>{ static_cast<Ti>(item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2)),
+									 static_cast<Ti>(item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1)),
+									 static_cast<Ti>(item_ct1.get_local_range().get(0) * item_ct1.get_group(0)
+													 + item_ct1.get_local_id(0)) };	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		voxel = voxel + tetMinVoxel;
+
+		if (voxel.x <= tetMaxVoxel.x && voxel.y <= tetMaxVoxel.y && voxel.z <= tetMaxVoxel.z)
+		{
+			vec3T<Tf> voxelPos = static_cast<vec3T<Tf>>(voxel) * resolution + bbMin;
+			ScanConverterInternals::computeParametersVoxel3D(
+				sampleDistance,
+				scanlineLayout,
+				scanlineIdxX, scanlineIdxY,
+				s1, e1, s2, e2, s3, e3, s4, e4,
+				scanline1Pos,
+				scanline1Dir,
+				scanline2Pos,
+				scanline2Dir,
+				scanline3Pos,
+				scanline3Dir,
+				scanline4Pos,
+				scanline4Dir,
+				startDepth, endDepth,
+				imageSize,
+				voxel,
+				voxelPos,
+				maskBuf,
+				sampleIdxBuf,
+				weightXBuf,
+				weightYBuf,
+				weightZBuf);
+		}
+	}
+
+	template <typename InputType, typename OutputType, typename WeightType, typename IndexType>
+	void scanConvert2D(
+		uint32_t numScanlines,
+		uint32_t numSamples,
+		uint32_t width,
+		uint32_t height,
+		const uint8_t* __restrict__ mask,
+		const IndexType* __restrict__ sampleIdx,
+		const WeightType* __restrict__ weightX,
+		const WeightType* __restrict__ weightY,
+		const InputType* __restrict__ scanlines,
+		OutputType* __restrict__ image,
+		sycl::nd_item<3> item_ct1)
+	{
+		vec2T<uint32_t> pixelPos{ item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2),
+								  item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1) };  //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+
+		if (pixelPos.x < width && pixelPos.y < height)
+		{
+			IndexType pixelIdx = pixelPos.x + pixelPos.y*width;
+			float val = 0;
+			if (mask[pixelIdx])
+			{
+				IndexType sIdx = sampleIdx[pixelIdx];
+				WeightType wX = weightX[pixelIdx];
+				WeightType wY = weightY[pixelIdx];
+
+				val = (1 - wY)*((1 - wX)*scanlines[sIdx] +
+					wX *scanlines[sIdx + 1]) +
+					wY *((1 - wX)*scanlines[sIdx + numScanlines] +
+						wX *scanlines[sIdx + 1 + numScanlines]);
+			}
+			image[pixelIdx] = clampCast<OutputType>(val);
+		}
+	}
+
+	template <typename InputType, typename OutputType, typename WeightType, typename IndexType>
+	void scanConvert3D(
+		uint32_t numScanlinesX,
+		uint32_t numScanlinesY,
+		uint32_t numSamples,
+		uint32_t width,
+		uint32_t height,
+		uint32_t depth,
+		const uint8_t* __restrict__ mask,
+		const IndexType* __restrict__ sampleIdx,
+		const WeightType* __restrict__ weightX,
+		const WeightType* __restrict__ weightY,
+		const WeightType* __restrict__ weightZ,
+		const InputType* __restrict__ scanlines,
+		OutputType* __restrict__ image,
+		sycl::nd_item<3> item_ct1)
+	{
+		vec3T<uint32_t> pixelPos{ item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2),
+								  item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1),
+								  item_ct1.get_local_range().get(0) * item_ct1.get_group(0) + item_ct1.get_local_id(0) };  //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+
+		if (pixelPos.x < width && pixelPos.y < height)
+		{
+			IndexType pixelIdx = pixelPos.x + pixelPos.y*width + pixelPos.z*width*height;
+			float val = 0;
+			if (mask[pixelIdx])
+			{
+				uint32_t numScanlines = numScanlinesX*numScanlinesY;
+				IndexType sIdx = sampleIdx[pixelIdx];
+				WeightType wX = weightX[pixelIdx];
+				WeightType wY = weightY[pixelIdx];
+				WeightType wZ = weightZ[pixelIdx];
+
+
+				val =
+					(1 - wY)*((1 - wZ)*((1 - wX)*scanlines[sIdx] +
+						wX *scanlines[sIdx + 1]) +
+						wZ *((1 - wX)*scanlines[sIdx + numScanlinesX] +
+							wX *scanlines[sIdx + 1 + numScanlinesX])) +
+					wY* ((1 - wZ)*((1 - wX)*scanlines[sIdx + numScanlines] +
+						wX *scanlines[sIdx + 1 + numScanlines]) +
+						wZ *((1 - wX)*scanlines[sIdx + numScanlinesX + numScanlines] +
+							wX *scanlines[sIdx + 1 + numScanlinesX + numScanlines]));
+			}
+			image[pixelIdx] = clampCast<OutputType>(val);
+		}
+	}
+
+	shared_ptr<Container<uint8_t> > ScanConverter::getMask()
+	{
+		return m_mask;
+	}
+
+	template<typename InputType, typename OutputType>
+	shared_ptr<Container<OutputType> > ScanConverter::convert(const shared_ptr<USImage>& inImage)
+	{
+		uint32_t numScanlines = (uint32_t)inImage->getImageProperties()->getNumScanlines();
+		vec2s scanlineLayout = inImage->getImageProperties()->getScanlineLayout();
+		uint32_t numSamples = (uint32_t)inImage->getImageProperties()->getNumSamples();
+
+		shared_ptr<const Container<InputType> > pScanlineData = inImage->getData<InputType>();
+		if (pScanlineData->isHost())
+		{
+			pScanlineData = make_shared<Container<InputType> >(LocationGpu, *pScanlineData);
+		}
+		auto pConv = make_shared<Container<OutputType> >(LocationGpu, pScanlineData->getStream(), m_imageSize.x*m_imageSize.y*m_imageSize.z);
+
+		if (m_is2D)
+		{
+			sycl::range<3> blockSize(1, 256, 1);
+			sycl::range<3> gridSize(1, static_cast<unsigned int>((m_imageSize.y + blockSize[ 1 ] - 1) / blockSize[ 1 ]),
+									static_cast<unsigned int>((m_imageSize.x + blockSize[ 2 ] - 1) / blockSize[ 2 ]));
+			scanConvert2D << <gridSize, blockSize, 0, pScanlineData->getStream()>> > (
+				numScanlines,
+				numSamples,
+				(uint32_t)m_imageSize.x,
+				(uint32_t)m_imageSize.y,
+				m_mask->get(),
+				m_sampleIdx->get(),
+				m_weightX->get(),
+				m_weightY->get(),
+				pScanlineData->get(),
+				pConv->get());
+			/*
+			DPCT1010:20: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+			*/
+			cudaSafeCall(0);
+		}
+		else
+		{
+			sycl::range<3> blockSize(1, 256, 1);
+			sycl::range<3> gridSize(static_cast<unsigned int>((m_imageSize.z + blockSize[ 0 ] - 1) / blockSize[ 0 ]), static_cast<unsigned int>((m_imageSize.y + blockSize[ 1 ] - 1) / blockSize[ 1 ]),
+									static_cast<unsigned int>((m_imageSize.x + blockSize[ 2 ] - 1) / blockSize[ 2 ]));
+			scanConvert3D << <gridSize, blockSize, 0, pScanlineData->getStream()>> > (
+				(uint32_t)scanlineLayout.x,
+				(uint32_t)scanlineLayout.y,
+				numSamples,
+				(uint32_t)m_imageSize.x,
+				(uint32_t)m_imageSize.y,
+				(uint32_t)m_imageSize.z,
+				m_mask->get(),
+				m_sampleIdx->get(),
+				m_weightX->get(),
+				m_weightY->get(),
+				m_weightZ->get(),
+				pScanlineData->get(),
+				pConv->get());
+			/*
+			DPCT1010:21: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+			*/
+			cudaSafeCall(0);
+		}
+		return pConv;
+	}
+
+	template
+		std::shared_ptr<Container<uint8_t> > ScanConverter::convert<uint8_t, uint8_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<int16_t> > ScanConverter::convert<uint8_t, int16_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<float> > ScanConverter::convert<uint8_t, float>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<uint8_t> > ScanConverter::convert<int16_t, uint8_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<int16_t> > ScanConverter::convert<int16_t, int16_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<float> > ScanConverter::convert<int16_t, float>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<uint8_t> > ScanConverter::convert<float, uint8_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<int16_t> > ScanConverter::convert<float, int16_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<float> > ScanConverter::convert<float, float>(const std::shared_ptr<USImage>& inImage);
+
+	void ScanConverter::updateInternals(const std::shared_ptr<const USImageProperties>& inImageProps)
+	{
+  dpct::device_ext& dev_ct1 = dpct::get_current_device();
+  sycl::queue&	  q_ct1 = dev_ct1.default_queue();
+		logging::log_log("Scanconverter: Updating scanconversion internals");
+
+		//Check the scanline configuration for validity
+		m_is2D = inImageProps->is2D();
+
+		vec2s layout = inImageProps->getScanlineLayout();
+		double startDepth = 0;
+		double endDepth = inImageProps->getDepth();
+		double resolution = inImageProps->getImageResolution();
+		auto scanlines = inImageProps->getScanlineInfo();
+		logging::log_error_if(!scanlines, "ScanConverter: No scanlines have been attached to the USImageProperties!");
+
+		bool scanlinesGood = scanlines.operator bool();
+
+		if (scanlinesGood)
+		{
+			for (size_t scanlineIdxY = 0; scanlineIdxY < layout.y; scanlineIdxY++)
+			{
+				for (size_t scanlineIdxX = 0; scanlineIdxX < layout.x; scanlineIdxX++)
+				{
+					if (scanlineIdxX > 0)
+					{
+						vec start = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec startbefore = (*scanlines)[scanlineIdxX - 1][scanlineIdxY].getPoint(startDepth);
+						vec end = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec endbefore = (*scanlines)[scanlineIdxX - 1][scanlineIdxY].getPoint(endDepth);
+
+						//scanline start points are increasing in x
+						scanlinesGood = scanlinesGood &&
+							start.x >= startbefore.x;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  1 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanline end points are increasing in x, that means scanlines do not intersect
+						scanlinesGood = scanlinesGood &&
+							end.x >= endbefore.x;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  2 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines can not be identical
+						scanlinesGood = scanlinesGood &&
+							(start.x > startbefore.x || end.x > endbefore.x);
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  3 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines are not skew
+						scanlinesGood = scanlinesGood &&
+							abs(det(start - endbefore, startbefore - endbefore, end - endbefore)) < m_skewnessTestThreshold;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  4 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+					}
+
+					if (scanlineIdxY > 0)
+					{
+						vec start = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec startbefore = (*scanlines)[scanlineIdxX][scanlineIdxY - 1].getPoint(startDepth);
+						vec end = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec endbefore = (*scanlines)[scanlineIdxX][scanlineIdxY - 1].getPoint(endDepth);
+
+						//scanline start points are increasing in z
+						scanlinesGood = scanlinesGood &&
+							start.z >= startbefore.z;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  5 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanline end points are increasing in z, that means scanlines do not intersect
+						scanlinesGood = scanlinesGood &&
+							end.z >= endbefore.z;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  6 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines can not be identical
+						scanlinesGood = scanlinesGood &&
+							(start.z > startbefore.z || end.z > endbefore.z);
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  7 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines are not skew
+						scanlinesGood = scanlinesGood &&
+							abs(det(start - endbefore, startbefore - endbefore, end - endbefore)) < m_skewnessTestThreshold;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  8 ", scanlineIdxX, ", ", scanlineIdxY, "   det = ", det(start - endbefore, startbefore - endbefore, end - endbefore));
+						}
+					}
+				}
+			}
+		}
+
+		if (scanlinesGood)
+		{
+			//find scan bounding box
+			vec bbMin{ numeric_limits<double>::max(),  numeric_limits<double>::max(),  numeric_limits<double>::max() };
+			vec bbMax{ -numeric_limits<double>::max(), -numeric_limits<double>::max(), -numeric_limits<double>::max() };
+			for (size_t scanlineIdxY = 0; scanlineIdxY < layout.y; scanlineIdxY++)
+			{
+				for (size_t scanlineIdxX = 0; scanlineIdxX < layout.x; scanlineIdxX++)
+				{
+					vec p1 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+					vec p2 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+					bbMin = { min(bbMin.x, p1.x), min(bbMin.y, p1.y), min(bbMin.z, p1.z) };
+					bbMax = { max(bbMax.x, p1.x), max(bbMax.y, p1.y), max(bbMax.z, p1.z) };
+					bbMin = { min(bbMin.x, p2.x), min(bbMin.y, p2.y), min(bbMin.z, p2.z) };
+					bbMax = { max(bbMax.x, p2.x), max(bbMax.y, p2.y), max(bbMax.z, p2.z) };
+				}
+			}
+			m_bbMin = bbMin;
+			m_bbMax = bbMax;
+
+			//compute image size
+			m_imageSize = static_cast<vec3s>(ceil((bbMax - bbMin) / resolution)) + 1;
+			m_imageSize.x = max(m_imageSize.x, (size_t)1);
+			m_imageSize.y = max(m_imageSize.y, (size_t)1);
+			m_imageSize.z = max(m_imageSize.z, (size_t)1);
+
+			// create buffers
+			size_t numelBuffers = m_imageSize.x*m_imageSize.y*m_imageSize.z;
+			/*m_mask = make_shared<Container<uint8_t> >(ContainerLocation::LocationHost, numelBuffers);
+			m_sampleIdx = make_shared<Container<IndexType> >(ContainerLocation::LocationHost, numelBuffers);
+			m_weightX = make_shared<Container<WeightType> >(ContainerLocation::LocationHost, numelBuffers);
+			m_weightY = make_shared<Container<WeightType> >(ContainerLocation::LocationHost, numelBuffers);
+			m_weightZ = make_shared<Container<WeightType> >(ContainerLocation::LocationHost, numelBuffers);*/
+			m_mask = make_shared<Container<uint8_t>>(ContainerLocation::LocationGpu, &q_ct1, numelBuffers);
+			m_sampleIdx = make_shared<Container<IndexType>>(ContainerLocation::LocationGpu, &q_ct1, numelBuffers);
+			m_weightX = make_shared<Container<WeightType>>(ContainerLocation::LocationGpu, &q_ct1, numelBuffers);
+			m_weightY = make_shared<Container<WeightType>>(ContainerLocation::LocationGpu, &q_ct1, numelBuffers);
+			m_weightZ = make_shared<Container<WeightType>>(ContainerLocation::LocationGpu, &q_ct1, numelBuffers);
+
+			//create image mask
+			/*
+			DPCT1003:22: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((q_ct1.memset(m_mask->get(), 0, m_mask->size() * sizeof(uint8_t)), 0));
+
+			if (m_is2D)
+			{
+				//2D is computed on the cpu at the moment -> copy
+				m_mask = make_shared<Container<uint8_t> >(LocationHost, *m_mask);
+				m_sampleIdx = make_shared<Container<IndexType> >(LocationHost, *m_sampleIdx);
+				m_weightX = make_shared<Container<WeightType> >(LocationHost, *m_weightX);
+				m_weightY = make_shared<Container<WeightType> >(LocationHost, *m_weightY);
+				m_weightZ = make_shared<Container<WeightType> >(LocationHost, *m_weightZ);
+
+				vec2 bb2DMin{ m_bbMin.x, m_bbMin.y };
+				assert(layout.x > 1);
+				// From now on, we assume everything is in the xy-plane
+				// -----------------------------------------
+				for (size_t scanlineIdxY = 0; scanlineIdxY < layout.y; scanlineIdxY++)
+				{
+#pragma omp parallel for schedule(dynamic, 8)
+					for (int scanlineIdxX = 0; scanlineIdxX < layout.x - 1; scanlineIdxX++)
+					{
+						vec start3 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec startN3 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(startDepth);
+						vec end3 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec endN3 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(endDepth);
+						vec2 start = { start3.x, start3.y };
+						vec2 startN = { startN3.x, startN3.y };
+						vec2 end = { end3.x, end3.y };
+						vec2 endN = { endN3.x, endN3.y };
+
+						// find bounding box of the two scanlines
+						vec2 quadMinWorld = { std::min(std::min(std::min(start.x, startN.x), end.x), endN.x), std::min(std::min(std::min(start.y, startN.y), end.y), endN.y) };
+						vec2 quadMaxWorld = { std::max(std::max(std::max(start.x, startN.x), end.x), endN.x), std::max(std::max(std::max(start.y, startN.y), end.y), endN.y) };
+
+						vec2s quadMinPixel = static_cast<vec2s>(floor((quadMinWorld - bb2DMin) / resolution));
+						vec2s quadMaxPixel = static_cast<vec2s>(ceil((quadMaxWorld - bb2DMin) / resolution));
+
+						// check the pixels in the quad bounding box and mark the inside ones
+						vec2s pixel;
+						for (pixel.x = quadMinPixel.x; pixel.x <= quadMaxPixel.x; pixel.x++)
+						{
+							for (pixel.y = quadMinPixel.y; pixel.y <= quadMaxPixel.y; pixel.y++)
+							{
+								vec2 pixelPos = static_cast<vec2>(pixel) * resolution + bb2DMin;
+								if (pointInsideTriangle(endN, end, start, pixelPos) ||
+									pointInsideTriangle(start, startN, endN, pixelPos))
+								{
+									m_mask->get()[pixel.x + pixel.y*m_imageSize.x] = 1;
+
+									vec2 params = mapToParameters2D(
+										(*scanlines)[scanlineIdxX][scanlineIdxY].position,
+										(*scanlines)[scanlineIdxX + 1][scanlineIdxY].position,
+										(*scanlines)[scanlineIdxX][scanlineIdxY].direction,
+										(*scanlines)[scanlineIdxX + 1][scanlineIdxY].direction,
+										startDepth, endDepth, { pixelPos.x, pixelPos.y, 0.0 });
+									double t = params.x;
+									double d = params.y;
+
+									IndexType  sampleIdxScanline = static_cast<IndexType>(std::floor(d / inImageProps->getSampleDistance()));
+									WeightType weightY = static_cast<WeightType>(d - (sampleIdxScanline*inImageProps->getSampleDistance()));
+									WeightType weightX = static_cast<WeightType>(t);
+
+									IndexType sampleIdx = static_cast<IndexType>(sampleIdxScanline*inImageProps->getNumScanlines() +
+										scanlineIdxX + scanlineIdxY*layout.x);
+
+									m_sampleIdx->get()[pixel.x + pixel.y*m_imageSize.x] = sampleIdx;
+									m_weightX->get()[pixel.x + pixel.y*m_imageSize.x] = weightX;
+									m_weightY->get()[pixel.x + pixel.y*m_imageSize.x] = weightY;
+								}
+							}
+						}
+					}
+				}
+
+				//2D is computed on the cpu at the moment -> copy
+				m_mask = make_shared<Container<uint8_t> >(LocationGpu, *m_mask);
+				m_sampleIdx = make_shared<Container<IndexType> >(LocationGpu, *m_sampleIdx);
+				m_weightX = make_shared<Container<WeightType> >(LocationGpu, *m_weightX);
+				m_weightY = make_shared<Container<WeightType> >(LocationGpu, *m_weightY);
+				m_weightZ = make_shared<Container<WeightType> >(LocationGpu, *m_weightZ);
+			}
+			else {
+				// 3D case
+				for (int scanlineIdxY = 0; scanlineIdxY < layout.y - 1; scanlineIdxY++)
+				{
+					//#pragma omp parallel for schedule(dynamic, 1)
+					for (int scanlineIdxX = 0; scanlineIdxX < layout.x - 1; scanlineIdxX++)
+					{
+						vec s1 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec e1 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec s2 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(startDepth);
+						vec e2 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(endDepth);
+						vec s3 = (*scanlines)[scanlineIdxX][scanlineIdxY + 1].getPoint(startDepth);
+						vec e3 = (*scanlines)[scanlineIdxX][scanlineIdxY + 1].getPoint(endDepth);
+						vec s4 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY + 1].getPoint(startDepth);
+						vec e4 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY + 1].getPoint(endDepth);
+
+						// find bounding box of the four scanlines
+						vec tetMinWorld = min(min(min(s1, s2), min(s3, s4)),
+							min(min(e1, e2), min(e3, e4)));
+						vec tetMaxWorld = max(max(max(s1, s2), max(s3, s4)),
+							max(max(e1, e2), max(e3, e4)));
+
+						vec3s tetMinVoxel = static_cast<vec3s>(floor((tetMinWorld - bbMin) / resolution));
+						vec3s tetMaxVoxel = static_cast<vec3s>(ceil((tetMaxWorld - bbMin) / resolution));
+
+						vec3s numVoxels = tetMaxVoxel - tetMinVoxel + 1;
+						sycl::range<3> blockSize(4, 4, 16);
+						sycl::range<3> gridSize(static_cast<unsigned int>((numVoxels.z + blockSize[ 0 ] - 1) / blockSize[ 0 ]),
+												static_cast<unsigned int>((numVoxels.y + blockSize[ 1 ] - 1) / blockSize[ 1 ]),
+												static_cast<unsigned int>((numVoxels.x + blockSize[ 2 ] - 1) / blockSize[ 2 ]));
+
+						typedef float Tf;
+						typedef int Ti;
+
+						/*
+						DPCT1049:23: The workgroup size passed to the SYCL kernel may exceed the limit. To get the device limit, query info::device::max_work_group_size. Adjust the workgroup size if
+						needed.
+						*/
+												q_ct1.submit([ & ](sycl::handler& cgh) {
+														auto inImageProps_getSampleDistance_ct0 = static_cast<Tf>(inImageProps->getSampleDistance());
+														auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct12 =
+															static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY ].position);
+														auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct13 =
+															static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY ].direction);
+														auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct14 =
+															static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY ].position);
+														auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct15 =
+															static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY ].direction);
+														auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct16 =
+															static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY + 1 ].position);
+														auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct17 =
+															static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY + 1 ].direction);
+														auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct18 =
+															static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY + 1 ].position);
+														auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct19 =
+															static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY + 1 ].direction);
+														auto static_cast_vec3T_Ti_m_imageSize_ct22 = static_cast<vec3T<Ti>>(m_imageSize);
+														auto m_mask_get_ct27 = m_mask->get();
+														auto m_sampleIdx_get_ct28 = m_sampleIdx->get();
+														auto m_weightX_get_ct29 = m_weightX->get();
+														auto m_weightY_get_ct30 = m_weightY->get();
+														auto m_weightZ_get_ct31 = m_weightZ->get();
+
+														cgh.parallel_for(sycl::nd_range<3>(gridSize * blockSize, blockSize), [ = ](sycl::nd_item<3> item_ct1) {
+																computeParameterBB3D<Tf, Ti>(
+																	inImageProps_getSampleDistance_ct0, static_cast<vec2T<Ti>>(layout), scanlineIdxX, scanlineIdxY, static_cast<vec3T<Tf>>(s1),
+																	static_cast<vec3T<Tf>>(e1), static_cast<vec3T<Tf>>(s2), static_cast<vec3T<Tf>>(e2), static_cast<vec3T<Tf>>(s3),
+																	static_cast<vec3T<Tf>>(e3), static_cast<vec3T<Tf>>(s4), static_cast<vec3T<Tf>>(e4),
+																	static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct12,
+																	static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct13,
+																	static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct14,
+																	static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct15,
+																	static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct16,
+																	static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct17,
+																	static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct18,
+																	static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct19, static_cast<Tf>(startDepth), static_cast<Tf>(endDepth),
+																	static_cast_vec3T_Ti_m_imageSize_ct22, static_cast<vec3T<Tf>>(bbMin), static_cast<vec3T<Ti>>(tetMinVoxel),
+																	static_cast<vec3T<Ti>>(tetMaxVoxel), static_cast<Tf>(resolution), m_mask_get_ct27, m_sampleIdx_get_ct28, m_weightX_get_ct29,
+																	m_weightY_get_ct30, m_weightZ_get_ct31, item_ct1);
+														});
+												});
+						/*
+						DPCT1010:24: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+						*/
+						cudaSafeCall(0);
+					}
+				}
+			}
+			/*
+			DPCT1003:25: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((q_ct1.wait(), 0));
+		}
+		else
+		{
+			logging::log_error("ScanConverter: The scanlines are not in the required configuration.");
+		}
+	}
+
+	double ScanConverter::barycentricCoordinate2D(const vec2 & a, const vec2 & b, const vec2 & c)
+	{
+		return (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);
+	}
+
+	bool ScanConverter::pointInsideTriangle(const vec2 & a, const vec2 & b, const vec2 & c, const vec2 & p)
+	{
+		double w0 = barycentricCoordinate2D(b, c, p);
+		double w1 = barycentricCoordinate2D(c, a, p);
+		double w2 = barycentricCoordinate2D(a, b, p);
+
+		// Test if p is on or inside all edges
+		return (w0 >= 0 && w1 >= 0 && w2 >= 0);
+	}
+
+	vec ScanConverter::pointLineConnection(const vec & a, const vec & da, const vec & x)
+	{
+		vec conn = x - a;
+		vec r = conn - dot(da, conn) *da;
+		return r;
+	}
+
+	vec2 ScanConverter::mapToParameters2D(const vec & a, const vec & b, const vec & da, const vec & db, double startDepth, double endDepth, const vec & x)
+	{
+		//find t via binary search
+		double lowT = 0;
+		double highT = 1;
+		vec lowConn = pointLineConnection(a, da, x);
+		vec highConn = pointLineConnection(b, db, x);
+		double lowDist = norm(lowConn);
+		double highDist = norm(highConn);
+
+		if (highConn.x == 0 && highConn.y == 0 && highConn.z == 0)
+		{
+			double t = highT;
+			double d = norm(x - b);
+			return{ t, d };
+		}
+		else if (lowConn.x == 0 && lowConn.y == 0 && lowConn.z == 0)
+		{
+			double t = lowT;
+			double d = norm(x - a);
+			return{ t, d };
+		}
+
+		assert(dot(lowConn, highConn) < 0);
+
+		double dist = 1e10;
+		double t = (highT - lowT) / 2 + lowT;
+		vec lineBase;
+		for (size_t numIter = 0; numIter < m_mappingMaxIterations && dist > m_mappingDistanceThreshold; numIter++)
+		{
+			t = (1 - highDist / (highDist + lowDist))*highT + (1 - lowDist / (highDist + lowDist))*lowT;
+
+			lineBase = (1 - t)*a + t*b;
+			vec lineDir = slerp3(da, db, t);
+
+			vec conn = pointLineConnection(lineBase, lineDir, x);
+			dist = norm(conn);
+
+			if (dot(lowConn, conn) < 0)
+			{
+				highT = t;
+				highConn = conn;
+				highDist = dist;
+			}
+			else
+			{
+				lowT = t;
+				lowConn = conn;
+				lowDist = dist;
+			}
+		}
+		double d = norm(x - lineBase);
+
+		return{ t, d };
+	}
+}
diff --git a/oneapi/src/SupraLib/Beamformer/ScanConverter.h b/oneapi/src/SupraLib/Beamformer/ScanConverter.h
new file mode 100644
index 0000000..2b891d1
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/ScanConverter.h
@@ -0,0 +1,68 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __SCANCONVERTER_H__
+#define __SCANCONVERTER_H__
+
+#include "USImage.h"
+#include "Container.h"
+
+#include <memory>
+
+namespace supra
+{
+	class ScanConverter
+	{
+	public:
+		typedef uint32_t IndexType;
+		typedef float WeightType;
+
+		static constexpr int m_mappingMaxIterations = 1000;
+		static constexpr double m_mappingDistanceThreshold = 1e-5;
+
+		template<typename InputType, typename OutputType>
+		std::shared_ptr<Container<OutputType> >
+			convert(const std::shared_ptr<USImage> & inImage);
+		std::shared_ptr<Container<uint8_t> > getMask();
+		void updateInternals(const std::shared_ptr<const USImageProperties> & inImageProps);
+		vec3s getImageSize() const { return m_imageSize; }
+
+	private:
+		static constexpr double m_skewnessTestThreshold = 1e-6;
+
+		double barycentricCoordinate2D(const vec2& a, const vec2& b, const vec2& c);
+		//double barycentricCoordinate3D(const vec& a, const vec& b, const vec& c, const vec& p);
+		bool pointInsideTriangle(const vec2& a, const vec2& b, const vec2& c, const vec2& p);
+		//bool pointInsideTetrahedron(const vec& a, const vec& b, const vec& c, const vec& d, const vec& p);
+
+		vec pointLineConnection(const vec& a, const vec& da, const vec& x);
+		//vec pointPlaneConnection(const vec& a, const vec& na, const vec& x);
+		vec2 mapToParameters2D(const vec& a, const vec& b, const vec& da, const vec& db, double startDepth, double endDepth, const vec& x);
+		/*std::pair<vec, bool>  mapToParameters3D(
+			const vec& a, const vec& ax, const vec& ay, const vec& axy,
+			const vec& da, const vec& dax, const vec& day, const vec& daxy,
+			double startDepth, double endDepth, const vec& x);*/
+
+		bool m_is2D;
+
+		std::shared_ptr<Container<uint8_t> > m_mask;
+		std::shared_ptr<Container<IndexType> > m_sampleIdx;
+		std::shared_ptr<Container<WeightType> > m_weightX;
+		std::shared_ptr<Container<WeightType> > m_weightY;
+		std::shared_ptr<Container<WeightType> > m_weightZ;
+
+		vec m_bbMin = { 0,0,0 };
+		vec m_bbMax = { 0,0,0 };
+		vec3s m_imageSize = { 0,0,0 };
+	};
+}
+
+#endif //!__SCANCONVERTER_H__
diff --git a/oneapi/src/SupraLib/Beamformer/USRawData.h b/oneapi/src/SupraLib/Beamformer/USRawData.h
new file mode 100644
index 0000000..9d5a517
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/USRawData.h
@@ -0,0 +1,84 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __USRAWDATA_H__
+#define __USRAWDATA_H__
+
+#include <memory>
+#include <stddef.h>
+
+#include "Container.h"
+#include "RecordObject.h"
+#include "USImageProperties.h"
+#include "RxBeamformerParameters.h"
+
+namespace supra
+{
+	class USRawData : public RecordObject
+	{
+	public:
+		USRawData(size_t numScanlines,
+			size_t numElements,
+			vec2s elementLayout,
+			size_t numReceivedChannels,
+			size_t numSamples,
+			double samplingFrequency,
+			std::shared_ptr<const ContainerBase > pData,
+			std::shared_ptr<const RxBeamformerParameters> pRxBeamformerParameters,
+			std::shared_ptr<const USImageProperties> pImageProperties,
+			double receiveTimestamp,
+			double syncTimestamp)
+			: RecordObject(receiveTimestamp, syncTimestamp)
+			, m_numScanlines(numScanlines)
+			, m_numElements(numElements)
+			, m_elementLayout(elementLayout)
+			, m_numReceivedChannels(numReceivedChannels)
+			, m_numSamples(numSamples)
+			, m_samplingFrequency(samplingFrequency)
+			, m_pData(pData)
+			, m_pRxBeamformerParameters(pRxBeamformerParameters)
+			, m_pImageProperties(pImageProperties)
+		{};
+
+		std::shared_ptr<const USImageProperties> getImageProperties() const { return m_pImageProperties; };
+		/// Sets the \see USImageProperties that contain the associated metadata
+		void setImageProperties(std::shared_ptr<USImageProperties> & imageProperties) { m_pImageProperties = imageProperties; };
+		template <typename ElementType>
+		std::shared_ptr<const Container<ElementType> > getData() const 
+		{
+			return std::dynamic_pointer_cast<const Container<ElementType> >(m_pData); 
+		}
+		size_t getNumScanlines() const { return m_numScanlines; };
+		size_t getNumElements() const { return m_numElements; };
+		vec2s getElementLayout() const { return m_elementLayout; };
+		size_t getNumReceivedChannels() const { return m_numReceivedChannels; };
+		size_t getNumSamples() const { return m_numSamples; };
+		double getSamplingFrequency() const { return m_samplingFrequency; };
+		std::shared_ptr<const RxBeamformerParameters> getRxBeamformerParameters() const { return m_pRxBeamformerParameters; };
+
+		virtual RecordObjectType getType() const { return TypeUSRawData; }
+		DataType getDataType() const { return m_pData->getType(); }
+
+	private:
+		size_t m_numScanlines;
+		size_t m_numElements;
+		vec2s m_elementLayout;
+		size_t m_numReceivedChannels;
+		size_t m_numSamples;
+		double m_samplingFrequency; // [MHz]
+		std::shared_ptr<const ContainerBase> m_pData;
+		std::shared_ptr<const RxBeamformerParameters> m_pRxBeamformerParameters;
+
+		std::shared_ptr<const USImageProperties> m_pImageProperties;
+	};
+}
+
+#endif //!__USRAWDATA_H__
diff --git a/oneapi/src/SupraLib/Beamformer/USTransducer.h b/oneapi/src/SupraLib/Beamformer/USTransducer.h
new file mode 100644
index 0000000..61a6100
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/USTransducer.h
@@ -0,0 +1,125 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __USTRANSDUCER_H__
+#define __USTRANSDUCER_H__
+
+#include <memory>
+#include <vector>
+#include <map>
+#include "vec.h"
+
+#include <utilities/utility.h>
+
+namespace supra
+{
+	class USTransducer
+	{
+	public:
+		enum Type {
+			Linear,
+			Curved,
+			Planar,
+			Bicurved
+		};
+
+		USTransducer(
+			size_t numElements,
+			vec2s elementLayout,
+			USTransducer::Type type,
+			const std::vector<double>& pitchX,
+			const std::vector<double>& pitchY,
+			const std::vector<std::pair<double, double> >& matchingLayers = {});
+
+		/// create the transducer object from an xml description
+		//USTransducer(std::string xmlFilename);
+
+	public:
+		/////////////////////////////////////////////////////////////////////
+		// simple setters for defining properties
+		/////////////////////////////////////////////////////////////////////
+		void setType(USTransducer::Type type);		// Defines the type of transducer
+		void setNumElements(size_t numElements);		// number of transducer elements
+		void setPitch(					// pitch of the transducer elemens. Distance of the transducer element centers for linear and curved arrays
+			const std::vector<double>& pitchX,
+			const std::vector<double>& pitchY);
+
+		template <typename valueType>
+		void setSpecificParameter(std::string parameterName, valueType value);	// set one interface-specific parameter
+
+		/////////////////////////////////////////////////////////////////////
+		// simple getters
+		/////////////////////////////////////////////////////////////////////
+		USTransducer::Type getType() const;		// Defines the type of transducer
+		size_t getNumElements() const;			// number of transducer elements
+		vec2s getElementLayout() const;			// the logical arrangement of the elements. E.g. for 2D: 32x32
+		std::shared_ptr < const std::vector<vec> > getElementCenterPoints() const; // vector of points that mark the center of each transducer element
+		std::shared_ptr < const std::vector<vec> > getElementNormals() const;      // vector of unit-vectors that describe the element normals
+
+		bool  hasSpecificParameter(std::string parameterName) const;					// whether one interface-specific parameter exists
+		const std::string&  getSpecificParameter(std::string parameterName) const;	// get one interface-specific parameter
+		const std::map<std::string, std::string>&  getSpecificParameters() const;	// map to the interface-specific parameters
+
+		/////////////////////////////////////////////////////////////////////
+		// Dependent properties, i.e. they only have a getter that computes the return value
+		/////////////////////////////////////////////////////////////////////
+		bool is2D() const;
+
+		double computeTransitTime(vec2s elementIndex, vec elementToTarget, double speedOfSoundMMperS, bool correctForMatchingLayer = true) const;
+
+		std::shared_ptr < const std::vector<vec4> >  getElementCenterPointsHom() const;	// array of points in HOMOGENEOUS COORDINATES that mark the center of each transducer element. EXPENSIVE
+		std::shared_ptr < const std::vector<vec4> >  getElementNormalsHom() const;	    // array of vectors in HOMOGENEOUS COORDINATES that describe the element normals. EXPENSIVE
+
+	private:
+		/////////////////////////////////////////////////////////////////////
+		// Defining properties
+		/////////////////////////////////////////////////////////////////////
+		USTransducer::Type m_type;	// Defines the type of transducer
+		size_t m_numElements;		// number of transducer elements
+		vec2s m_elementLayout;      // the logical arrangement of the elements. E.g. for 2D: 32x32
+		std::vector<double> m_pitchX; // pitch of the transducer elemens. Distance of the transducer element centers for linear and curved arrays
+		std::vector<double> m_pitchY; // pitch of the transducer elemens. Distance of the transducer element centers for linear and curved arrays
+		std::vector<std::pair<double, double> > m_matchingLayers; // List of the matching layers, as pairs of thickness [mm] and speed of sound [m/s]
+
+		/////////////////////////////////////////////////////////////////////
+		// Properties for efficient ray-Based operations
+		/////////////////////////////////////////////////////////////////////
+		std::shared_ptr < std::vector<vec> > m_elementCenterPoints; // vector of points that mark the center of each transducer element
+		std::shared_ptr < std::vector<vec> > m_elementNormals;		// vector of unit-vectors that describe the element normals
+
+		// Map for interface specific parameters, they do not define the image itself but its meaning
+		std::map<std::string, std::string> m_specificParameters;
+
+		void computeInternals(void);
+
+		std::pair<double, std::vector<vec2> >
+			findRay(vec2 pos, double speedOfSoundMMperS) const;
+		std::pair<vec2, std::vector<vec2> >
+			computeRay(double alpha, double speedOfSoundMMperS, double posAxial) const;
+		double computeRayTime(const vec2& endPoint, const std::vector<vec2> & rayPositions, double speedofSoundMMperS) const;
+		std::pair<vec2, double>
+			matchingLayer(vec2 p, double angle1, double c1, double c2, double thickness) const;
+	};
+
+	template<typename valueType>
+	inline void USTransducer::setSpecificParameter(std::string parameterName, valueType value)
+	{
+		m_specificParameters[parameterName] = stringify(value);
+	}
+
+	template<>
+	inline void USTransducer::setSpecificParameter<std::string>(std::string parameterName, std::string value)
+	{
+		m_specificParameters[parameterName] = value;
+	}
+}
+
+#endif //!__USTRANSDUCER_H__
diff --git a/oneapi/src/SupraLib/Beamformer/WindowFunction.h b/oneapi/src/SupraLib/Beamformer/WindowFunction.h
new file mode 100644
index 0000000..2158d3a
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/WindowFunction.h
@@ -0,0 +1,150 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __WINDOWFUNCTION_H__
+#define __WINDOWFUNCTION_H__
+
+#ifndef SYCL_LANGUAGE_VERSION
+#include <algorithm>
+#endif
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <memory>
+#include <Container.h>
+#include <utilities/utility.h>
+#include <utilities/cudaUtility.h>
+#include <cmath>
+
+namespace supra
+{
+#ifndef SYCL_LANGUAGE_VERSION
+	using std::max;
+	using std::min;
+#else
+	using sycl::max;
+	using sycl::min;
+#endif
+
+	//forward declaration
+	class WindowFunction;
+
+	enum WindowType : uint32_t
+	{
+		WindowRectangular = 0,
+		WindowHann = 1,
+		WindowHamming = 2,
+		WindowGauss = 3,
+		WindowINVALID = 4
+	};
+
+	class WindowFunctionGpu
+	{
+	public:
+		typedef float ElementType;
+
+		WindowFunctionGpu(const WindowFunctionGpu& a)
+			: m_numEntriesPerFunction(a.m_numEntriesPerFunction)
+			, m_data(a.m_data)
+			, m_scale(a.m_scale) {};
+
+		//Returns the weight of chosen window a the relative index 
+		// relativeIndex has to be normalized to [-1, 1] (inclusive)
+		inline ElementType get(float relativeIndex) const
+		{
+			float	 relativeIndexClamped = sycl::min(sycl::max(relativeIndex, -1.0f), 1.0f);
+			uint32_t absoluteIndex = static_cast<uint32_t>(sycl::round(m_scale * (relativeIndexClamped + 1.0f)));
+			return m_data[absoluteIndex];
+		}
+
+		//Returns the weight of chosen window a the relative index
+		// relativeIndex has to be normalized to [-1, 1] (inclusive)
+		inline ElementType getShared(const ElementType * __restrict__ sharedData, float relativeIndex) const
+		{
+			float	 relativeIndexClamped = sycl::min(sycl::max(relativeIndex, -1.0f), 1.0f);
+			uint32_t absoluteIndex = static_cast<uint32_t>(sycl::round(m_scale * (relativeIndexClamped + 1.0f)));
+			return sharedData[absoluteIndex];
+		}
+
+		inline ElementType getDirect(uint32_t idx) const
+		{
+			ElementType ret = 0;
+			if (idx < m_numEntriesPerFunction)
+			{
+				ret = m_data[idx];
+			}
+			return ret;
+		}
+
+		inline uint32_t numElements() const
+		{
+			return m_numEntriesPerFunction;
+		}
+
+	private:
+		friend WindowFunction;
+		WindowFunctionGpu(size_t numEntriesPerFunction, const ElementType* data)
+			: m_numEntriesPerFunction(static_cast<uint32_t>(numEntriesPerFunction))
+			, m_data(data)
+			, m_scale(static_cast<float>(numEntriesPerFunction - 1)*0.5f) {};
+
+		float m_scale;
+		uint32_t m_numEntriesPerFunction;
+		const ElementType* m_data;
+	};
+
+	class WindowFunction
+	{
+	public:
+		typedef WindowFunctionGpu::ElementType ElementType;
+
+		WindowFunction(WindowType type, ElementType windowParameter = 0.0, size_t numEntriesPerFunction = 128);
+
+		const WindowFunctionGpu* getGpu() const;
+
+		WindowType getType() const { return m_type; };
+		ElementType getParameter() const { return m_windowParameter; };
+
+		//Returns the weight of chosen window a the relative index
+		// relativeIndex has to be normalized to [-1, 1] (inclusive)
+		ElementType get(float relativeIndex) const;
+		ElementType getDirect(uint32_t idx) const;
+
+		// relativeIndex has to be normalized to [-1, 1] (inclusive)
+		template <typename T>
+		static inline T windowFunction(const WindowType& type, const T& relativeIndex, const T& windowParameter)
+		{
+			switch (type)
+			{
+			case WindowRectangular:
+				return 1.0;
+			case WindowHann:
+				return (1 - windowParameter)*(0.5f - 0.5f*std::cos(2*static_cast<T>(M_PI)*((relativeIndex + 1) *0.5f))) + windowParameter;
+			case WindowHamming:
+				return (1 - windowParameter)*(0.54f - 0.46f*std::cos(2*static_cast<T>(M_PI)*((relativeIndex + 1) *0.5f))) + windowParameter;
+			case WindowGauss:
+				return static_cast<T>(1.0 / (windowParameter * sycl::sqrt(2.0 * M_PI)) * std::exp((-1.0 / 2.0) * (relativeIndex / windowParameter) * (relativeIndex / windowParameter)));
+			default:
+				return 0;
+			}
+		}
+	private:
+		size_t m_numEntriesPerFunction;
+		std::vector<ElementType> m_data;
+		std::unique_ptr<Container<ElementType> > m_dataGpu;
+		ElementType m_scale;
+		WindowType m_type;
+		ElementType m_windowParameter;
+		WindowFunctionGpu m_gpuFunction;
+	};
+}
+
+#endif //!__WINDOWFUNCTION_H__
diff --git a/oneapi/src/SupraLib/Beamformer/WindowFunction.h.yaml b/oneapi/src/SupraLib/Beamformer/WindowFunction.h.yaml
new file mode 100644
index 0000000..068ca7b
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/WindowFunction.h.yaml
@@ -0,0 +1,160 @@
+---
+MainSourceFile:  '/home/wangyon1/projects/supra-projects/golden/supra/oneapi/src/SupraLib/Beamformer/WindowFunction.h'
+Replacements:
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          549
+    Length:          10
+    ReplacementText: SYCL_LANGUAGE_VERSION
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          589
+    Length:          0
+    ReplacementText: '#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          695
+    Length:          0
+    ReplacementText: '
+#include <cmath>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          723
+    Length:          10
+    ReplacementText: SYCL_LANGUAGE_VERSION
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          775
+    Length:          12
+    ReplacementText: 'using sycl::max;'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          789
+    Length:          12
+    ReplacementText: 'using sycl::min;'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          1345
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          1442
+    Length:          36
+    ReplacementText: 'sycl::min(sycl::max(relativeIndex, -1.0f), 1.0f)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          1534
+    Length:          45
+    ReplacementText: 'sycl::round(m_scale*(relativeIndexClamped + 1.0f))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          1746
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          1894
+    Length:          36
+    ReplacementText: 'sycl::min(sycl::max(relativeIndex, -1.0f), 1.0f)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          1986
+    Length:          45
+    ReplacementText: 'sycl::round(m_scale*(relativeIndexClamped + 1.0f))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          2078
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          2259
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          2387
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          3387
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          3398
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          3951
+    Length:          16
+    ReplacementText: 'sycl::sqrt(2.0 * M_PI)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Beamformer/WindowFunction.h'
+    Offset:          3971
+    Length:          3
+    ReplacementText: 'std::exp'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+...
diff --git a/oneapi/src/SupraLib/Container.h b/oneapi/src/SupraLib/Container.h
new file mode 100644
index 0000000..eac0fca
--- /dev/null
+++ b/oneapi/src/SupraLib/Container.h
@@ -0,0 +1,329 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __CONTAINER_H__
+#define __CONTAINER_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "ContainerFactory.h"
+#ifdef HAVE_CUDA
+#include "utilities/cudaUtility.h"
+#endif
+#include "utilities/DataType.h"
+
+#include <exception>
+#include <memory>
+#include <vector>
+#include <cassert>
+#include <chrono>
+
+#include <future>
+
+namespace supra
+{
+	class ContainerBase
+	{
+	public:
+		virtual ~ContainerBase() {};
+		virtual DataType getType() const { return TypeUnknown; };
+	};
+
+	template<typename T>
+	class Container : public ContainerBase
+	{
+	public:
+		typedef ContainerFactory::ContainerStreamType ContainerStreamType;
+
+		Container(ContainerLocation location, ContainerStreamType associatedStream, size_t numel)
+		{
+#ifndef HAVE_CUDA
+			location = LocationHost;
+#endif
+#ifdef HAVE_CUDA
+			m_creationEvent = nullptr;
+#endif
+			m_numel = numel;
+			m_location = location;
+			m_associatedStream = associatedStream;
+
+			m_buffer = reinterpret_cast<T*>(ContainerFactoryContainerInterface::acquireMemory(
+				m_numel * sizeof(T), m_location));
+		};
+		Container(ContainerLocation location, ContainerStreamType associatedStream, const std::vector<T> & data, bool waitFinished = true)
+			:Container(location, associatedStream, data.size())
+		{
+#ifdef HAVE_CUDA
+			if(location == LocationGpu)
+			{
+				/*
+				DPCT1003:10: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((associatedStream->memcpy(this->get(), data.data(), this->size() * sizeof(T)), 0));
+				createAndRecordEvent();
+			}
+			else if(location == LocationBoth)
+			{
+				/*
+				DPCT1003:11: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((associatedStream->memcpy(this->get(), data.data(), this->size() * sizeof(T)), 0));
+				createAndRecordEvent();
+			}
+			else
+			{
+				std::copy(data.begin(), data.end(), this->get());
+			}
+			if (waitFinished)
+			{
+				waitCreationFinished();
+			}
+#else
+			std::copy(data.begin(), data.end(), this->get());
+#endif
+		};
+		Container(ContainerLocation location, ContainerStreamType associatedStream, const T* dataBegin, const T* dataEnd, bool waitFinished = true)
+			:Container(location, associatedStream, dataEnd - dataBegin)
+		{
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:12: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((associatedStream->memcpy(this->get(), dataBegin, this->size() * sizeof(T)), 0));
+			createAndRecordEvent();
+			if (waitFinished)
+			{
+				waitCreationFinished();
+			}
+#else
+			std::copy(dataBegin, dataEnd, this->get());
+#endif
+		};
+		Container(ContainerLocation location, const Container<T>& source, bool waitFinished = true)
+			: Container(location, source.getStream(), source.size())
+		{
+			if (source.m_location == LocationHost && location == LocationHost)
+			{
+				std::copy(source.get(), source.get() + source.size(), this->get());
+			}
+#ifdef HAVE_CUDA
+			else if (source.m_location == LocationHost && location == LocationGpu)
+			{
+				/*
+				DPCT1003:13: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T)), 0));
+				createAndRecordEvent();
+			}
+			else if (source.m_location == LocationGpu && location == LocationHost)
+			{
+				/*
+				DPCT1003:14: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T)), 0));
+				createAndRecordEvent();
+			}
+			else if (source.m_location == LocationGpu && location == LocationGpu)
+			{
+				/*
+				DPCT1003:15: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T)), 0));
+				createAndRecordEvent();
+			}
+			else
+			{
+				/*
+				DPCT1003:16: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T)), 0));
+				createAndRecordEvent();
+			}
+			if (waitFinished)
+			{
+				waitCreationFinished();
+			}
+#else
+			std::copy(source.get(), source.get() + source.size(), this->get());
+#endif
+		};
+		~Container()
+		 try {
+#ifdef HAVE_CUDA
+			/*
+			DPCT1027:3: The call to cudaStreamQuery was replaced with 0, because DPC++ currently does not support query operations on queues.
+			*/
+			auto ret = 0;
+			if (ret != 0 && ret != 600 && ret != 4)
+			{
+				cudaSafeCall(ret);
+			}
+			// If the driver is currently unloading, we cannot free the memory in any way. Exit will clean up.
+			else if (ret != 4)
+			{
+				if (ret == 0)
+				{
+					ContainerFactoryContainerInterface::returnMemory(reinterpret_cast<uint8_t*>(m_buffer), m_numel * sizeof(T), m_location);
+				}
+				else
+				{
+					auto buffer = m_buffer;
+					auto numel = m_numel;
+					auto location = m_location;
+					addCallbackStream([ buffer, numel, location ](sycl::queue* s, int e) -> void {
+						ContainerFactoryContainerInterface::returnMemory(reinterpret_cast<uint8_t*>(buffer), numel * sizeof(T), location);
+					});
+				}
+			}
+#else
+			ContainerFactoryContainerInterface::returnMemory(reinterpret_cast<uint8_t*>(m_buffer), m_numel * sizeof(T), m_location);
+#endif
+		}
+		catch (sycl::exception const& exc) {
+		  std::cerr << exc.what() << "Exception caught at file:" << __FILE__ << ", line:" << __LINE__ << std::endl;
+		  std::exit(1);
+		};
+
+		const T* get() const { return m_buffer; };
+		T* get() { return m_buffer; };
+
+		T* getCopyHostRaw() const
+		{
+#ifdef HAVE_CUDA
+			auto ret = new T[this->size()];
+			
+			if(m_location == LocationHost)
+			{
+				std::copy(this->get(), this->get() + this->size(), ret);
+			}
+			else if(m_location == LocationGpu)
+			{
+				/*
+				DPCT1003:17: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((getStream()->memcpy(ret, this->get(), this->size() * sizeof(T)), 0));
+				cudaSafeCall(cudaStreamSynchronize(getStream()));				
+			}
+			else 
+			{
+				/*
+				DPCT1003:18: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((dpct::get_default_queue().memcpy(ret, this->get(), this->size() * sizeof(T)).wait(), 0));
+			}
+			return ret;
+#else
+			return nullptr;
+#endif
+		}
+
+		void copyTo(T* dst, size_t maxSize) const
+		{
+#ifdef HAVE_CUDA
+			assert(maxSize >= this->size());
+			/*
+			DPCT1003:19: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((dpct::get_default_queue().memcpy(dst, this->get(), this->size() * sizeof(T)).wait(), 0));
+#endif
+		}
+
+		void waitCreationFinished()
+		{
+#ifdef HAVE_CUDA
+			if (m_creationEvent)
+			{
+				/*
+				DPCT1003:4: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((m_creationEvent.wait_and_throw(), 0));
+				/*
+				DPCT1027:5: The call to cudaEventDestroy was replaced with 0, because this call is redundant in DPC++.
+				*/
+				cudaSafeCall(0);
+				m_creationEvent = nullptr;
+			}
+#endif
+		}
+
+		// returns the number of elements that can be stored in this container
+		size_t size() const { return m_numel; };
+
+		bool isHost() const { return m_location == ContainerLocation::LocationHost; };
+		bool isGPU() const { return m_location == ContainerLocation::LocationGpu; };
+		bool isBoth() const { return m_location == ContainerLocation::LocationBoth; };
+		ContainerLocation getLocation() const { return m_location; };
+		ContainerStreamType getStream() const
+		{
+			return m_associatedStream;
+		}
+		DataType getType() const { return DataTypeGet<T>(); }
+
+	private:
+		void createAndRecordEvent()
+		{
+#ifdef HAVE_CUDA
+			if (!m_creationEvent)
+			{
+				//cudaSafeCall(cudaEventCreateWithFlags(&m_creationEvent, cudaEventBlockingSync | cudaEventDisableTiming));
+				/*
+				DPCT1027:6: The call to cudaEventCreateWithFlags was replaced with 0, because this call is redundant in DPC++.
+				*/
+				cudaSafeCall(0);
+			}
+			/*
+			DPCT1012:7: Detected kernel execution time measurement pattern and generated an initial code for time measurements in SYCL. You can change the way time is measured depending on your goals.
+			*/
+			/*
+			DPCT1024:8: The original code returned the error code that was further consumed by the program logic. This original code was replaced with 0. You may need to rewrite the program logic
+			consuming the error code.
+			*/
+			m_creationEvent_ct1 = std::chrono::steady_clock::now();
+			cudaSafeCall(0);
+#endif
+		}
+
+#ifdef HAVE_CUDA
+		void addCallbackStream(std::function<void(sycl::queue*, int)> func)
+		{
+			auto funcPointer = new std::function<void(sycl::queue*, int)>(func);
+			/*
+			DPCT1003:9: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((std::async([ & ]() {
+											 m_associatedStream->wait(); &(Container<T>::cudaDeleteCallback)(m_associatedStream, 0, funcPointer);
+						  }),
+						  0));
+		}
+#endif
+
+#ifdef HAVE_CUDA
+		static void cudaDeleteCallback(sycl::queue* stream, int status, void* userData)
+		{
+			std::unique_ptr<std::function<void(sycl::queue*, int)>> func = std::unique_ptr<std::function<void(sycl::queue*, int)>>(reinterpret_cast<std::function<void(sycl::queue*, int)>*>(userData));
+			(*func)(stream, status);
+		}
+#endif
+		// The number of elements this container can store
+		size_t m_numel;
+		ContainerLocation m_location;
+
+		ContainerStreamType m_associatedStream;
+		T* m_buffer;
+
+#ifdef HAVE_CUDA
+		sycl::event										   m_creationEvent;
+		std::chrono::time_point<std::chrono::steady_clock> m_creationEvent_ct1;
+#endif
+	};
+}
+
+#endif //!__CONTAINER_H__
diff --git a/oneapi/src/SupraLib/Container.h.yaml b/oneapi/src/SupraLib/Container.h.yaml
new file mode 100644
index 0000000..97ac27f
--- /dev/null
+++ b/oneapi/src/SupraLib/Container.h.yaml
@@ -0,0 +1,779 @@
+---
+MainSourceFile:  '/home/wangyon1/projects/supra-projects/golden/supra/oneapi/src/SupraLib/Container.h'
+Replacements:
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          531
+    Length:          0
+    ReplacementText: '#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          728
+    Length:          0
+    ReplacementText: '
+#include <chrono>
+
+#include <future>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          1688
+    Length:          0
+    ReplacementText: '				/*
+				DPCT1003:10: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          1705
+    Length:          15
+    ReplacementText: '(associatedStream->memcpy'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          1771
+    Length:          19
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          1790
+    Length:          18
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          1809
+    Length:          0
+    ReplacementText: ', 0)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          1887
+    Length:          0
+    ReplacementText: '				/*
+				DPCT1003:11: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          1904
+    Length:          15
+    ReplacementText: '(associatedStream->memcpy'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          1970
+    Length:          19
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          1989
+    Length:          18
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          2008
+    Length:          0
+    ReplacementText: ', 0)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          2472
+    Length:          0
+    ReplacementText: '			/*
+			DPCT1003:12: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          2488
+    Length:          15
+    ReplacementText: '(associatedStream->memcpy'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          2552
+    Length:          19
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          2571
+    Length:          18
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          2590
+    Length:          0
+    ReplacementText: ', 0)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3150
+    Length:          0
+    ReplacementText: '				/*
+				DPCT1003:13: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3167
+    Length:          15
+    ReplacementText: '(source.getStream()->memcpy'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3235
+    Length:          19
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3254
+    Length:          20
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3275
+    Length:          0
+    ReplacementText: ', 0)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3390
+    Length:          0
+    ReplacementText: '				/*
+				DPCT1003:14: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3407
+    Length:          15
+    ReplacementText: '(source.getStream()->memcpy'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3475
+    Length:          19
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3494
+    Length:          20
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3515
+    Length:          0
+    ReplacementText: ', 0)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3629
+    Length:          0
+    ReplacementText: '				/*
+				DPCT1003:15: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3646
+    Length:          15
+    ReplacementText: '(source.getStream()->memcpy'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3714
+    Length:          19
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3733
+    Length:          20
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3754
+    Length:          0
+    ReplacementText: ', 0)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3803
+    Length:          0
+    ReplacementText: '				/*
+				DPCT1003:16: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3820
+    Length:          15
+    ReplacementText: '(source.getStream()->memcpy'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3888
+    Length:          19
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3907
+    Length:          20
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          3928
+    Length:          0
+    ReplacementText: ', 0)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          4129
+    Length:          0
+    ReplacementText: ' try '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          4148
+    Length:          0
+    ReplacementText: '			/*
+			DPCT1027:3: The call to cudaStreamQuery was replaced with 0, because DPC++ currently does not support query operations on queues.
+			*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          4162
+    Length:          35
+    ReplacementText: '0'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          4213
+    Length:          11
+    ReplacementText: '0'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          4235
+    Length:          17
+    ReplacementText: '600'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          4263
+    Length:          24
+    ReplacementText: '4'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          4442
+    Length:          24
+    ReplacementText: '4'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          4488
+    Length:          11
+    ReplacementText: '0'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          4792
+    Length:          12
+    ReplacementText: 'sycl::queue'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          4805
+    Length:          0
+    ReplacementText: '*'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          4808
+    Length:          11
+    ReplacementText: int
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          5114
+    Length:          0
+    ReplacementText: '
+		catch (sycl::exception const &exc) {
+		  std::cerr << exc.what() << "Exception caught at file:" << __FILE__ << ", line:" << __LINE__ << std::endl;
+		  std::exit(1);
+		}'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          5432
+    Length:          0
+    ReplacementText: '				/*
+				DPCT1003:17: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          5449
+    Length:          15
+    ReplacementText: '(getStream()->memcpy'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          5507
+    Length:          24
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          5531
+    Length:          13
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          5545
+    Length:          0
+    ReplacementText: ', 0)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          5625
+    Length:          0
+    ReplacementText: '				/*
+				DPCT1003:18: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          5642
+    Length:          10
+    ReplacementText: '(dpct::get_default_queue().memcpy'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          5695
+    Length:          19
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          5715
+    Length:          0
+    ReplacementText: '.wait(), 0)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          5876
+    Length:          0
+    ReplacementText: '			/*
+			DPCT1003:19: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          5892
+    Length:          10
+    ReplacementText: '(dpct::get_default_queue().memcpy'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          5945
+    Length:          19
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          5965
+    Length:          0
+    ReplacementText: '.wait(), 0)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          6060
+    Length:          0
+    ReplacementText: '				/*
+				DPCT1003:4: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          6077
+    Length:          37
+    ReplacementText: '(m_creationEvent.wait_and_throw(), 0)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          6117
+    Length:          0
+    ReplacementText: '				/*
+				DPCT1027:5: The call to cudaEventDestroy was replaced with 0, because this call is redundant in DPC++.
+				*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          6134
+    Length:          33
+    ReplacementText: '0'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          6978
+    Length:          0
+    ReplacementText: '				/*
+				DPCT1027:6: The call to cudaEventCreateWithFlags was replaced with 0, because this call is redundant in DPC++.
+				*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          6995
+    Length:          66
+    ReplacementText: '0'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7069
+    Length:          0
+    ReplacementText: '			/*
+			DPCT1012:7: Detected kernel execution time measurement pattern and generated an initial code for time measurements in SYCL. You can change the way time is measured depending on your goals.
+			*/
+			/*
+			DPCT1024:8: The original code returned the error code that was further consumed by the program logic. This original code was replaced with 0. You may need to rewrite the program logic consuming the error code.
+			*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7072
+    Length:          0
+    ReplacementText: 'm_creationEvent_ct1 = std::chrono::steady_clock::now(); 
+			'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7085
+    Length:          52
+    ReplacementText: '0'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7213
+    Length:          12
+    ReplacementText: 'sycl::queue *'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7227
+    Length:          11
+    ReplacementText: int
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7296
+    Length:          12
+    ReplacementText: 'sycl::queue *'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7310
+    Length:          11
+    ReplacementText: int
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7331
+    Length:          0
+    ReplacementText: '			/*
+			DPCT1003:9: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7347
+    Length:          94
+    ReplacementText: '(std::async([&]() { m_associatedStream->wait(); &(Container<T>::cudaDeleteCallback)(m_associatedStream, 0, funcPointer); }), 0)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7487
+    Length:          10
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7516
+    Length:          12
+    ReplacementText: 'sycl::queue'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7529
+    Length:          0
+    ReplacementText: '*'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7537
+    Length:          11
+    ReplacementText: int
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7615
+    Length:          12
+    ReplacementText: 'sycl::queue *'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7629
+    Length:          11
+    ReplacementText: int
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7691
+    Length:          12
+    ReplacementText: 'sycl::queue *'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7705
+    Length:          11
+    ReplacementText: int
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7763
+    Length:          12
+    ReplacementText: 'sycl::queue *'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          7777
+    Length:          11
+    ReplacementText: int
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          8025
+    Length:          11
+    ReplacementText: 'sycl::event'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/Container.h'
+    Offset:          8053
+    Length:          0
+    ReplacementText: '
+		std::chrono::time_point<std::chrono::steady_clock> m_creationEvent_ct1;'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+...
diff --git a/oneapi/src/SupraLib/ContainerFactory.cpp.dp.cpp b/oneapi/src/SupraLib/ContainerFactory.cpp.dp.cpp
new file mode 100644
index 0000000..464a762
--- /dev/null
+++ b/oneapi/src/SupraLib/ContainerFactory.cpp.dp.cpp
@@ -0,0 +1,290 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2017, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "ContainerFactory.h"
+
+#include <utilities/Logging.h>
+#include <utilities/utility.h>
+
+#include <sstream>
+#include <cassert>
+using namespace std;
+
+namespace supra
+{
+	ContainerFactory::ContainerStreamType ContainerFactory::getNextStream()
+	{
+		std::lock_guard<std::mutex> streamLock(sm_streamMutex);
+
+		if (sm_streams.size() == 0)
+		{
+			initStreams();
+		}
+
+		size_t streamIndex = sm_streamIndex;
+		sm_streamIndex = (sm_streamIndex + 1) % sm_numberStreams;
+		return sm_streams[streamIndex];
+	}
+	uint8_t* ContainerFactory::acquireMemory(size_t numBytes, ContainerLocation location)
+	{
+		assert(location < LocationINVALID);
+		
+		// Check whether the queue for this location and size has a buffer left
+		uint8_t* buffer = nullptr;
+		{
+			// by directly accessing the desired length in the map sm_bufferMaps[location],
+			// the map entry is created if it does not already exist. That means the map is
+			// modified here
+			tbb::concurrent_queue<std::pair<uint8_t*, double> >* queuePointer =
+				&(sm_bufferMaps[location][numBytes]);
+
+			std::pair<uint8_t*, double> queueEntry;
+			if (queuePointer->try_pop(queueEntry))
+			{
+				// If yes, just return this already allocated buffer
+				buffer = queueEntry.first;
+			}
+		}
+
+		// If the queue did not contain a buffer, allocate a new one
+		if (!buffer)
+		{
+			// Check whether there is enough free space for the requested buffer. 
+			size_t memoryFree;
+#ifdef HAVE_CUDA
+			size_t memoryTotal;
+			if (location == LocationGpu || location == LocationBoth)
+			{
+				cudaSafeCall(cudaMemGetInfo(&memoryFree, &memoryTotal));
+				memoryFree = static_cast<size_t>(std::max(static_cast<double>(memoryFree) - (static_cast<double>(memoryTotal) * 0.02), 0.0));
+			}
+			else
+#endif
+			{
+				// For the host memory we just rely on the 
+				memoryFree = numBytes;
+			}
+
+			// If not, relase enough unused buffers, starting with the ones that have been returned the longest time ago.
+			if (memoryFree < numBytes)
+			{
+				freeBuffers(numBytes, location);
+			}
+
+			// additionaly, release memory that has been returned over XX (e.g. 30) seconds ago
+			freeOldBuffers();
+
+			// Now that we have made the required memory available, we can allocate the buffer
+			buffer = allocateMemory(numBytes, location);
+		}
+
+		return buffer;
+	}
+
+	void ContainerFactory::returnMemory(uint8_t* pointer, size_t numBytes, ContainerLocation location)
+	{
+		assert(location < LocationINVALID);
+
+		// do not free here, just put it back to the queues with the time it was returned at
+		double returnTime = getCurrentTime();
+
+		// Put buffer back to queue
+		{
+			tbb::concurrent_queue<std::pair<uint8_t*, double> >* queuePointer =
+				&(sm_bufferMaps[location][numBytes]);
+
+			queuePointer->push(std::make_pair(pointer, returnTime));
+		}
+	}
+	void ContainerFactory::initStreams()
+	{
+		logging::log_log("ContainerFactory: Initializing ", sm_numberStreams, " streams.");
+		sm_streamIndex = 0;
+#ifdef HAVE_CUDA
+		sm_streams.resize(sm_numberStreams);
+		for (size_t k = 0; k < sm_numberStreams; k++)
+		{
+			/*
+			DPCT1003:32: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			/*
+			DPCT1025:33: The SYCL queue is created ignoring the flag/priority options.
+			*/
+			cudaSafeCall(((sm_streams[ k ]) = dpct::get_current_device().create_queue(), 0));
+		}
+#else
+		sm_streams.resize(sm_numberStreams, 0);
+#endif
+	}
+
+	uint8_t * ContainerFactory::allocateMemory(size_t numBytes, ContainerLocation location)
+	{
+  dpct::device_ext& dev_ct1 = dpct::get_current_device();
+  sycl::queue&	  q_ct1 = dev_ct1.default_queue();
+		uint8_t* buffer = nullptr;
+		switch (location)
+		{
+		case LocationGpu:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:34: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((buffer = ( uint8_t* )sycl::malloc_device(numBytes, q_ct1), 0));
+#endif
+			break;
+		case LocationBoth:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:35: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((buffer = ( uint8_t* )sycl::malloc_shared(numBytes, q_ct1), 0));
+#endif
+			break;
+		case LocationHost:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:36: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((buffer = ( uint8_t* )sycl::malloc_host(numBytes, q_ct1), 0));
+#else
+			buffer = new uint8_t[numBytes];
+#endif
+			break;
+		default:
+			throw std::runtime_error("invalid argument: Container: Unknown location given");
+		}
+		if (!buffer)
+		{
+			std::stringstream s;
+			s << "bad alloc: Container: Error allocating buffer of size " << numBytes << " in "
+				<< (location == LocationHost ? "LocationHost" : (location == LocationGpu ? "LocationGpu" : "LocationBoth"));
+			throw std::runtime_error(s.str());
+		}
+
+		return buffer;
+	}
+
+	void ContainerFactory::freeBuffers(size_t numBytesMin, ContainerLocation location)
+	{
+		size_t numBytesFreed = 0;
+		size_t numBuffersFreed;
+		do 
+		{
+			numBuffersFreed = 0;
+			// by traversing the map sm_bufferMaps[location] we never create new entries, but only modifiy those already present.
+			for (auto mapIterator = sm_bufferMaps[location].begin(); mapIterator != sm_bufferMaps[location].end(); mapIterator++)
+			{
+				size_t numBytesBuffer = mapIterator->first;
+				std::pair<uint8_t*, double> queueEntry;
+				if(mapIterator->second.try_pop(queueEntry))
+				{
+					// If there is an element in this queue, remove it and free the memory
+					freeMemory(queueEntry.first, numBytesBuffer, location);
+					numBytesFreed += numBytesBuffer;
+					numBuffersFreed++;
+				}
+			}
+		} while (numBytesFreed < numBytesMin && numBuffersFreed > 0);
+	}
+
+	void ContainerFactory::freeOldBuffers()
+	{
+		double currentTime = getCurrentTime();
+		double deleteTime = currentTime - sm_deallocationTimeout;
+		for (ContainerLocation location = LocationHost; location < LocationINVALID; location = static_cast<ContainerLocation>(location + 1))
+		{
+			for (auto mapIterator = sm_bufferMaps[location].begin(); mapIterator != sm_bufferMaps[location].end(); mapIterator++)
+			{
+				size_t numBytesBuffer = mapIterator->first;
+
+				double lastTime = 0.0;
+				while(!mapIterator->second.empty() && lastTime < deleteTime)
+				{
+					// If there is an element in this queue, remove it and free the memory
+					std::pair<uint8_t*, double> bufferPair;
+					if (mapIterator->second.try_pop(bufferPair))
+					{
+						lastTime = bufferPair.second;
+						if (lastTime < deleteTime)
+						{
+							freeMemory(bufferPair.first, numBytesBuffer, location);
+						}
+						else
+						{
+							// oops, we should not have taken that element from the queue. Let's just put it back.
+							// Yes, it will be in the wrong temporal order, but that will be solved in a while on its own
+							mapIterator->second.push(bufferPair);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	void ContainerFactory::garbageCollectionThreadFunction()
+	{
+		sm_garbageCollectionThread.detach();
+		while (true)
+		{
+			ContainerFactory::freeOldBuffers();
+			std::this_thread::sleep_for(std::chrono::duration<double>(sm_deallocationTimeout));
+		}
+	}
+
+	void ContainerFactory::freeMemory(uint8_t * pointer, size_t numBytes, ContainerLocation location)
+	{
+  dpct::device_ext& dev_ct1 = dpct::get_current_device();
+  sycl::queue&	  q_ct1 = dev_ct1.default_queue();
+		switch (location)
+		{
+		case LocationGpu:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:37: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			(sycl::free(pointer, q_ct1), 0);
+#endif
+			break;
+		case LocationBoth:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:38: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			(sycl::free(pointer, q_ct1), 0);
+#endif
+			break;
+		case LocationHost:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:39: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			(sycl::free(pointer, q_ct1), 0);
+#else
+			delete[] pointer;
+#endif
+			break;
+		default:
+			break;
+		}
+	}
+
+	std::vector<ContainerFactory::ContainerStreamType> ContainerFactory::sm_streams = {};
+	size_t ContainerFactory::sm_streamIndex = 0;
+	std::mutex ContainerFactory::sm_streamMutex;
+
+	constexpr double ContainerFactory::sm_deallocationTimeout;
+
+	std::array<tbb::concurrent_unordered_map<size_t, tbb::concurrent_queue<std::pair<uint8_t*, double> > >, LocationINVALID> ContainerFactory::sm_bufferMaps;
+
+	std::thread ContainerFactory::sm_garbageCollectionThread(&ContainerFactory::garbageCollectionThreadFunction);
+}
diff --git a/oneapi/src/SupraLib/ContainerFactory.h b/oneapi/src/SupraLib/ContainerFactory.h
new file mode 100644
index 0000000..e39c914
--- /dev/null
+++ b/oneapi/src/SupraLib/ContainerFactory.h
@@ -0,0 +1,79 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2017, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __CONTAINERFACTORY_H__
+#define __CONTAINERFACTORY_H__
+
+#ifdef HAVE_CUDA
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "utilities/cudaUtility.h"
+#endif
+
+#include <vector>
+#include <mutex>
+#include <thread>
+#include <tbb/concurrent_unordered_map.h>
+#include <tbb/concurrent_queue.h>
+
+namespace supra
+{
+	enum ContainerLocation
+	{
+		LocationHost,
+		LocationGpu,
+		LocationBoth,
+		LocationINVALID
+	};
+
+	class ContainerFactory
+	{
+	public:
+#ifdef HAVE_CUDA
+		typedef sycl::queue* ContainerStreamType;
+#else
+		typedef int ContainerStreamType;
+#endif
+		
+		static ContainerStreamType getNextStream();
+
+	protected:
+		static uint8_t* acquireMemory(size_t numBytes, ContainerLocation location);
+		static void returnMemory(uint8_t* pointer, size_t numBytes, ContainerLocation location);
+
+	private:
+		static void initStreams();
+	
+		static constexpr size_t sm_numberStreams = 8;
+
+		static std::vector<ContainerStreamType> sm_streams;
+		static size_t sm_streamIndex;
+		static std::mutex sm_streamMutex;
+
+		static constexpr double sm_deallocationTimeout = 60; // [seconds]
+
+		static uint8_t* allocateMemory(size_t numBytes, ContainerLocation location);
+		static void freeBuffers(size_t numBytesMin, ContainerLocation location);
+		static void freeOldBuffers();
+		static void garbageCollectionThreadFunction();
+		static void freeMemory(uint8_t* pointer, size_t numBytes, ContainerLocation location);
+
+		static std::array<tbb::concurrent_unordered_map<size_t, tbb::concurrent_queue<std::pair<uint8_t*, double> > >, LocationINVALID> sm_bufferMaps;
+		static std::thread sm_garbageCollectionThread;
+	};
+
+	class ContainerFactoryContainerInterface : public ContainerFactory
+	{
+		template <typename T> friend class Container;
+	};
+}
+
+#endif //!__CONTAINERFACTORY_H__
diff --git a/oneapi/src/SupraLib/ContainerFactory.h.yaml b/oneapi/src/SupraLib/ContainerFactory.h.yaml
new file mode 100644
index 0000000..3657cb6
--- /dev/null
+++ b/oneapi/src/SupraLib/ContainerFactory.h.yaml
@@ -0,0 +1,22 @@
+---
+MainSourceFile:  '/home/wangyon1/projects/supra-projects/golden/supra/oneapi/src/SupraLib/ContainerFactory.h'
+Replacements:
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/ContainerFactory.h'
+    Offset:          562
+    Length:          0
+    ReplacementText: '#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/ContainerFactory.h'
+    Offset:          913
+    Length:          12
+    ReplacementText: 'sycl::queue *'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+...
diff --git a/oneapi/src/SupraLib/RecordObject.h b/oneapi/src/SupraLib/RecordObject.h
new file mode 100644
index 0000000..3f1519e
--- /dev/null
+++ b/oneapi/src/SupraLib/RecordObject.h
@@ -0,0 +1,62 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2011-2016, all rights reserved,
+//      Christoph Hennersperger 
+//		EmaiL christoph.hennersperger@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+//	and
+//		Rüdiger Göbl
+//		Email r.goebl@tum.de
+//
+// ================================================================================================
+
+#ifndef __RECORDOBJECT_H__
+#define __RECORDOBJECT_H__
+
+namespace supra
+{
+	/// Enum for the different types of data distributed within the dataflow graph
+	enum RecordObjectType {
+		TypeSyncRecordObject,
+		TypeTrackerDataSet,
+		TypeUSImage,
+		TypeUSRawData,
+		TypeRecordUnknown
+	};
+
+	//const char* RecordObjectTypeToString(RecordObjectType t);
+
+	/// Base class for all RecordObjects
+	class RecordObject
+	{
+
+	public:
+		/// Constructor that takes the two timestamps:
+		///		receiveTimestamp is the timestamp (in seconds) at which this dataset initially was recieved
+		///		syncTimestamp is the timestamp (in seconds) after optinal temporal synchronization
+		RecordObject(double receiveTimestamp, double syncTimestamp) : m_receiveTimestamp(receiveTimestamp), m_syncTimestamp(syncTimestamp) {};
+		/// Base constructor
+		RecordObject() : m_receiveTimestamp(0.0), m_syncTimestamp(0.0) {};
+		virtual ~RecordObject() {};
+
+		/// Returns the receive timestamp (in seconds), that is the time at which this dataset initially was recieved
+		inline double getReceiveTimestamp() const { return m_receiveTimestamp; };
+		/// Returns the snyc timestamp (in seconds), that is after optinal temporal synchronization
+		inline double getSyncTimestamp() const { return m_syncTimestamp; };
+		/// Apply a temporal offset to the original timestamp to perform temporal synchronization
+		inline void setSyncOffset(double temporalOffset) { m_syncTimestamp = m_receiveTimestamp + temporalOffset; };
+
+		/// Returns the type of the dataset. Overwritten in subclasses.
+		virtual RecordObjectType getType() const { return TypeRecordUnknown; }
+
+	protected:
+		/// The receive timestamp(in seconds), that is the time at which this dataset initially was recieved
+		double m_syncTimestamp;
+		/// The snyc timestamp (in seconds), that is after optinal temporal synchronization
+		double m_receiveTimestamp;
+	};
+}
+
+#endif // !__RECORDOBJECT_H__
diff --git a/oneapi/src/SupraLib/USImage.h b/oneapi/src/SupraLib/USImage.h
new file mode 100644
index 0000000..80e2c92
--- /dev/null
+++ b/oneapi/src/SupraLib/USImage.h
@@ -0,0 +1,133 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __USIMAGE_H__
+#define __USIMAGE_H__
+
+#include <memory>
+#include <stddef.h>
+
+#include "Container.h"
+#include "RecordObject.h"
+#include "USImageProperties.h"
+#include "vec.h"
+
+namespace supra
+{
+	/// A compute graph object that represents an ultrasound image with elements of type ElementType.
+	/// Can contain 2D and 3D images and both before scansconversion (that is samples aling scanlines) and
+	/// images / volumes after scanconversion are supported
+	class USImage : public RecordObject
+	{
+	public:
+		USImage() : m_dimensions(0), m_size{}, m_pData(nullptr) {};
+		/// Constructs a 3D Image
+		USImage(size_t size1,
+			size_t size2,
+			size_t size3,
+			std::shared_ptr<ContainerBase> pData,
+			std::shared_ptr<const USImageProperties> pImageProperties,
+			double receiveTimestamp,
+			double syncTimestamp)
+			: RecordObject(receiveTimestamp, syncTimestamp)
+			, m_pImageProperties(pImageProperties)
+			, m_dimensions(3)
+			, m_size{ size1, size2, size3 }
+		, m_pData(pData) {};
+		/// Constructs a 2D Image
+		USImage(size_t size1,
+			size_t size2,
+			std::shared_ptr<ContainerBase> pData,
+			std::shared_ptr<const USImageProperties> pImageProperties,
+			double receiveTimestamp, double syncTimestamp)
+			: RecordObject(receiveTimestamp, syncTimestamp)
+			, m_pImageProperties(pImageProperties)
+			, m_dimensions(2)
+			, m_size{ size1, size2, 1 }
+		, m_pData(pData) {};
+		/// Constructs a 3D or 2D Image.
+		/// If size.z == 1, the image is 2D.
+		USImage(vec3s size,
+			std::shared_ptr<ContainerBase> pData,
+			std::shared_ptr<const USImageProperties> pImageProperties,
+			double receiveTimestamp, double syncTimestamp)
+			: RecordObject(receiveTimestamp, syncTimestamp)
+			, m_pImageProperties(pImageProperties)
+			, m_dimensions(3)
+			, m_size(size)
+			, m_pData(pData)
+		{
+			if (size.z == 1)
+			{
+				m_dimensions = 2;
+			}
+		};
+		/// Constructs a 2D Image
+		USImage(vec2s size,
+			std::shared_ptr<ContainerBase> pData,
+			std::shared_ptr<const USImageProperties> pImageProperties,
+			double receiveTimestamp,
+			double syncTimestamp)
+			: RecordObject(receiveTimestamp, syncTimestamp)
+			, m_pImageProperties(pImageProperties)
+			, m_dimensions(2)
+			, m_pData(pData)
+		{
+			m_size.x = size.x;
+			m_size.y = size.y;
+			m_size.z = 1;
+		};
+		/// Copy constructor. Copies image metadata and the pointer to the data.
+		USImage(const USImage& a)
+			: RecordObject(a)
+			, m_dimensions(a.m_dimensions)
+			, m_size(a.m_size)
+			, m_pData(a.m_pData)
+			, m_pImageProperties(a.m_pImageProperties) {};
+		/// Special copy constructor, copies image metadata from the given image,
+		/// but uses the given Container for data
+		USImage(const USImage& a, std::shared_ptr<ContainerBase> pData)
+			: RecordObject(a)
+			, m_dimensions(a.m_dimensions)
+			, m_size(a.m_size)
+			, m_pData(pData)
+			, m_pImageProperties(a.m_pImageProperties) {};
+
+		//~USImage();
+		/// Returns a pointer to the \see USImageProperties that contain the associated metadata
+		std::shared_ptr<const USImageProperties> getImageProperties() const { return m_pImageProperties; };
+		/// Sets the \see USImageProperties that contain the associated metadata
+		void setImageProperties(std::shared_ptr<USImageProperties> & imageProperties) { m_pImageProperties = imageProperties; };
+		/// Returns the size of the image. If it is 2D, `getSize().z == 1`
+		vec3s getSize() const { return m_size; };
+		/// Returns a pointer to the image data
+		template <typename ElementType>
+		std::shared_ptr<const Container<ElementType> > getData() const
+		{
+			return std::dynamic_pointer_cast<const Container<ElementType> >(m_pData);
+		}
+
+		virtual RecordObjectType getType() const { return TypeUSImage; }
+		DataType getDataType() const { return m_pData->getType(); }
+
+	private:
+		std::shared_ptr<const USImageProperties> m_pImageProperties;
+
+		std::shared_ptr<ContainerBase> m_pData;
+
+		//number of image dimensions
+		int m_dimensions;
+		//the size of the image buffer (i.e. m_pData->size() == prod(m_size))
+		vec3s m_size;
+	};
+}
+
+#endif //!__USIMAGE_H__
diff --git a/oneapi/src/SupraLib/USImageProperties.h b/oneapi/src/SupraLib/USImageProperties.h
new file mode 100644
index 0000000..f20a021
--- /dev/null
+++ b/oneapi/src/SupraLib/USImageProperties.h
@@ -0,0 +1,208 @@
+// ================================================================================================
+// 
+// Copyright (C) 2016, Rüdiger Göbl - all rights reserved
+// Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.
+//
+//          Rüdiger Göbl
+//          Email r.goebl@tum.de
+//          Chair for Computer Aided Medical Procedures
+//          Technische Universität München
+//          Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License, version 2.1, as published by the Free Software Foundation.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this program.  If not, see
+// <http://www.gnu.org/licenses/>.
+//
+// ================================================================================================
+
+#ifndef __USIMAGEPROPERTIES_H__
+#define __USIMAGEPROPERTIES_H__
+
+#include <memory>
+#include <vector>
+#include <map>
+#include "vec.h"
+
+#include <iostream>
+#include <iomanip>
+
+#include <utilities/utility.h>
+
+namespace supra
+{
+	// The receive parameters for one scanline
+	struct ScanlineRxParameters3D
+	{
+		ScanlineRxParameters3D()
+			: txParameters{ {{0,0}, {0,0}, 0, 0} }
+			, position{ 0.0, 0.0, 0.0 }
+			, direction{ 0.0, 0.0, 0.0 }
+			, maxElementDistance{ 0.0, 0.0 }
+		{}
+
+		struct TransmitParameters {
+			vec2T<uint16_t> firstActiveElementIndex;	// index of the first active transducer element
+			vec2T<uint16_t> lastActiveElementIndex;		// index of the last active transducer element
+			uint16_t  txScanlineIdx;		// index of the corresponsing transmit scanline
+			double initialDelay;			// the minmal delay in [s] that is to be used during rx
+
+			bool operator== (const TransmitParameters& b) const
+			{
+				return firstActiveElementIndex == b.firstActiveElementIndex &&
+					lastActiveElementIndex == b.lastActiveElementIndex &&
+					txScanlineIdx == b.txScanlineIdx &&
+					initialDelay == b.initialDelay;
+			}
+		};
+
+		vec position;	                // the position of the scanline
+		vec direction;                  // direction of the scanline
+		double txWeights[4];            // Weights for interpolation between different transmits
+		TransmitParameters txParameters[4]; // Parameters of the transmits to use
+		vec2 maxElementDistance;		// maximum distance of an element to the scanline start, used to compute rxWeights
+
+		vec getPoint(double depth) const
+		{
+			return position + depth*direction;
+		}
+
+		bool operator== (const ScanlineRxParameters3D& b) const
+		{
+			return txParameters[0] == b.txParameters[0] &&
+				txParameters[1] == b.txParameters[1] &&
+				txParameters[2] == b.txParameters[2] &&
+				txParameters[3] == b.txParameters[3] &&
+				txWeights[0] == b.txWeights[0] &&
+				txWeights[1] == b.txWeights[1] &&
+				txWeights[2] == b.txWeights[2] &&
+				txWeights[3] == b.txWeights[3] &&
+				position == b.position &&
+				direction == b.direction &&
+				maxElementDistance == b.maxElementDistance;
+		}
+
+		friend std::ostream& operator<< (std::ostream& os, const ScanlineRxParameters3D& params);
+		friend std::istream& operator>> (std::istream& is, ScanlineRxParameters3D& params);
+	};
+
+
+	class USImageProperties
+	{
+	public:
+		enum ImageType {
+			BMode,
+			Doppler,
+			Planewave
+		};
+
+		enum ImageState {
+			Raw,
+			RawDelayed,
+			RF,
+			EnvDetected,
+			PreScan,
+			Scan
+		};
+		enum TransducerType {
+			Linear,
+			Phased,
+			Curved,
+			Planar,
+			PlanarPhased,
+			Bicurved
+		};
+
+		USImageProperties();
+		USImageProperties(vec2s scanlineLayout, size_t numSamples, USImageProperties::ImageType imageType, USImageProperties::ImageState imageState, USImageProperties::TransducerType transducerType, double depth);
+		USImageProperties(const USImageProperties& a);
+		USImageProperties(const std::string & mockJsonMetadataFilename);
+
+	public:
+		/////////////////////////////////////////////////////////////////////
+		// simple setters for defining properties
+		/////////////////////////////////////////////////////////////////////
+		void setImageType(USImageProperties::ImageType imageType);	// Defines the type of information contained in the image
+		void setImageState(USImageProperties::ImageState imageState);	// Describes the state the image is currently in
+		void setTransducerType(USImageProperties::TransducerType transducerType);	// Defines the type of transducer
+		void setScanlineLayout(vec2s scanlineLayout);	// number of scanlines acquired
+		void setNumSamples(size_t numSamples);		// number of samples acquired on each scanline
+		void setDepth(double depth);					// depth covered
+		void setImageResolution(double resolution);  // the resolution of the scanConverted image
+
+
+		void setScanlineInfo(std::shared_ptr<std::vector<std::vector<ScanlineRxParameters3D> > > scanlines);
+
+		template <typename valueType>
+		void setSpecificParameter(std::string parameterName, valueType value);	// set one interface-specific parameter
+
+		void writeMetaDataForMock(std::string filename) const;
+
+		/////////////////////////////////////////////////////////////////////
+		// simple getters
+		/////////////////////////////////////////////////////////////////////
+		USImageProperties::ImageType getImageType() const;				// Defines the type of information contained in the image
+		USImageProperties::ImageState getImageState() const;			// Describes the state the image is currently in
+		USImageProperties::TransducerType getTransducerType() const;	// Defines the type of transducer
+		size_t getNumScanlines() const;			// number of scanlines acquired
+		vec2s getScanlineLayout() const;
+		size_t getNumSamples() const;				// number of samples acquired on each scanline
+		double getDepth() const;					// depth covered
+
+
+		std::shared_ptr<std::vector<std::vector<ScanlineRxParameters3D> > > getScanlineInfo() const;
+
+		bool  hasSpecificParameter(std::string parameterName) const;					// whether one interface-specific parameter exists
+		const std::string&  getSpecificParameter(std::string parameterName) const;	// get one interface-specific parameter
+		const std::map<std::string, std::string>&  getSpecificParameters() const;	// map to the interface-specific parameters
+
+		/////////////////////////////////////////////////////////////////////
+		// Dependent properties, i.e. they only have a getter that computes the return value
+		/////////////////////////////////////////////////////////////////////
+		double getSampleDistance() const;		// distance between samples of the scanlines
+		double getImageResolution() const;		// spatial resolution of image
+		bool is2D() const;
+
+	private:
+		/////////////////////////////////////////////////////////////////////
+		// Defining properties
+		/////////////////////////////////////////////////////////////////////
+		USImageProperties::ImageType m_imageType;			// Defines the type of information contained in the image
+		USImageProperties::ImageState m_imageState;			// Describes the state the image is currently in
+		USImageProperties::TransducerType m_transducerType;	// Defines the type of transducer
+		size_t m_numScanlines;				// number of scanlines acquired
+		vec2s m_scanlineLayout;
+		size_t m_numSamples;					// number of samples acquired on each scanline
+		double m_depth;						// depth covered
+		bool m_imageResolutionSet;			// whether explicit image resolution has been set
+		double m_imageResolution;			// explicit image resolution
+
+
+		// Map for interface specific parameters, they do not define the image itself but its meaning
+		std::map<std::string, std::string> m_specificParameters;
+
+		std::shared_ptr<std::vector<std::vector<ScanlineRxParameters3D> > > m_scanlines;
+	};
+
+	template<typename valueType>
+	inline void USImageProperties::setSpecificParameter(std::string parameterName, valueType value)
+	{
+		m_specificParameters[parameterName] = stringify(value);
+	}
+
+	template<>
+	inline void USImageProperties::setSpecificParameter<std::string>(std::string parameterName, std::string value)
+	{
+		m_specificParameters[parameterName] = value;
+	}
+}
+
+#endif //!__USIMAGEPROPERTIES_H__
diff --git a/oneapi/src/SupraLib/utilities/DataType.h b/oneapi/src/SupraLib/utilities/DataType.h
new file mode 100644
index 0000000..6a97bba
--- /dev/null
+++ b/oneapi/src/SupraLib/utilities/DataType.h
@@ -0,0 +1,90 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2017, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __DATATYPE_H__
+#define __DATATYPE_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <stdint.h>
+#include <string>
+#include "utilities/utility.h"
+
+#ifdef HAVE_CUDA
+#endif
+
+namespace supra
+{
+	/// Enum for the types used in containers and by the parameter system
+	enum DataType
+	{
+		TypeBool,
+		TypeInt8,
+		TypeUint8,
+		TypeInt16,
+		TypeUint16,
+		TypeInt32,
+		TypeUint32,
+		TypeInt64,
+		TypeUint64,
+#ifdef HAVE_CUDA
+		TypeHalf,
+#endif
+		TypeFloat,
+		TypeDouble,
+		TypeString,
+		TypeDataType,
+		TypeUnknown
+	};
+
+	template <typename T>
+	DataType DataTypeGet()
+	{
+		return TypeUnknown;
+	}
+
+	template <>
+	DataType DataTypeGet<bool>();
+	template <>
+	DataType DataTypeGet<int8_t>();
+	template <>
+	DataType DataTypeGet<uint8_t>();
+	template <>
+	DataType DataTypeGet<int16_t>();
+	template <>
+	DataType DataTypeGet<uint16_t>();
+	template <>
+	DataType DataTypeGet<int32_t>();
+	template <>
+	DataType DataTypeGet<uint32_t>();
+	template <>
+	DataType DataTypeGet<int64_t>();
+	template <>
+	DataType DataTypeGet<uint64_t>();
+#ifdef HAVE_CUDA
+	template <> DataType DataTypeGet<sycl::half>();
+#endif
+	template <>
+	DataType DataTypeGet<float>();
+	template <>
+	DataType DataTypeGet<double>();
+	template <>
+	DataType DataTypeGet<std::string>();
+	template <>
+	DataType DataTypeGet<DataType>();
+
+	DataType DataTypeFromString(const std::string& s, bool* sucess = nullptr);
+	std::string DataTypeToString(DataType t, bool* success = nullptr);
+	std::ostream& operator<<(std::ostream& os, DataType dataType);
+	std::istream& operator>>(std::istream& is, DataType& dataType);
+}
+
+#endif // !__DATATYPE_H__
diff --git a/oneapi/src/SupraLib/utilities/DataType.h.yaml b/oneapi/src/SupraLib/utilities/DataType.h.yaml
new file mode 100644
index 0000000..79abe34
--- /dev/null
+++ b/oneapi/src/SupraLib/utilities/DataType.h.yaml
@@ -0,0 +1,30 @@
+---
+MainSourceFile:  '/home/wangyon1/projects/supra-projects/golden/supra/oneapi/src/SupraLib/utilities/DataType.h'
+Replacements:
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/DataType.h'
+    Offset:          529
+    Length:          0
+    ReplacementText: '#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/DataType.h'
+    Offset:          616
+    Length:          23
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/DataType.h'
+    Offset:          1533
+    Length:          6
+    ReplacementText: 'sycl::half'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+...
diff --git a/oneapi/src/SupraLib/utilities/FirFilterFactory.h b/oneapi/src/SupraLib/utilities/FirFilterFactory.h
new file mode 100644
index 0000000..09283ba
--- /dev/null
+++ b/oneapi/src/SupraLib/utilities/FirFilterFactory.h
@@ -0,0 +1,238 @@
+// ================================================================================================
+// 
+// Copyright (C) 2016, Rüdiger Göbl - all rights reserved
+// Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.
+//
+//          Rüdiger Göbl
+//          Email r.goebl@tum.de
+//          Chair for Computer Aided Medical Procedures
+//          Technische Universität München
+//          Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License, version 2.1, as published by the Free Software Foundation.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this program.  If not, see
+// <http://www.gnu.org/licenses/>.
+//
+// ================================================================================================
+
+#ifndef __FIRFILTERFACTORY_H__
+#define __FIRFILTERFACTORY_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <memory>
+#include <functional>
+#include "Container.h"
+#include <cmath>
+
+namespace supra
+{
+	/// A factory for FIR filters
+	class FirFilterFactory {
+	public:
+		/// Enum for the different filter types
+		enum FilterType {
+			FilterTypeLowPass,
+			FilterTypeHighPass,
+			FilterTypeBandPass,
+			FilterTypeHilbertTransformer
+		};
+
+		/// Enum for the different window types used in creating filters
+		enum FilterWindow {
+			FilterWindowRectangular,
+			FilterWindowHann,
+			FilterWindowHamming,
+			FilterWindowKaiser
+		};
+
+		/// Returns a FIR filter constructed with the window-method
+		template <typename ElementType>
+		static std::shared_ptr<Container<ElementType> >
+			createFilter(const size_t &length, const FilterType &type, const FilterWindow &window, const double &samplingFrequency = 2.0, const double &frequency = 0.0, const double &bandwidth = 0.0)
+		{
+			std::shared_ptr<Container<ElementType> > filter = createFilterNoWindow<ElementType>(length, type, samplingFrequency, frequency, bandwidth);
+			applyWindowToFilter<ElementType>(filter, window);
+			if (type == FilterTypeBandPass)
+			{
+				normalizeGain<ElementType>(filter, samplingFrequency, frequency);
+			}
+
+			return filter;
+		}
+
+	private:
+		template <typename ElementType>
+		static std::shared_ptr<Container<ElementType> >
+			createFilterNoWindow(const size_t &length, const FilterType &type, const double &samplingFrequency, const double &frequency, const double &bandwidth)
+		{
+			if (type == FilterTypeHighPass || type == FilterTypeBandPass || type == FilterTypeLowPass)
+			{
+				assert(samplingFrequency != 0.0);
+				assert(frequency != 0.0);
+			}
+			if (type == FilterTypeBandPass)
+			{
+				assert(bandwidth != 0.0);
+			}
+
+			ElementType omega = static_cast<ElementType>(2 * M_PI* frequency / samplingFrequency);
+			ElementType omegaBandwidth = static_cast<ElementType>(2 * M_PI* bandwidth / samplingFrequency);
+			int halfWidth = ((int)length - 1) / 2;
+
+			auto filter = std::make_shared<Container<ElementType>>(LocationHost, &dpct::get_default_queue(), length);
+
+			//determine the filter function
+			std::function<ElementType(int)> filterFunction = [&halfWidth](int n) -> ElementType {
+				if (n == halfWidth)
+				{
+					return static_cast<ElementType>(1);
+				}
+				else {
+					return static_cast<ElementType>(0);
+				}
+			};
+			switch (type)
+			{
+			case FilterTypeHilbertTransformer:
+				// Following formula 2 in
+				// "Carrick, Matt, and Doug Jaeger. "Design and Application of a Hilbert Transformer in a Digital Receiver." (2011)."
+				filterFunction = [halfWidth](int n) -> ElementType {
+					auto k = (n - halfWidth);
+					if (k % 2 == 0)
+					{
+						return static_cast<ElementType>(0);
+					}
+					else
+					{
+						return static_cast<ElementType>(2.0 / (M_PI * k));
+					}
+				};
+				break;
+			case FilterTypeHighPass:
+				filterFunction = [omega, halfWidth](int n) -> ElementType {
+					if (n == halfWidth)
+					{
+						return static_cast<ElementType>(1 - omega / M_PI);
+					}
+					else {
+						return static_cast<ElementType>(-omega / M_PI * sin(omega * (n - halfWidth)) / (omega * (n - halfWidth)));
+					}
+				};
+				break;
+			case FilterTypeBandPass:
+				filterFunction = [omega, omegaBandwidth, halfWidth](int n) -> ElementType {
+					if (n == halfWidth)
+					{
+						return static_cast<ElementType>(2.0 * omegaBandwidth / M_PI);
+					}
+					else {
+						return static_cast<ElementType>(
+							2.0 * cos(omega * n - halfWidth) *
+							omegaBandwidth / M_PI * sin(omegaBandwidth * (n - halfWidth)) / (omegaBandwidth * (n - halfWidth)));
+					}
+				};
+				break;
+			case FilterTypeLowPass:
+			default:
+				filterFunction = [omega, halfWidth](int n) -> ElementType {
+					if (n == halfWidth)
+					{
+						return static_cast<ElementType>(omega / M_PI);
+					}
+					else {
+						return static_cast<ElementType>(omega / M_PI * sin(omega * (n - halfWidth)) / (omega * (n - halfWidth)));
+					}
+				};
+				break;
+			}
+
+			//create the filter
+			for (size_t k = 0; k < length; k++)
+			{
+				filter->get()[k] = filterFunction((int)k);
+			}
+
+			return filter;
+		}
+
+		template <typename ElementType>
+		static void applyWindowToFilter(std::shared_ptr<Container<ElementType> > filter, FilterWindow window)
+		{
+			size_t filterLength = filter->size();
+			size_t maxN = filterLength - 1;
+			ElementType beta = (ElementType)4.0;
+			std::function<ElementType(int)> windowFunction = [filterLength](int n) -> ElementType { return static_cast<ElementType>(1); };
+			switch (window)
+			{
+			case FilterWindowHann:
+				windowFunction = [maxN](int n) -> ElementType { return static_cast<ElementType>(
+					0.50 - 0.50*cos(2 * M_PI * n / maxN)); };
+				break;
+			case FilterWindowHamming:
+				windowFunction = [maxN](int n) -> ElementType { return static_cast<ElementType>(
+					0.54 - 0.46*cos(2 * M_PI * n / maxN)); };
+				break;
+			case FilterWindowKaiser:
+				windowFunction = [maxN, beta](int n) -> ElementType {
+					double argument = beta * sqrt(1.0 - (2 * (( ElementType )n - maxN / 2) / maxN) * (2 * (( ElementType )n - maxN / 2) / maxN));
+					return static_cast<ElementType>(bessel0_1stKind(argument) / bessel0_1stKind(beta)); };
+				break;
+			case FilterWindowRectangular:
+			default:
+				windowFunction = [](int n) -> ElementType { return static_cast<ElementType>(1); };
+				break;
+			}
+
+			for (size_t k = 0; k < filterLength; k++)
+			{
+				filter->get()[k] *= windowFunction((int)k);
+			}
+		}
+
+		template <typename ElementType>
+		static void normalizeGain(std::shared_ptr<Container<ElementType> > filter, double samplingFrequency, double frequency)
+		{
+			ElementType omega = static_cast<ElementType>(2 * M_PI* frequency / samplingFrequency);
+			ElementType gainR = 0;
+			ElementType gainI = 0;
+
+			for (int k = 0; k < filter->size(); k++)
+			{
+				gainR += filter->get()[k] * cos(omega * (ElementType)k);
+				gainI += filter->get()[k] * sin(omega * (ElementType)k);
+			}
+			ElementType gain = sqrt(gainR*gainR + gainI*gainI);
+			for (int k = 0; k < filter->size(); k++)
+			{
+				filter->get()[k] /= gain;
+			}
+		}
+
+		template <typename T>
+		static T bessel0_1stKind(const T &x)
+		{
+			T sum = 0.0;
+			//implemented look up factorial. 
+			static const int factorial[9] = { 1, 2, 6, 24, 120, 720, 5040, 40320, 362880 };
+			for (int k = 1; k < 10; k++)
+			{
+				T xPower = pow(x / ( T )2.0, ( T )k);
+				// 1, 2, 6, 24, 120, 720, 5040, 40320, 362880
+				sum += pow(xPower / ( T )factorial[ k - 1 ], ( T )2.0);
+			}
+			return (T)1.0 + sum;
+		}
+	};
+}
+
+#endif // !__FIRFILTERFACTORY_H__
diff --git a/oneapi/src/SupraLib/utilities/FirFilterFactory.h.yaml b/oneapi/src/SupraLib/utilities/FirFilterFactory.h.yaml
new file mode 100644
index 0000000..11ef482
--- /dev/null
+++ b/oneapi/src/SupraLib/utilities/FirFilterFactory.h.yaml
@@ -0,0 +1,56 @@
+---
+MainSourceFile:  '/home/wangyon1/projects/supra-projects/golden/supra/oneapi/src/SupraLib/utilities/FirFilterFactory.h'
+Replacements:
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/FirFilterFactory.h'
+    Offset:          1237
+    Length:          0
+    ReplacementText: '#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/FirFilterFactory.h'
+    Offset:          1299
+    Length:          0
+    ReplacementText: '
+#include <cmath>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/FirFilterFactory.h'
+    Offset:          3223
+    Length:          19
+    ReplacementText: '&dpct::get_default_queue()'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/FirFilterFactory.h'
+    Offset:          6147
+    Length:          48
+    ReplacementText: '(2 * ((ElementType)n - maxN / 2) / maxN) * (2 * ((ElementType)n - maxN / 2) / maxN)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/FirFilterFactory.h'
+    Offset:          7435
+    Length:          21
+    ReplacementText: 'pow(x / (T)2.0, (T)k)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/FirFilterFactory.h'
+    Offset:          7519
+    Length:          39
+    ReplacementText: 'pow(xPower / (T)factorial[k-1], (T)2.0)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+...
diff --git a/oneapi/src/SupraLib/utilities/Logging.h b/oneapi/src/SupraLib/utilities/Logging.h
new file mode 100644
index 0000000..fac819b
--- /dev/null
+++ b/oneapi/src/SupraLib/utilities/Logging.h
@@ -0,0 +1,330 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __LOGGING_H__
+#define __LOGGING_H__
+
+#include <mutex>
+#include <iostream>
+#include <fstream>
+#include <iomanip>
+#include <type_traits>
+#include <atomic>
+#include <array>
+#include <ctime>
+
+#ifdef WIN32 
+	#ifndef NOMINMAX
+		#define NOMINMAX
+	#endif
+	#include <windows.h>
+#endif
+
+namespace supra
+{
+	/*! \brief The main logging facility.
+	*/
+	namespace logging
+	{
+		/// Tags the severity of a message.
+		typedef int SeverityMask;
+		/// Tags the severity of a message.
+		enum Severity : SeverityMask {
+			log = 1,  ///Messages that might be of interest when understanding operation surrounding an error. Such events can happen repeatedly. E.g. call frequencies.
+			info = 2,  ///A message tagged with info descibes non-repeating events that are handled correctly. E.g. start/stop of interfaces.
+			warning = 4,  ///Warn the user of circumstances that should not arise normally. Use this level if there is a good chance of continued operation.
+			error = 8,  ///The message describes an unexpected failure. Normal operation probably cannot be kept up.
+			param = 16,  ///The message describes an parameter change.
+			profiling = 32, ///The message serves the profiling of the application
+			external = 64,  ///Message coming from an external lib
+			always = 128   ///Message has to be printed always
+		};
+
+#ifdef WIN32
+		/// Stream modifier for blue text
+		inline std::ostream& blue(std::ostream &s)
+		{
+			HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
+			SetConsoleTextAttribute(h,
+				FOREGROUND_BLUE | FOREGROUND_INTENSITY);
+			return s;
+		}
+		/// Stream modifier for red text
+		inline std::ostream& red(std::ostream &s)
+		{
+			HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
+			SetConsoleTextAttribute(h,
+				FOREGROUND_RED | FOREGROUND_INTENSITY);
+			return s;
+		}
+		/// Stream modifier for green text
+		inline std::ostream& green(std::ostream &s)
+		{
+			HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
+			SetConsoleTextAttribute(h,
+				FOREGROUND_GREEN | FOREGROUND_INTENSITY);
+			return s;
+		}
+		/// Stream modifier for yellow text
+		inline std::ostream& yellow(std::ostream &s)
+		{
+			HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
+			SetConsoleTextAttribute(h,
+				FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY);
+			return s;
+		}
+		/// Stream modifier to reset text color
+		inline std::ostream& reset(std::ostream &s)
+		{
+			HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
+			SetConsoleTextAttribute(h,
+				FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
+			return s;
+		}
+#else
+		/// Stream modifier for red text
+		const std::string red("\033[0;31m");
+		/// Stream modifier for green text
+		const std::string green("\033[1;32m");
+		/// Stream modifier for yellow text
+		const std::string yellow("\033[1;33m");
+		/// Stream modifier for cyan text
+		const std::string cyan("\033[0;36m");
+		/// Stream modifier for magenta text
+		const std::string magenta("\033[0;35m");
+		/// Stream modifier to reset text color
+		const std::string reset("\033[0m");
+#endif
+		/// Endline character to use for logging
+		const std::string endl("\n");
+
+		/// Logging base functionality
+		class Base
+		{
+		public:
+			/// Internal: Implementation of logging output
+			template <typename... outObjectTypes>
+			static void log(outObjectTypes... o)
+			{
+				//acquire mutex to make it legible
+				std::lock_guard<std::mutex> lock(sm_streamMutex);
+				logRec(o...);
+				logRecFile(o...);
+			}
+
+			/// Internal: Implementation of logging output with severity
+			template <typename... outObjectTypes>
+			static void log(Severity severity, outObjectTypes... o)
+			{
+				//acquire mutex to make it legible
+				std::lock_guard<std::mutex> lock(sm_streamMutex);
+				if ((severity & sm_logLevel) > 0)
+				{
+					logRec(o..., endl);
+				}
+				logRecFile(o..., endl);
+			}
+
+			/// Sets the output stream for the console log output
+			static void setOutStream(std::ostream* newOut)
+			{
+				std::lock_guard<std::mutex> lock(sm_streamMutex);
+				sm_pOutStream->flush();
+				sm_pOutStream = newOut;
+			}
+
+			/// Sets which log-levels are shown on the console log output.
+			/// Accepts a mask built from values of \see SeverityMask
+			/// default: Severity::warning | Severity::error | Severity::always
+			static void setLogLevel(SeverityMask severity)
+			{
+				sm_logLevel = severity | logging::Severity::always;
+			}
+		private:
+			template <typename firstObjectType>
+			static void logRec(firstObjectType first)
+			{
+				if (std::is_arithmetic<firstObjectType>::value)
+				{
+					(*sm_pOutStream) << std::setbase(10) << first;
+				}
+				else {
+					(*sm_pOutStream) << first;
+				}
+			}
+
+			template <typename firstObjectType, typename... outObjectTypes>
+			static void logRec(firstObjectType first, outObjectTypes... o)
+			{
+				logRec(first);
+				logRec(o...);
+			}
+
+			template <typename firstObjectType>
+			static void logRecFile(firstObjectType first)
+			{
+				if (!sm_logFile.is_open())
+				{
+					initLogfile();
+				}
+
+				if (std::is_arithmetic<firstObjectType>::value)
+				{
+					sm_logFile << std::setbase(10);
+					if (std::is_floating_point<firstObjectType>::value)
+					{
+						sm_logFile << std::setprecision(std::numeric_limits<firstObjectType>::digits10 + 1);
+					}
+					sm_logFile << first;
+					
+				}
+				else {
+					sm_logFile << first;
+				}
+			}
+
+			template <typename firstObjectType, typename... outObjectTypes>
+			static void logRecFile(firstObjectType first, outObjectTypes... o)
+			{
+				logRecFile(first);
+				logRecFile(o...);
+			}
+
+			static void initLogfile()
+			{
+				sm_logFile.open(m_logFileName, std::ios_base::out | std::ios_base::app);
+
+				std::array<char, 64> buffer;
+				buffer.fill(0);
+				std::time_t rawtime;
+				std::time(&rawtime);
+				const auto timeinfo = std::localtime(&rawtime);
+				std::strftime(buffer.data(), sizeof(buffer), "%Y-%m-%d %H:%M:%S", timeinfo);
+
+				sm_logFile << std::endl << std::endl <<
+					"------------------------------------------" << std::endl <<
+					"SUPRA (" << buffer.data() << ")" << std::endl;
+			}
+
+			static std::mutex sm_streamMutex;
+			static std::ostream* sm_pOutStream;
+			static SeverityMask sm_logLevel;
+			static std::ofstream sm_logFile;
+			static const std::string m_logFileName;
+		};
+
+		/// Log entry that has always to be shown.
+		template <typename... outObjectTypes>
+		void log_always(outObjectTypes... o)
+		{
+			Base::log(Severity::always, o...);
+		}
+
+		/// Log entry with the lowest severity, is only logged if cond is true
+		/// Messages that might be of interest when understanding operation surrounding an error. Such events can happen repeatedly. E.g. call frequencies.
+		template <typename... outObjectTypes>
+		void log_log_if(bool cond, outObjectTypes... o)
+		{
+			if (cond)
+			{
+				Base::log(Severity::log, o...);
+			}
+		}
+
+		/// Log entry that informs the user of events of normal operation, is only logged if cond is true
+		/// A message tagged with info descibes non-repeating events that are handled correctly. E.g. start/stop of interfaces.
+		template <typename... outObjectTypes>
+		void log_info_if(bool cond, outObjectTypes... o)
+		{
+			if (cond)
+			{
+				Base::log(Severity::info, o...);
+			}
+		}
+
+		/// Log entry representing a warning, is only logged if cond is true
+		/// Warn the user of circumstances that should not arise normally. Use this level if there is a good chance of continued operation.
+		template <typename... outObjectTypes>
+		void log_warn_if(bool cond, outObjectTypes... o)
+		{
+			if (cond)
+			{
+				Base::log(Severity::warning, yellow, o..., reset);
+			}
+		}
+
+		/// Log entry representing an error, is only logged if cond is true
+		/// The message describes an unexpected failure. Normal operation probably cannot be kept up.
+		template <typename... outObjectTypes>
+		void log_error_if(bool cond, outObjectTypes... o)
+		{
+			if (cond)
+			{
+				Base::log(Severity::error, red, o..., reset);
+			}
+		}
+		/// Log entry containing profiling details
+		/// Should only be used internally by the CallFrequency
+		template <typename... outObjectTypes>
+		void log_profiling_if(bool cond, outObjectTypes... o)
+		{
+			if (cond)
+			{
+				Base::log(Severity::profiling, o...);
+			}
+		}
+
+		/// Log entry with the lowest severity
+		/// Messages that might be of interest when understanding operation surrounding an error. Such events can happen repeatedly. E.g. call frequencies.
+		template <typename... outObjectTypes>
+		void log_log(outObjectTypes... o)
+		{
+			log_log_if(true, o...);
+		}
+		/// Log entry that informs the user of events of normal operation
+		/// A message tagged with info descibes non-repeating events that are handled correctly. E.g. start/stop of interfaces.
+		template <typename... outObjectTypes>
+		void log_info(outObjectTypes... o)
+		{
+			log_info_if(true, o...);
+		}
+		/// Log entry representing a warning
+		/// Warn the user of circumstances that should not arise normally. Use this level if there is a good chance of continued operation.
+		template <typename... outObjectTypes>
+		void log_warn(outObjectTypes... o)
+		{
+			log_warn_if(true, o...);
+		}
+		/// Log entry representing an error
+		/// The message describes an unexpected failure. Normal operation probably cannot be kept up.
+		template <typename... outObjectTypes>
+		void log_error(outObjectTypes... o)
+		{
+			log_error_if(true, o...);
+		}
+		/// Log entry informing about the change of a node parameter
+		/// Should only be used internally by the parameter system
+		template <typename... outObjectTypes>
+		void log_parameter(outObjectTypes... o)
+		{
+			Base::log(Severity::param, o...);
+		}
+		/// Log entry containing profiling details
+		/// Should only be used internally by the CallFrequency
+		template <typename... outObjectTypes>
+		void log_profiling(outObjectTypes... o)
+		{
+			log_profiling_if(true, o...);
+		}
+	}
+}
+
+#endif // !__LOGGING_H__
diff --git a/oneapi/src/SupraLib/utilities/cudaUtility.h b/oneapi/src/SupraLib/utilities/cudaUtility.h
new file mode 100644
index 0000000..8d5356c
--- /dev/null
+++ b/oneapi/src/SupraLib/utilities/cudaUtility.h
@@ -0,0 +1,168 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __CUDAUTILITY_H__
+#define __CUDAUTILITY_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <cmath>
+#ifdef HAVE_CUDA
+#ifdef HAVE_CUFFT
+#include <cufft.h>
+#endif
+#endif
+#include <cstdio>
+#include "utilities/Logging.h"
+#include <algorithm>
+#include <cmath>
+#include <cfloat>
+
+namespace supra
+{
+#ifdef SYCL_LANGUAGE_VERSION
+	using sycl::max;
+	using sycl::min;
+	using sycl::round;
+	using sycl::floor;
+	using sycl::ceil;
+#else
+	using std::max;
+	using std::min;
+	using std::round;
+	using std::floor;
+	using std::ceil;
+#endif
+
+#ifdef HAVE_CUDA
+	//define for portable function name resolution
+	#if defined(__GNUC__)
+	//GCC
+	/// Name of the function this define is referenced. GCC version
+	#define FUNCNAME_PORTABLE __PRETTY_FUNCTION__
+	#elif defined(_MSC_VER)
+	//Visual Studio
+	/// Name of the function this define is referenced. Visual Studio version
+	#define FUNCNAME_PORTABLE __FUNCSIG__
+	#endif
+
+	/// Verifies a cuda call returned "cudaSuccess". Prints error message otherwise.
+	/// returns true if no error occured, false otherwise.
+	#define cudaSafeCall(_err_) cudaSafeCall2(_err_, __FILE__, __LINE__, FUNCNAME_PORTABLE)
+
+	/// Verifies a cuda call returned "cudaSuccess". Prints error message otherwise.
+	/// returns true if no error occured, false otherwise. Calles by cudaSafeCall
+	inline bool cudaSafeCall2(int err, const char* file, int line, const char* func) {
+
+		//#ifdef CUDA_ERROR_CHECK
+		/*
+		DPCT1000:1: Error handling if-stmt was detected but could not be rewritten.
+		*/
+		if (0 != err) {
+			char buf[1024];
+			/*
+			DPCT1001:0: The statement could not be removed.
+			*/
+			/*
+			DPCT1009:2: SYCL uses exceptions to report errors and does not use the error codes. The original code was commented out and a warning string was inserted. You need to rewrite this code.
+			*/
+			sprintf(buf, "CUDA Error (in \"%s\", Line: %d, %s): %d - %s\n", file, line, func, err, "cudaGetErrorString not supported" /*cudaGetErrorString(err)*/);
+			printf("%s", buf);
+			logging::log_error(buf);
+			return false;
+		}
+
+		//#endif
+		return true;
+	}
+
+#ifdef HAVE_CUFFT
+	/// Verifies a cuFFT call returned "CUFFT_SUCCESS". Prints error message otherwise.
+	/// returns true if no error occured, false otherwise.
+    #define cufftSafeCall(_err_) cufftSafeCall2(_err_, __FILE__, __LINE__, FUNCNAME_PORTABLE)
+
+	/// Verifies a cuFFT call returned "CUFFT_SUCCESS". Prints error message otherwise.
+	/// returns true if no error occured, false otherwise. Calles by cudaSafeCall
+	inline bool cufftSafeCall2(cufftResult err, const char* file, int line, const char* func) {
+
+		//#ifdef CUDA_ERROR_CHECK
+		if (CUFFT_SUCCESS != err) {
+			char buf[1024];
+			sprintf(buf, "CUFFT Error (in \"%s\", Line: %d, %s): %d\n", file, line, func, err);
+			printf("%s", buf);
+			logging::log_error(buf);
+			return false;
+		}
+
+		//#endif
+		return true;
+	}
+#endif
+
+	/// Returns the square of x. CUDA constexpr version
+	template <typename T>
+	constexpr inline T squ(const T& x)
+	{
+		return x*x;
+	}
+#else
+	#define __host__
+	#define __device__
+#endif
+
+	template <typename T>
+	class LimitProxy
+	{
+	public:
+		inline static T max();
+		inline static T min();
+	};
+
+	template <>
+	class LimitProxy<float>
+	{
+	public:
+		inline static float max() { return FLT_MAX; }
+		inline static float min() { return -FLT_MAX; }
+	};
+
+	template <>
+	class LimitProxy<int16_t>
+	{
+	public:
+		inline static int16_t max() { return 32767; }
+		inline static int16_t min() { return -32767; }
+	};
+
+	template <>
+	class LimitProxy<uint8_t>
+	{
+	public:
+		inline static uint8_t max() { return 255; }
+		inline static uint8_t min() { return 0; }
+	};
+
+	template <typename ResultType, typename InputType>
+	ResultType clampCast(const InputType& x)
+	{
+		return static_cast<ResultType>(std::min(std::max(x, static_cast<InputType>(LimitProxy<ResultType>::min())), static_cast<InputType>(LimitProxy<ResultType>::max())));
+	}
+
+	template <typename ResultType, typename InputType>
+	struct clampCaster {
+		ResultType operator()(const InputType& a) const
+		{
+			return clampCast<ResultType>(a);
+		}
+	};
+}
+
+#endif // !__CUDAUTILITY_H__
diff --git a/oneapi/src/SupraLib/utilities/cudaUtility.h.yaml b/oneapi/src/SupraLib/utilities/cudaUtility.h.yaml
new file mode 100644
index 0000000..53d3ec0
--- /dev/null
+++ b/oneapi/src/SupraLib/utilities/cudaUtility.h.yaml
@@ -0,0 +1,311 @@
+---
+MainSourceFile:  '/home/wangyon1/projects/supra-projects/golden/supra/oneapi/src/SupraLib/utilities/cudaUtility.h'
+Replacements:
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          535
+    Length:          0
+    ReplacementText: '#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          569
+    Length:          30
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          781
+    Length:          10
+    ReplacementText: SYCL_LANGUAGE_VERSION
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          793
+    Length:          12
+    ReplacementText: 'using sycl::max;'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          807
+    Length:          12
+    ReplacementText: 'using sycl::min;'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          821
+    Length:          14
+    ReplacementText: 'using sycl::round;'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          837
+    Length:          14
+    ReplacementText: 'using sycl::floor;'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          853
+    Length:          13
+    ReplacementText: 'using sycl::ceil;'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          1759
+    Length:          9
+    ReplacementText: int
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          1851
+    Length:          0
+    ReplacementText: '		/*
+		DPCT1000:1: Error handling if-stmt was detected but could not be rewritten.
+		*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          1857
+    Length:          11
+    ReplacementText: '0'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          1898
+    Length:          0
+    ReplacementText: '			/*
+			DPCT1001:0: The statement could not be removed.
+			*/
+			/*
+			DPCT1009:2: SYCL uses exceptions to report errors and does not use the error codes. The original code was commented out and a warning string was inserted. You need to rewrite this code.
+			*/
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          1988
+    Length:          0
+    ReplacementText: '"cudaGetErrorString not supported"/*'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          2011
+    Length:          0
+    ReplacementText: '*/'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          2978
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3158
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3167
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3203
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3212
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3303
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3312
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3371
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3380
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3497
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3506
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3565
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3574
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3691
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3700
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3757
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3766
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3870
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3879
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3967
+    Length:          3
+    ReplacementText: 'std::min'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          3971
+    Length:          3
+    ReplacementText: 'std::max'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          4171
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/cudaUtility.h'
+    Offset:          4180
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+...
diff --git a/oneapi/src/SupraLib/utilities/utility.h b/oneapi/src/SupraLib/utilities/utility.h
new file mode 100644
index 0000000..729de80
--- /dev/null
+++ b/oneapi/src/SupraLib/utilities/utility.h
@@ -0,0 +1,216 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __UTILITY_H__
+#define __UTILITY_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <cctype>
+#include <algorithm>
+#include <vector>
+#include <string>
+#include <sstream>
+#include <stddef.h>
+#include <cstring>
+#include <fstream>
+#include <array>
+
+namespace std
+{
+	/// overload of std function to ease type handling
+	inline std::string to_string(std::string s)
+	{
+		return s;
+	}
+}
+
+namespace supra
+{
+	using std::to_string;
+
+#ifndef M_PI
+	/// Definition of pi for the cuda compile path, as cuda math.h does not seem to provide it.
+	constexpr auto M_PI = 3.14159265358979323846;
+#endif //!M_PI
+	/// Definition of eps following the value of matlabs "eps()"
+	constexpr double M_EPS = 2.2204e-16;
+
+	/// Writes a buffer of given length as text to a file with the given filename
+	template <typename T>
+	void writeAscii(std::string filename, const T* buffer, size_t length)
+	{
+		std::ofstream o(filename);
+		for (size_t i = 0; i < length; i++)
+		{
+			o << buffer[i] << '\n';
+		}
+		o.close();
+	}
+
+	template <typename T>
+	void readChunks(std::ifstream& f, T* destination, size_t numElements, size_t chunkSize)
+	{
+		size_t numElementsChunk = chunkSize / sizeof(T);
+		for (size_t elementsRead = 0; elementsRead < numElements; 
+				elementsRead += numElementsChunk, destination += numElementsChunk)
+		{
+			size_t numToRead = std::min(chunkSize, (numElements - elementsRead) * sizeof(T));
+			f.read(reinterpret_cast<char*>(destination), numToRead);
+		}
+	}
+
+	/// returns the square of x
+	template <typename T>
+	constexpr T sq(T x)
+	{
+		return x*x;
+	}
+
+	/// Conversion function from degree to radian
+	template <typename T>
+	constexpr T degToRad(T deg)
+	{
+		return deg*M_PI / 180.0;
+	}
+	/// Conversion function from radian to degree
+	template <typename T>
+	constexpr T radToDeg(T rad)
+	{
+		return rad * 180 / M_PI;
+	}
+
+	/// Performs a copy between the given buffers while transposing the 2D-matrix,
+	/// exchanging width and height
+	template <typename T>
+	void memcpyTransposed(T* dest, const T* src, size_t width, size_t height)
+	{
+		for (size_t x = 0; x < width; x++)
+		{
+			for (size_t y = 0; y < height; y++)
+			{
+				dest[y*width + x] = src[x*height + y];
+			}
+		}
+	}
+
+	/// Converts the argument to a string with its operator<<
+	/// As opposed to stdlibs to_string the locale can be modified conviniently
+	template <typename valueType>
+	std::string stringify(valueType v)
+	{
+		std::stringstream ss;
+		ss << v;
+		return ss.str();
+	}
+
+	/// Converts the vector argument to a string
+	template <typename valueType>
+	std::string stringify(std::vector<valueType> v)
+	{
+		std::string b;
+		if (v.size() > 0)
+		{
+			b += "[";
+			for (valueType& value : v)
+			{
+				b += to_string(value) + ", ";
+			}
+			b.erase(b.end() - 1, b.end());
+			b += "]";
+			return b;
+		}
+		else {
+			return "[]";
+		}
+	}
+
+	/// Converts the argument to a string (true|false)
+	template <>
+	std::string stringify(std::vector<bool> v);
+
+	/// Converts the array argument to a string
+	template <typename valueType, size_t N>
+	std::string stringify(std::array<valueType, N> v)
+	{
+		std::string b;
+		if (N > 0)
+		{
+			b += "[";
+			for (valueType& value : v)
+			{
+				b += to_string(value) + ", ";
+			}
+			b.erase(b.end() - 1, b.end());
+			b += "]";
+			return b;
+		}
+		else {
+			return "[]";
+		}
+	}
+
+	/// Converts the string argument to the type specified via its operator>>
+	template <typename T>
+	T from_string(const std::string& s) {
+		std::stringstream ss(s);
+		T t;
+		ss >> t;
+		return t;
+	}
+
+	/// Converts a string to a newly allocated cstr.
+	/// ATTENTION: The returned buffer has to be deleted with `delete[] <ptr>`!
+	inline char* stringToNewCstr(std::string org)
+	{
+		size_t len = org.length();
+		char* ret = new char[len + 1];
+		memcpy(ret, org.c_str(), (len + 1) * sizeof(char));
+		return ret;
+	}
+
+	/// Trims leading and trailing whitespace from the string
+	inline std::string trim(const std::string &str)
+	{
+		auto strStart = std::find_if(str.begin(), str.end(), [](int ch) {return !std::isspace(ch);} );
+		auto strEnd = std::find_if(str.rbegin(), str.rend(), [](int ch) {return !std::isspace(ch);} ).base();
+		if (strEnd <= strStart)
+		{
+			return std::string();
+		}
+		else {
+			return std::string(strStart, strEnd);
+		}
+	}
+
+	inline std::vector<std::string> split(const std::string &str, char delimiter)
+	{
+		std::vector<std::string> tokens;
+		std::stringstream s(str);
+		std::string token;
+		while (std::getline(s, token, delimiter))
+		{
+			tokens.push_back(token);
+		}
+		return tokens;
+	}
+
+	/// Returns current time in seconds. The resolution depends on the operating system.
+	double getCurrentTime();
+
+	/// Performs a busy wait for the given number of microseconds. This is just a debug-tool
+	void busyWait(size_t microseconds);
+
+	/// Returns whether the given file exists
+	bool fileExists(const std::string& path);
+}
+
+#endif // !__UTILITY_H__
diff --git a/oneapi/src/SupraLib/utilities/utility.h.yaml b/oneapi/src/SupraLib/utilities/utility.h.yaml
new file mode 100644
index 0000000..8a5cc6f
--- /dev/null
+++ b/oneapi/src/SupraLib/utilities/utility.h.yaml
@@ -0,0 +1,22 @@
+---
+MainSourceFile:  '/home/wangyon1/projects/supra-projects/golden/supra/oneapi/src/SupraLib/utilities/utility.h'
+Replacements:
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/utility.h'
+    Offset:          527
+    Length:          0
+    ReplacementText: '#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/utilities/utility.h'
+    Offset:          1761
+    Length:          61
+    ReplacementText: 'std::min(chunkSize, (numElements - elementsRead) * sizeof(T))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+...
diff --git a/oneapi/src/SupraLib/vec.h b/oneapi/src/SupraLib/vec.h
new file mode 100644
index 0000000..8b10d3e
--- /dev/null
+++ b/oneapi/src/SupraLib/vec.h
@@ -0,0 +1,412 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __VEC_H__
+#define __VEC_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "utilities/utility.h"
+#include "utilities/cudaUtility.h"
+#include <cmath>
+
+namespace supra
+{
+	template <typename ElementType>
+	struct vec2T;
+	template <typename ElementType>
+	struct vec3T;
+	template <typename ElementType>
+	struct vec4T;
+
+	/// Vector of two elements of type ElementType
+	template <typename ElementType>
+	struct vec2T
+	{
+		/// The first element of the two-vector
+		ElementType x;
+		/// The second element of the two-vector
+		ElementType y;
+
+		/// Explicit numeric conversion operator. Casts both elements seperately to NewElementType
+		template <typename NewElementType>
+		explicit operator vec2T<NewElementType>() const
+		{
+			return vec2T<NewElementType>{
+				static_cast<NewElementType>(this->x),
+					static_cast<NewElementType>(this->y) };
+		}
+
+		/// Equality operator. Compares this and b elementwise for equality
+		bool operator==(const vec2T<ElementType>& b) const
+		{
+			return x == b.x && y == b.y;
+		}
+
+		/// Inequality operator. Compares this and b elementwise for inequality
+		bool operator!=(const vec2T<ElementType>& b) const
+		{
+			return x != b.x || y != b.y;
+		}
+	};
+
+	/// Vector of three elements of type ElementType
+	template <typename ElementType>
+	struct vec3T
+	{
+		/// The first element of the three-vector
+		ElementType x;
+		/// The second element of the three-vector
+		ElementType y;
+		/// The third element of the three-vector
+		ElementType z;
+
+		/// Conversion of a 3-vector representing a POINT to homogeneous coordinates
+		vec4T<ElementType> pointToHom() const { return vec4T<ElementType>({ this->x, this->y, this->z, 1 }); }
+		/// Explicit conversion of a 3-vector representing a POINT to homogeneous coordinates
+		explicit operator vec4T<ElementType>() const { return pointToHom(); };
+
+		/// Conversion of a 3-vector representing a VECTOR to homogeneous coordinates
+		vec4T<ElementType> vectorToHom() const { return vec4T<ElementType>({ this->x, this->y, this->z, 0 }); }
+
+		/// Explicit numeric conversion operator. Casts both elements seperately to NewElementType
+		template <typename NewElementType>
+		explicit operator vec3T<NewElementType>() const
+		{
+			return vec3T<NewElementType>{
+				static_cast<NewElementType>(this->x),
+					static_cast<NewElementType>(this->y),
+					static_cast<NewElementType>(this->z) };
+		}
+
+		/// Equality operator. Compares this and b elementwise for equality
+		bool operator==(const vec3T<ElementType>& b) const
+		{
+			return x == b.x && y == b.y && z == b.z;
+		}
+
+		/// Inequality operator. Compares this and b elementwise for inequality
+		bool operator!=(const vec3T<ElementType>& b) const
+		{
+			return x != b.x || y != b.y || z != b.z;
+		}
+	};
+
+	/// Vector of four elements of type ElementType
+	template <typename ElementType>
+	struct vec4T
+	{
+		/// The first element of the four-vector
+		ElementType x;
+		/// The second element of the four-vector
+		ElementType y;
+		/// The third element of the four-vector
+		ElementType z;
+		/// The fourth element of the four-vector
+		ElementType w;
+	};
+
+	/// Rectangle in 2D of type ElementType
+	template <typename ElementType>
+	struct rect2T
+	{
+		/// Inclusive begin of the rectangle in top-left
+		vec2T<ElementType> begin;
+		/// Inclusive end of the rectangle in bottom-right
+		vec2T<ElementType> end;
+	};
+
+	/// Single precision two-vector
+	typedef vec2T<float> vec2f;
+	/// Single precision three-vector
+	typedef vec3T<float> vec3f;
+	/// Single precision four-vector
+	typedef vec4T<float> vec4f;
+
+	/// Double precision two-vector
+	typedef vec2T<double> vec2d;
+	/// Double precision three-vector
+	typedef vec3T<double> vec3d;
+	/// Double precision four-vector
+	typedef vec4T<double> vec4d;
+
+	/// Integer two-vector
+	typedef vec2T<int> vec2i;
+	/// Integer three-vector
+	typedef vec3T<int> vec3i;
+	/// Integer four-vector
+	typedef vec4T<int> vec4i;
+
+	/// size_t two-vector
+	typedef vec2T<size_t> vec2s;
+	/// size_t three-vector
+	typedef vec3T<size_t> vec3s;
+	/// size_t four-vector
+	typedef vec4T<size_t> vec4s;
+
+	/// Double precision two-vector
+	typedef vec2d vec2;
+	/// Double precision three-vector
+	typedef vec3d vec3;
+	/// Double precision four-vector
+	typedef vec4d vec4;
+
+	/// Double precision three-vector
+	typedef vec3 vec;
+
+	/// Single precision rectangle
+	typedef rect2T<float> rect2f;
+	/// Double precision rectangle
+	typedef rect2T<double> rect2d;
+	/// Integer rectangle
+	typedef rect2T<int> rect2i;
+	/// size_t rectangle
+	typedef rect2T<size_t> rect2s;
+
+	/// Double precision rectangle
+	typedef rect2d rect2;
+	/// Double precision rectangle
+	typedef rect2 rect;
+
+	/// Element-wise sum of a two-vector and a scalar
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator+(const vec2T<Ta>& a, const Tb& b) {
+		return vec2T<Ta>({ a.x + b, a.y + b });
+	}
+	/// Negation of a two-vector
+	template <typename Ta> SYCL_EXTERNAL inline vec2T<Ta> operator-(const vec2T<Ta>& a) {
+		return vec2T<Ta>({ -a.x, -a.y });
+	}
+	/// Element-wise subtraction of a two-vector and a scalar
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator-(const vec2T<Ta>& a, const Tb& b) {
+		return vec2T<Ta>({ a.x - b, a.y - b });
+	}
+	/// Product of a two-vector and a scalar
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator*(const vec2T<Ta>& a, const Tb& b) {
+		return vec2T<Ta>({ a.x * b, a.y * b });
+	}
+	/// Element-wise division of a two-vector and a scalar
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator/(const vec2T<Ta>& a, const Tb& b) {
+		return vec2T<Ta>({ a.x / b, a.y / b });
+	}
+	/// Element-wise sum of a scalar and a two-vector
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator+(const Tb& b, const vec2T<Ta>& a) {
+		return vec2T<Ta>({ a.x + b, a.y + b });
+	}
+	/// Element-wise difference of a scalar and a two-vector
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator-(const Tb& b, const vec2T<Ta>& a) {
+		return vec2T<Ta>({ b - a.x, b - a.y });
+	}
+	/// Product of a scalar and a two-vector
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator*(const Tb& b, const vec2T<Ta>& a) {
+		return vec2T<Ta>({ a.x * b, a.y * b });
+	}
+	/// Element-wise division of two-vectors
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator/(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+		return vec2T<Ta>({ a.x / b.x, a.y / b.y });
+	}
+	/// Sum of two-vectors
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator+(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+		return vec2T<Ta>({ a.x + b.x, a.y + b.y });
+	}
+	/// Difference of two-vectors
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator-(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+		return vec2T<Ta>({ a.x - b.x, a.y - b.y });
+	}
+	/// Element-wise product of two-vectors
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator*(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+		return vec2T<Ta>({ a.x * b.x, a.y * b.y });
+	}
+	/// Euclidean norm of a two-vector
+	template <typename Ta>
+	inline Ta norm(const vec2T<Ta>& a)
+	{
+		return sqrt(a.x*a.x + a.y*a.y);
+	}
+	/// Normalization of a two-vector
+	template <typename Ta>
+	inline vec2T<Ta> normalize(const vec2T<Ta>& a)
+	{
+		return a / norm(a);
+	}
+
+	/// Element-wise round of a two-vector
+	template <typename Ta>
+	inline vec2T<Ta> round(const vec2T<Ta>& a)
+	{
+		return{ round(a.x), round(a.y) };
+	}
+	/// Element-wise floor of a two-vector
+	template <typename Ta>
+	inline vec2T<Ta> floor(const vec2T<Ta>& a)
+	{
+		return { sycl::floor(( double )(a.x)), sycl::floor(( double )(a.y)) };
+	}
+	/// Element-wise ceil of a two-vector
+	template <typename Ta>
+	inline vec2T<Ta> ceil(const vec2T<Ta>& a)
+	{
+		return { sycl::ceil(( double )(a.x)), sycl::ceil(( double )(a.y)) };
+	}
+	/// Element-wise minimum of two-vectors
+	template <typename Ta>
+	inline vec2T<Ta> min(const vec2T<Ta>& a, const vec2T<Ta>& b)
+	{
+		return { std::min(a.x, b.x), std::min(a.y, b.y) };
+	}
+	/// Element-wise maximum of two-vectors
+	template <typename Ta>
+	inline vec2T<Ta> max(const vec2T<Ta>& a, const vec2T<Ta>& b)
+	{
+		return { std::max(a.x, b.x), std::max(a.y, b.y) };
+	}
+
+	/// Element-wise sum of a three-vector and a scalar
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator+(const vec3T<Ta>& a, const Tb& b) {
+		return vec3T<Ta>({ a.x + b, a.y + b, a.z + b });
+	}
+	/// Negation of a three-vector
+	template <typename Ta> SYCL_EXTERNAL inline vec3T<Ta> operator-(const vec3T<Ta>& a) {
+		return vec3T<Ta>({ -a.x, -a.y, -a.z });
+	}
+	/// Element-wise subtraction of a three-vector and a scalar
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator-(const vec3T<Ta>& a, const Tb& b) {
+		return vec3T<Ta>({ a.x - b, a.y - b, a.z - b });
+	}
+	/// Product of a three-vector and a scalar
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator*(const vec3T<Ta>& a, const Tb& b) {
+		return vec3T<Ta>({ a.x * b, a.y * b, a.z * b });
+	}
+	/// Element-wise division of a three-vector and a scalar
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator/(const vec3T<Ta>& a, const Tb& b) {
+		return vec3T<Ta>({ a.x / b, a.y / b, a.z / b });
+	}
+	/// Element-wise sum of a scalar and a three-vector
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator+(const Tb& b, const vec3T<Ta>& a) {
+		return vec3T<Ta>({ a.x + b, a.y + b, a.z + b });
+	}
+	/// Element-wise difference of a scalar and a three-vector
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator-(const Tb& b, const vec3T<Ta>& a) {
+		return vec3T<Ta>({ b - a.x, b - a.y, b - a.z });
+	}
+	/// Product of a scalar and a three-vector
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator*(const Tb& b, const vec3T<Ta>& a) {
+		return vec3T<Ta>({ a.x * b, a.y * b, a.z * b });
+	}
+	/// Element-wise division of three-vectors
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator/(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+		return vec3T<Ta>({ a.x / b.x, a.y / b.y, a.z / b.z });
+	}
+	/// Sum of three-vectors
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator+(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+		return vec3T<Ta>({ a.x + b.x, a.y + b.y, a.z + b.z });
+	}
+	/// Difference of three-vectors
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator-(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+		return vec3T<Ta>({ a.x - b.x, a.y - b.y, a.z - b.z });
+	}
+	/// Element-wise product of three-vectors
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator*(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+		return vec3T<Ta>({ a.x * b.x, a.y * b.y, a.z * b.z });
+	}
+
+	/// Euclidean norm of a three-vector
+	template <typename Ta>
+	inline Ta norm(const vec3T<Ta>& a)
+	{
+		return sycl::sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
+	}
+	/// Normalization of a three-vector
+	template <typename Ta>
+	inline vec3T<Ta> normalize(const vec3T<Ta>& a)
+	{
+		return a / norm(a);
+	}
+	/// Dot-product of two three-vectors
+	template <typename Ta, typename Tb>
+	inline typename std::common_type<Ta, Tb>::type dot(const vec3T<Ta>& a, const vec3T<Tb>& b)
+	{
+		return a.x*b.x + a.y*b.y + a.z*b.z;
+	}
+	/// Cross-product of two three-vectors
+	template <typename Ta, typename Tb>
+	inline vec3T<typename std::common_type<Ta, Tb>::type > cross(const vec3T<Ta>& a, const vec3T<Tb>& b)
+	{
+		return{
+			a.y*b.z - a.z*b.y,
+			a.z*b.x - a.x*b.z,
+			a.x*b.y - a.y*b.x
+		};
+	}
+	/// Determinant of matric \f$[a, b, c]\f$
+	template <typename Ta, typename Tb, typename Tc>
+	inline typename std::common_type<Ta, Tb, Tc>::type det(const vec3T<Ta>& a, const vec3T<Tb>& b, const vec3T<Tc>& c)
+	{
+		return sycl::fabs(dot(a, cross(b, c)));
+	}
+	/// Element-wise round of a three-vector
+	template <typename Ta>
+	inline vec3T<Ta> round(const vec3T<Ta>& a)
+	{
+		return{ round(a.x), round(a.y), round(a.z) };
+	}
+	/// Element-wise floor of a three-vector
+	template <typename Ta>
+	inline vec3T<Ta> floor(const vec3T<Ta>& a)
+	{
+		return { sycl::floor(( double )(a.x)), sycl::floor(( double )(a.y)), sycl::floor(( double )(a.z)) };
+	}
+	/// Element-wise ceil of a three-vector
+	template <typename Ta>
+	inline vec3T<Ta> ceil(const vec3T<Ta>& a)
+	{
+		return { sycl::ceil(( double )(a.x)), sycl::ceil(( double )(a.y)), sycl::ceil(( double )(a.z)) };
+	}
+
+	/// Element-wise minimum of three-vectors
+	template <typename Ta>
+	inline vec3T<Ta> min(const vec3T<Ta>& a, const vec3T<Ta>& b)
+	{
+		return { std::min(a.x, b.x), std::min(a.y, b.y), std::min(a.z, b.z) };
+	}
+
+	/// Element-wise maximum of three-vectors
+	template <typename Ta>
+	inline vec3T<Ta> max(const vec3T<Ta>& a, const vec3T<Ta>& b)
+	{
+		return { std::max(a.x, b.x), std::max(a.y, b.y), std::max(a.z, b.z) };
+	}
+
+	/// Spherical Linear Interpolation (SLERP) of two three-vectors
+	template <typename T>
+	vec3T<T> inline slerp3(const vec3T<T>& a, const vec3T<T>& b, const T& t)
+	{
+		T omega = sycl::acos(( double )(dot(a, b)));
+		if (omega < M_EPS)
+		{
+			return a;
+		}
+		vec3T<T> ret;
+		if (t < M_EPS)
+		{
+			ret = a;
+		}
+		else if ((T)1.0 - t < M_EPS)
+		{
+			ret = b;
+		}
+		else {
+			ret = (sycl::sin((( T )1.0 - t) * omega) / sycl::sin(omega)) * a + (sycl::sin(t * omega) / sycl::sin(omega)) * b;
+		}
+		return ret;
+	}
+}
+
+#endif //!__VEC_H__
diff --git a/oneapi/src/SupraLib/vec.h.yaml b/oneapi/src/SupraLib/vec.h.yaml
new file mode 100644
index 0000000..396054a
--- /dev/null
+++ b/oneapi/src/SupraLib/vec.h.yaml
@@ -0,0 +1,1056 @@
+---
+MainSourceFile:  '/home/wangyon1/projects/supra-projects/golden/supra/oneapi/src/SupraLib/vec.h'
+Replacements:
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          519
+    Length:          0
+    ReplacementText: '#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          584
+    Length:          0
+    ReplacementText: '
+#include <cmath>
+'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          1099
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          1108
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          1368
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          1377
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          1556
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          1565
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          2038
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          2047
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          2251
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          2260
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          2425
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          2434
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          2682
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          2691
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          2994
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          3003
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          3194
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          3203
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          5279
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          5288
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          5461
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          5470
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          5666
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          5675
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          5873
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          5882
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          6094
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          6103
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          6310
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          6319
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          6533
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          6542
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          6740
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          6749
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          6947
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          6956
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          7147
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          7156
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          7354
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          7363
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          7571
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          7580
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          7770
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          7779
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          7925
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          7934
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8086
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8095
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8256
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8265
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8332
+    Length:          10
+    ReplacementText: 'sycl::floor((double)(a.x))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8344
+    Length:          10
+    ReplacementText: 'sycl::floor((double)(a.y))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8425
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8434
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8500
+    Length:          9
+    ReplacementText: 'sycl::ceil((double)(a.x))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8511
+    Length:          9
+    ReplacementText: 'sycl::ceil((double)(a.y))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8593
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8602
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8690
+    Length:          3
+    ReplacementText: 'std::min'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8708
+    Length:          3
+    ReplacementText: 'std::min'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8796
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8805
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8893
+    Length:          3
+    ReplacementText: 'std::max'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          8911
+    Length:          3
+    ReplacementText: 'std::max'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          9025
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          9034
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          9218
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          9227
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          9431
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          9440
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          9649
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          9658
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          9881
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          9890
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          10108
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          10117
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          10342
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          10351
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          10560
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          10569
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          10778
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          10787
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          10991
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          11000
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          11211
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          11220
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          11441
+    Length:          9
+    ReplacementText: 'SYCL_EXTERNAL '
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          11450
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          11654
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          11663
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          11721
+    Length:          33
+    ReplacementText: 'sycl::sqrt(a.x*a.x + a.y*a.y + a.z*a.z)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          11821
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          11830
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          11992
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          12001
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          12225
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          12234
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          12526
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          12535
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          12673
+    Length:          24
+    ReplacementText: 'sycl::fabs(dot(a, cross(b, c)))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          12769
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          12778
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          12953
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          12962
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13029
+    Length:          10
+    ReplacementText: 'sycl::floor((double)(a.x))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13041
+    Length:          10
+    ReplacementText: 'sycl::floor((double)(a.y))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13053
+    Length:          10
+    ReplacementText: 'sycl::floor((double)(a.z))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13136
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13145
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13211
+    Length:          9
+    ReplacementText: 'sycl::ceil((double)(a.x))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13222
+    Length:          9
+    ReplacementText: 'sycl::ceil((double)(a.y))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13233
+    Length:          9
+    ReplacementText: 'sycl::ceil((double)(a.z))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13318
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13327
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13415
+    Length:          3
+    ReplacementText: 'std::min'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13433
+    Length:          3
+    ReplacementText: 'std::min'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13451
+    Length:          3
+    ReplacementText: 'std::min'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13542
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13551
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13639
+    Length:          3
+    ReplacementText: 'std::max'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13657
+    Length:          3
+    ReplacementText: 'std::max'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13675
+    Length:          3
+    ReplacementText: 'std::max'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13787
+    Length:          9
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13796
+    Length:          11
+    ReplacementText: ''
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          13895
+    Length:          15
+    ReplacementText: 'sycl::acos((double)(dot(a, b)))'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          14077
+    Length:          23
+    ReplacementText: 'sycl::sin(((T)1.0 - t)*omega)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          14103
+    Length:          10
+    ReplacementText: 'sycl::sin(omega)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          14124
+    Length:          13
+    ReplacementText: 'sycl::sin(t *omega)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+  - FilePath:        '/home/wangyon1/projects/supra-projects/golden/supra/src/SupraLib/vec.h'
+    Offset:          14140
+    Length:          10
+    ReplacementText: 'sycl::sin(omega)'
+    ConstantFlag:    ''
+    ConstantOffset:  0
+    InitStr:         ''
+    NewHostVarName:  ''
+...
diff --git a/src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp b/src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp
new file mode 100644
index 0000000..f2823f9
--- /dev/null
+++ b/src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp
@@ -0,0 +1,132 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2019, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "HilbertFirEnvelope.h"
+#include <utilities/utility.h>
+#include <utilities/FirFilterFactory.h>
+
+#include <dpct/dpl_utils.hpp>
+#include <oneapi/dpl/execution>
+#include <oneapi/dpl/algorithm>
+
+#include <algorithm>
+
+using namespace std;
+
+namespace supra
+{
+	template <typename InputType, typename OutputType>
+	void kernelFilterDemodulation(
+		const InputType* __restrict__ signal,
+		const HilbertFirEnvelope::WorkType * __restrict__ filter,
+		OutputType * __restrict__ out,
+		const int numSamples,
+		const int numScanlines,
+		const int filterLength,
+		sycl::nd_item<3> item_ct1) {
+		int scanlineIdx = item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2);
+		int sampleIdx = item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1);
+
+		if (scanlineIdx < numScanlines && sampleIdx < numSamples)
+		{
+			HilbertFirEnvelope::WorkType accumulator = 0;
+			
+			int startPoint = sampleIdx - filterLength / 2;
+			int endPoint = sampleIdx + filterLength / 2;
+			int currentFilterElement = 0;
+			for (int currentSample = startPoint;
+				currentSample <= endPoint;
+				currentSample++, currentFilterElement++)
+			{
+				if (currentSample >= 0 && currentSample < numSamples)
+				{
+					HilbertFirEnvelope::WorkType sample = static_cast<HilbertFirEnvelope::WorkType>(signal[scanlineIdx + currentSample*numScanlines]);
+					HilbertFirEnvelope::WorkType filterElement = filter[currentFilterElement];
+					accumulator += sample*filterElement;
+				}
+			}
+
+			HilbertFirEnvelope::WorkType signalValue = static_cast<HilbertFirEnvelope::WorkType>(signal[scanlineIdx + sampleIdx*numScanlines]);
+			out[ scanlineIdx + sampleIdx * numScanlines ] = sycl::sqrt(squ(signalValue) + squ(accumulator));
+		}
+
+	}
+
+	HilbertFirEnvelope::HilbertFirEnvelope(size_t filterLength)
+		: m_filterLength(filterLength)
+		, m_hilbertFilter(nullptr)
+	{
+		prepareFilter();
+	}
+
+	HilbertFirEnvelope::~HilbertFirEnvelope()
+	{
+	}
+
+	void HilbertFirEnvelope::prepareFilter()
+	{
+		m_hilbertFilter = FirFilterFactory::createFilter<float>(
+			m_filterLength,
+			FirFilterFactory::FilterTypeHilbertTransformer,
+			FirFilterFactory::FilterWindowHamming);
+		m_hilbertFilter = make_shared<Container<float> >(LocationGpu, *m_hilbertFilter);
+	}
+
+	template<typename InputType, typename OutputType>
+	shared_ptr<Container<OutputType> > HilbertFirEnvelope::demodulate(
+		const shared_ptr<const Container<InputType>>& inImageData,
+		int numScanlines, int numSamples)
+	{
+		auto pEnv = make_shared<Container<OutputType> >(LocationGpu, inImageData->getStream(), numScanlines*numSamples);
+		sycl::range<3> blockSizeFilter(1, 8, 16);
+		sycl::range<3> gridSizeFilter(1, static_cast<unsigned int>((numSamples + blockSizeFilter[ 1 ] - 1) / blockSizeFilter[ 1 ]),
+									  static_cast<unsigned int>((numScanlines + blockSizeFilter[ 2 ] - 1) / blockSizeFilter[ 2 ]));
+
+		/*
+		DPCT1049:27: The workgroup size passed to the SYCL kernel may exceed the limit. To get the device limit, query info::device::max_work_group_size. Adjust the workgroup size if needed.
+		*/
+				inImageData->getStream()->submit([ & ](sycl::handler& cgh) {
+						auto inImageData_get_ct0 = inImageData->get();
+						auto m_hilbertFilter_get_ct1 = m_hilbertFilter->get();
+						auto pEnv_get_ct2 = pEnv->get();
+						auto m_filterLength_ct5 = ( int )m_filterLength;
+
+						cgh.parallel_for(sycl::nd_range<3>(gridSizeFilter * blockSizeFilter, blockSizeFilter), [ = ](sycl::nd_item<3> item_ct1) {
+								kernelFilterDemodulation(inImageData_get_ct0, m_hilbertFilter_get_ct1, pEnv_get_ct2, numSamples, numScanlines, m_filterLength_ct5, item_ct1);
+						});
+				});
+		/*
+		DPCT1010:26: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+
+		return pEnv;
+	}
+
+	template 
+	shared_ptr<Container<int16_t> > HilbertFirEnvelope::demodulate<int16_t, int16_t>(
+		const shared_ptr<const Container<int16_t> >& inImageData,
+		int numScanlines, int numSamples);
+	template
+		shared_ptr<Container<int16_t> > HilbertFirEnvelope::demodulate<float, int16_t>(
+			const shared_ptr<const Container<float> >& inImageData,
+			int numScanlines, int numSamples);
+	template
+		shared_ptr<Container<float> > HilbertFirEnvelope::demodulate<int16_t, float>(
+			const shared_ptr<const Container<int16_t> >& inImageData,
+			int numScanlines, int numSamples);
+	template
+		shared_ptr<Container<float> > HilbertFirEnvelope::demodulate<float, float>(
+			const shared_ptr<const Container<float> >& inImageData,
+			int numScanlines, int numSamples);
+}
\ No newline at end of file
diff --git a/src/SupraLib/Beamformer/LogCompressor.dp.cpp b/src/SupraLib/Beamformer/LogCompressor.dp.cpp
new file mode 100644
index 0000000..7389daf
--- /dev/null
+++ b/src/SupraLib/Beamformer/LogCompressor.dp.cpp
@@ -0,0 +1,90 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "LogCompressor.h"
+
+#include <dpct/dpl_utils.hpp>
+#include <oneapi/dpl/execution>
+#include <oneapi/dpl/algorithm>
+#include <cmath>
+
+using namespace std;
+
+namespace supra
+{
+	template <typename In, typename Out, typename WorkType>
+	/*
+	DPCT1044:29: thrust::unary_function was removed because std::unary_function has been deprecated in C++11. You may need to remove references to typedefs from thrust::unary_function in the class
+	definition.
+	*/
+	struct thrustLogcompress {
+		WorkType _inScale;
+		WorkType _scaleOverDenominator;
+
+		// Thrust functor that computes
+		// signal = log10(1 + a*signal)./log10(1 + a) 
+		// of the downscaled (_inMax) input signal
+		thrustLogcompress(double dynamicRange, In inMax, Out outMax, double scale)
+			: _inScale(static_cast<WorkType>(dynamicRange / inMax))
+			, _scaleOverDenominator(static_cast<WorkType>(scale * outMax / log10(dynamicRange + 1)))
+		{};
+
+		Out operator()(const In& a) const
+		{
+			WorkType val = log10(abs(static_cast<WorkType>(a))*_inScale + (WorkType)1) * _scaleOverDenominator;
+			return clampCast<Out>(val);
+		}
+	};
+
+	template <typename InputType, typename OutputType>
+	shared_ptr<Container<OutputType> > LogCompressor::compress(const shared_ptr<const Container<InputType>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax)
+	{
+		size_t width = size.x;
+		size_t height = size.y;
+		size_t depth = size.z;
+
+		auto pComprGpu = make_shared<Container<OutputType> >(LocationGpu, inImageData->getStream(), width*height*depth);
+
+		OutputType outMax;
+		if (std::is_integral<OutputType>::value)
+		{
+			outMax = std::numeric_limits<OutputType>::max();
+		}
+		else if (std::is_floating_point<OutputType>::value)
+		{
+			outMax = static_cast<OutputType>(255.0);
+		}
+
+		thrustLogcompress<InputType, OutputType, WorkType> c(sycl::pow<double>(10, (dynamicRange / 20)), static_cast<InputType>(inMax), outMax, scale);
+		std::transform(thrust::cuda::par.on(inImageData->getStream()), inImageData->get(), inImageData->get() + (width * height * depth), pComprGpu->get(), c);
+		/*
+		DPCT1010:28: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+
+		return pComprGpu;
+	}
+
+	template
+	shared_ptr<Container<uint8_t> > LogCompressor::compress<int16_t, uint8_t>(const shared_ptr<const Container<int16_t> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<uint8_t> > LogCompressor::compress<float, uint8_t>(const shared_ptr<const Container<float> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<uint8_t> > LogCompressor::compress<uint8_t, uint8_t>(const shared_ptr<const Container<uint8_t> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<float> > LogCompressor::compress<int16_t, float>(const shared_ptr<const Container<int16_t> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<float> > LogCompressor::compress<float, float>(const shared_ptr<const Container<float> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<float> > LogCompressor::compress<uint8_t, float>(const shared_ptr<const Container<uint8_t> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+}
\ No newline at end of file
diff --git a/src/SupraLib/Beamformer/RxBeamformerCommon.h b/src/SupraLib/Beamformer/RxBeamformerCommon.h
index 1e9f442..1527995 100644
--- a/src/SupraLib/Beamformer/RxBeamformerCommon.h
+++ b/src/SupraLib/Beamformer/RxBeamformerCommon.h
@@ -12,6 +12,8 @@
 #ifndef __RXBEAMFORMERCOMMON_H__
 #define __RXBEAMFORMERCOMMON_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include "WindowFunction.h"
 
 //TODO ALL ELEMENT/SCANLINE Y positons are actually Z! Change all variable names accordingly
@@ -19,13 +21,13 @@ namespace supra
 {
 
 	template <typename T>
-	__device__ inline T computeAperture_D(T F, T z)
+	inline T computeAperture_D(T F, T z)
 	{
 		return z / (2 * F);
 	}
 
 	template <typename T>
-	__device__ inline T computeDelayDTSPACE_D(T dirX, T dirY, T dirZ, T x_element, T x, T z)
+	inline T computeDelayDTSPACE_D(T dirX, T dirY, T dirZ, T x_element, T x, T z)
 	{
 		return sqrt((x_element - (x + dirX*z))*
 			(x_element - (x + dirX*z)) +
@@ -33,7 +35,7 @@ namespace supra
 	}
 
 	template <typename T>
-	__device__ inline T computeDelayDTSPACE3D_D(T dirX, T dirY, T dirZ, T x_element, T z_element, T x, T z, T d)
+	inline T computeDelayDTSPACE3D_D(T dirX, T dirY, T dirZ, T x_element, T z_element, T x, T z, T d)
 	{
 		return sqrt(
 			squ(x_element - (x + dirX*d)) +
@@ -42,22 +44,18 @@ namespace supra
 	}
 
 	// distance has to be normalized to [-1, 1] (inclusive)
-	__device__ inline WindowFunctionGpu::ElementType
+	inline WindowFunctionGpu::ElementType
 		computeWindow3D(const WindowFunctionGpu& windowFunction, const vec2f& distance)
 	{
-		return
-			sqrt(windowFunction.get(distance.x)*
-				windowFunction.get(distance.y));
+		return sycl::sqrt(windowFunction.get(distance.x) * windowFunction.get(distance.y));
 	}
 
 
 	// distance has to be normalized to [-1, 1] (inclusive)
-	__device__ inline WindowFunctionGpu::ElementType
+	inline WindowFunctionGpu::ElementType
 		computeWindow3DShared(const WindowFunctionGpu& windowFunction, const WindowFunctionGpu::ElementType * __restrict__ sharedData, const vec2f& distance)
 	{
-		return
-			sqrt(windowFunction.getShared(sharedData, distance.x)*
-				windowFunction.getShared(sharedData, distance.y));
+		return sycl::sqrt(windowFunction.getShared(sharedData, distance.x) * windowFunction.getShared(sharedData, distance.y));
 	}
 }
 
diff --git a/src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp b/src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp
new file mode 100644
index 0000000..39f80ff
--- /dev/null
+++ b/src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp
@@ -0,0 +1,627 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "RxBeamformerCuda.h"
+#include "USImage.h"
+#include "USRawData.h"
+#include "RxSampleBeamformerDelayAndSum.h"
+#include "RxSampleBeamformerDelayAndStdDev.h"
+#include "RxSampleBeamformerTestSignal.h"
+#include "RxBeamformerCommon.h"
+#include "utilities/cudaUtility.h"
+
+//TODO ALL ELEMENT/SCANLINE Y positons are actually Z! Change all variable names accordingly
+namespace supra
+{
+	RxBeamformerCuda::RxBeamformerCuda(const RxBeamformerParameters & parameters)
+		: m_windowFunction(nullptr)
+	{
+  dpct::device_ext& dev_ct1 = dpct::get_current_device();
+  sycl::queue&	  q_ct1 = dev_ct1.default_queue();
+		m_lastSeenDt = 0;
+		m_numRxScanlines = parameters.getNumRxScanlines();
+		m_rxScanlineLayout = parameters.getRxScanlineLayout();
+
+		m_is3D = (m_rxScanlineLayout.x > 1 && m_rxScanlineLayout.y > 1);
+		m_speedOfSoundMMperS = parameters.getSpeedOfSoundMMperS();
+		m_rxNumDepths = parameters.getRxNumDepths();
+
+		// create and fill new buffers
+		m_pRxDepths = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationGpu, &q_ct1, parameters.getRxDepths()));
+
+		m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D>>(new Container<ScanlineRxParameters3D>(LocationGpu, &q_ct1, parameters.getRxScanlines()));
+
+		m_pRxElementXs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationGpu, &q_ct1, parameters.getRxElementXs()));
+		m_pRxElementYs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationGpu, &q_ct1, parameters.getRxElementYs()));
+	}
+
+	RxBeamformerCuda::~RxBeamformerCuda()
+	{
+	}
+
+	void RxBeamformerCuda::convertToDtSpace(double dt, double speedOfSoundMMperS, size_t numTransducerElements) const
+	{
+		if (m_lastSeenDt != dt || m_speedOfSoundMMperS != speedOfSoundMMperS)
+		{
+			double oldFactor = 1;
+			double oldFactorTime = 1;
+			if (m_lastSeenDt != 0 && m_speedOfSoundMMperS != 0)
+			{
+				oldFactor = 1 / (m_speedOfSoundMMperS * m_lastSeenDt);
+				oldFactorTime = 1 / m_lastSeenDt;
+			}
+
+			double factor = 1 / oldFactor / (speedOfSoundMMperS * dt);
+			double factorTime = 1 / oldFactorTime / dt;
+
+			m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D> >(new Container<ScanlineRxParameters3D>(LocationHost, *m_pRxScanlines));
+			for (size_t i = 0; i < m_numRxScanlines; i++)
+			{
+				ScanlineRxParameters3D p = m_pRxScanlines->get()[i];
+				p.position = p.position*factor;
+				for (size_t k = 0; k < std::extent<decltype(p.txWeights)>::value; k++)
+				{
+					p.txParameters[k].initialDelay *= factorTime;
+				}
+				p.maxElementDistance = p.maxElementDistance*factor;
+				m_pRxScanlines->get()[i] = p;
+			}
+			m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D> >(new Container<ScanlineRxParameters3D>(LocationGpu, *m_pRxScanlines));
+
+			m_pRxDepths = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationHost, *m_pRxDepths));
+			for (size_t i = 0; i < m_rxNumDepths; i++)
+			{
+				m_pRxDepths->get()[i] = static_cast<LocationType>(m_pRxDepths->get()[i] * factor);
+			}
+			m_pRxDepths = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationGpu, *m_pRxDepths));
+
+			m_pRxElementXs = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationHost, *m_pRxElementXs));
+			m_pRxElementYs = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationHost, *m_pRxElementYs));
+			for (size_t i = 0; i < numTransducerElements; i++)
+			{
+				m_pRxElementXs->get()[i] = static_cast<LocationType>(m_pRxElementXs->get()[i] * factor);
+				m_pRxElementYs->get()[i] = static_cast<LocationType>(m_pRxElementYs->get()[i] * factor);
+			}
+			m_pRxElementXs = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationGpu, *m_pRxElementXs));
+			m_pRxElementYs = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationGpu, *m_pRxElementYs));
+
+			m_lastSeenDt = dt;
+			m_speedOfSoundMMperS = speedOfSoundMMperS;
+		}
+	}
+
+	template <class SampleBeamformer, bool interpolateRFlines, bool interpolateBetweenTransmits, unsigned int maxNumElements, unsigned int maxNumFunctionElements, typename RFType, typename ResultType, typename LocationType>
+	
+		void rxBeamformingDTSPACE3DKernel(
+			uint32_t numTransducerElements,
+			vec2T<uint32_t> elementLayout,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const RFType* __restrict__ RF,
+			uint32_t numTxScanlines,
+			uint32_t numRxScanlines,
+			const ScanlineRxParameters3D* __restrict__ scanlinesDT,
+			uint32_t numDs,
+			const LocationType* __restrict__ dsDT,
+			const LocationType* __restrict__ x_elemsDT,
+			const LocationType* __restrict__ z_elemsDT,
+			LocationType speedOfSound,
+			LocationType dt,
+			uint32_t additionalOffset,
+			LocationType F,
+			const WindowFunctionGpu windowFunction,
+			ResultType* __restrict__ s,
+			sycl::nd_item<3> item_ct1,
+			LocationType *x_elemsDTsh,
+			LocationType *z_elemsDTsh,
+			WindowFunction::ElementType *functionShared)
+	{
+
+		//fetch element positions to shared memory
+		for (int threadId = (item_ct1.get_local_id(1) * item_ct1.get_local_range().get(2)) + item_ct1.get_local_id(2);	//@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+			 threadId < maxNumElements && threadId < numTransducerElements;
+			 threadId += item_ct1.get_local_range().get(2) * item_ct1.get_local_range().get(1))	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		{
+			x_elemsDTsh[threadId] = x_elemsDT[threadId];
+			z_elemsDTsh[threadId] = z_elemsDT[threadId];
+		}
+		for (int threadId = (item_ct1.get_local_id(1) * item_ct1.get_local_range().get(2)) + item_ct1.get_local_id(2);	//@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+			 threadId < maxNumFunctionElements && threadId < windowFunction.numElements();
+			 threadId += item_ct1.get_local_range().get(2) * item_ct1.get_local_range().get(1))	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		{
+			functionShared[threadId] = windowFunction.getDirect(threadId);
+		}
+		item_ct1.barrier();	 //@suppress("Function cannot be resolved")
+
+		int r = item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1);			 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		int scanlineIdx = item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2);	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+
+		if (r < numDs && scanlineIdx < numRxScanlines)
+		{
+			LocationType d = dsDT[r];
+			//TODO should this also depend on the angle?
+			LocationType aDT = squ(computeAperture_D(F, d*dt*speedOfSound) / speedOfSound / dt);
+			ScanlineRxParameters3D scanline = scanlinesDT[scanlineIdx];
+
+			LocationType scanline_x = scanline.position.x;
+			LocationType scanline_z = scanline.position.z;
+			LocationType dirX = scanline.direction.x;
+			LocationType dirY = scanline.direction.y;
+			LocationType dirZ = scanline.direction.z;
+			vec2f maxElementDistance = static_cast<vec2f>(scanline.maxElementDistance);
+			vec2f		 invMaxElementDistance = vec2f{ 1.0f, 1.0f } / min(vec2f{ sycl::sqrt(aDT), sycl::sqrt(aDT) }, maxElementDistance);
+
+			float sInterp = 0.0f;
+
+			int highestWeightIndex;
+			if (!interpolateBetweenTransmits)
+			{
+				highestWeightIndex = 0;
+				float highestWeight = scanline.txWeights[0];
+				for (int k = 1; k < std::extent<decltype(scanline.txWeights)>::value; k++)
+				{
+					if (scanline.txWeights[k] > highestWeight)
+					{
+						highestWeight = scanline.txWeights[k];
+						highestWeightIndex = k;
+					}
+				}
+			}
+
+			// now iterate over all four txScanlines to interpolate beamformed scanlines from those transmits
+			for (int k = (interpolateBetweenTransmits ? 0 : highestWeightIndex);
+				(interpolateBetweenTransmits && k < std::extent<decltype(scanline.txWeights)>::value) ||
+				(!interpolateBetweenTransmits && k == highestWeightIndex);
+				k++)
+			{
+				if (scanline.txWeights[k] > 0.0)
+				{
+					ScanlineRxParameters3D::TransmitParameters txParams = scanline.txParameters[k];
+					uint32_t txScanlineIdx = txParams.txScanlineIdx;
+					if (txScanlineIdx >= numTxScanlines)
+					{
+						//ERROR!
+						return;
+					}
+					float sLocal = 0.0f;
+					
+					sLocal = SampleBeamformer::template sampleBeamform3D<interpolateRFlines, RFType, float, LocationType>(
+						txParams, RF, elementLayout, numReceivedChannels, numTimesteps,
+						x_elemsDTsh, z_elemsDTsh, scanline_x, scanline_z, dirX, dirY, dirZ,
+						aDT, d, invMaxElementDistance, speedOfSound, dt, additionalOffset, &windowFunction, functionShared);
+
+					if (interpolateBetweenTransmits)
+					{
+						sInterp += static_cast<float>(scanline.txWeights[k])* sLocal;
+					}
+					else
+					{
+						sInterp += sLocal;
+					}
+				}
+			}
+			s[scanlineIdx + r * numRxScanlines] = clampCast<ResultType>(sInterp);
+		}
+	}
+
+	template <class SampleBeamformer, bool interpolateRFlines, bool interpolateBetweenTransmits, typename RFType, typename ResultType, typename LocationType>
+	
+		void rxBeamformingDTSPACEKernel(
+			size_t numTransducerElements,
+			size_t numReceivedChannels,
+			size_t numTimesteps,
+			const RFType* __restrict__ RF,
+			size_t numTxScanlines,
+			size_t numRxScanlines,
+			const ScanlineRxParameters3D* __restrict__ scanlinesDT,
+			size_t numDs,
+			const LocationType* __restrict__ dsDT,
+			const LocationType* __restrict__ x_elemsDT,
+			LocationType speedOfSound,
+			LocationType dt,
+			uint32_t additionalOffset,
+			LocationType F,
+			const WindowFunctionGpu windowFunction,
+			ResultType* __restrict__ s,
+			sycl::nd_item<3> item_ct1)
+	{
+		int r = item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1);			 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		int scanlineIdx = item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2);	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		if (r < numDs && scanlineIdx < numRxScanlines)
+		{
+			LocationType d = dsDT[r];
+			//TODO should this also depend on the angle?
+			LocationType aDT = computeAperture_D(F, d*dt*speedOfSound) / speedOfSound / dt;
+			ScanlineRxParameters3D scanline = scanlinesDT[scanlineIdx];
+			LocationType scanline_x = scanline.position.x;
+			LocationType dirX = scanline.direction.x;
+			LocationType dirY = scanline.direction.y;
+			LocationType dirZ = scanline.direction.z;
+			LocationType maxElementDistance = static_cast<LocationType>(scanline.maxElementDistance.x);
+			LocationType		   invMaxElementDistance = 1 / sycl::min(aDT, maxElementDistance);
+
+			float sInterp = 0.0f;
+
+			int highestWeightIndex;
+			if (!interpolateBetweenTransmits)
+			{
+				highestWeightIndex = 0;
+				float highestWeight = scanline.txWeights[0];
+				for (int k = 1; k < std::extent<decltype(scanline.txWeights)>::value; k++)
+				{
+					if (scanline.txWeights[k] > highestWeight)
+					{
+						highestWeight = scanline.txWeights[k];
+						highestWeightIndex = k;
+					}
+				}
+			}
+
+			// now iterate over all four txScanlines to interpolate beamformed scanlines from those transmits
+			for (int k = (interpolateBetweenTransmits ? 0 : highestWeightIndex);
+				(interpolateBetweenTransmits && k < std::extent<decltype(scanline.txWeights)>::value) ||
+				(!interpolateBetweenTransmits && k == highestWeightIndex);
+				k++)
+			{
+				if (scanline.txWeights[k] > 0.0)
+				{
+					ScanlineRxParameters3D::TransmitParameters txParams = scanline.txParameters[k];
+					uint32_t txScanlineIdx = txParams.txScanlineIdx;
+					if (txScanlineIdx >= numTxScanlines)
+					{
+						//ERROR!
+						return;
+					}
+
+					float sLocal = 0.0f;
+					sLocal = SampleBeamformer::template sampleBeamform2D<interpolateRFlines, RFType, float, LocationType>(
+						txParams, RF, numTransducerElements, numReceivedChannels, numTimesteps,
+						x_elemsDT, scanline_x, dirX, dirY, dirZ,
+						aDT, d, invMaxElementDistance, speedOfSound, dt, additionalOffset, &windowFunction);
+
+					if (interpolateBetweenTransmits)
+					{
+						sInterp += static_cast<float>(scanline.txWeights[k])* sLocal;
+					}
+					else
+					{
+						sInterp += sLocal;
+					}
+				}
+			}
+			s[scanlineIdx + r * numRxScanlines] = clampCast<ResultType>(sInterp);
+		}
+	}
+
+	template <class SampleBeamformer, unsigned int maxWindowFunctionNumel, typename RFType, typename ResultType, typename LocationType>
+	void rxBeamformingDTspaceCuda3D(bool interpolateRFlines, bool interpolateBetweenTransmits, size_t numTransducerElements, vec2s elementLayout, size_t numReceivedChannels, size_t numTimesteps,
+									const RFType* RF, size_t numTxScanlines, size_t numRxScanlines, const ScanlineRxParameters3D* scanlines, size_t numZs, const LocationType* zs,
+									const LocationType* x_elems, const LocationType* y_elems, LocationType speedOfSound, LocationType dt, uint32_t additionalOffset, LocationType F,
+									const WindowFunctionGpu windowFunction, sycl::queue* stream, ResultType* s)
+	{
+		sycl::range<3> blockSize(1, 256, 1);
+		sycl::range<3> gridSize(1, static_cast<unsigned int>((numZs + blockSize[ 1 ] - 1) / blockSize[ 1 ]), static_cast<unsigned int>((numRxScanlines + blockSize[ 2 ] - 1) / blockSize[ 2 ]));
+
+		if (interpolateRFlines)
+		{
+			if (interpolateBetweenTransmits)
+			{
+				/*
+				DPCT1049:32: The workgroup size passed to the SYCL kernel may exceed the limit. To get the device limit, query info::device::max_work_group_size. Adjust the workgroup size if needed.
+				*/
+						stream->submit([ & ](sycl::handler& cgh) {
+							  sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>				  x_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+							  sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>				  z_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+							  sycl::accessor<WindowFunction::ElementType, 1, sycl::access::mode::read_write, sycl::access::target::local> functionShared_acc_ct1(sycl::range<1>(maxWindowFunctionNumel),
+																																								 cgh);
+
+							  cgh.parallel_for(sycl::nd_range<3>(gridSize * blockSize, blockSize), [ = ](sycl::nd_item<3> item_ct1) {
+									rxBeamformingDTSPACE3DKernel<SampleBeamformer, true, true, 1024, maxWindowFunctionNumel>(
+										( uint32_t )numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout), ( uint32_t )numReceivedChannels, ( uint32_t )numTimesteps, RF,
+										( uint32_t )numTxScanlines, ( uint32_t )numRxScanlines, scanlines, ( uint32_t )numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F,
+										windowFunction, s, item_ct1, ( LocationType* )x_elemsDTsh_acc_ct1.get_pointer(), ( LocationType* )z_elemsDTsh_acc_ct1.get_pointer(),
+										functionShared_acc_ct1.get_pointer());
+							  });
+						});
+			}
+			else {
+				/*
+				DPCT1049:33: The workgroup size passed to the SYCL kernel may exceed the limit. To get the device limit, query info::device::max_work_group_size. Adjust the workgroup size if needed.
+				*/
+						stream->submit([ & ](sycl::handler& cgh) {
+							  sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>				  x_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+							  sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>				  z_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+							  sycl::accessor<WindowFunction::ElementType, 1, sycl::access::mode::read_write, sycl::access::target::local> functionShared_acc_ct1(sycl::range<1>(maxWindowFunctionNumel),
+																																								 cgh);
+
+							  cgh.parallel_for(sycl::nd_range<3>(gridSize * blockSize, blockSize), [ = ](sycl::nd_item<3> item_ct1) {
+									rxBeamformingDTSPACE3DKernel<SampleBeamformer, true, false, 1024, maxWindowFunctionNumel>(
+										( uint32_t )numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout), ( uint32_t )numReceivedChannels, ( uint32_t )numTimesteps, RF,
+										( uint32_t )numTxScanlines, ( uint32_t )numRxScanlines, scanlines, ( uint32_t )numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F,
+										windowFunction, s, item_ct1, ( LocationType* )x_elemsDTsh_acc_ct1.get_pointer(), ( LocationType* )z_elemsDTsh_acc_ct1.get_pointer(),
+										functionShared_acc_ct1.get_pointer());
+							  });
+						});
+			}
+		}
+		else {
+			if (interpolateBetweenTransmits)
+			{
+				/*
+				DPCT1049:34: The workgroup size passed to the SYCL kernel may exceed the limit. To get the device limit, query info::device::max_work_group_size. Adjust the workgroup size if needed.
+				*/
+						stream->submit([ & ](sycl::handler& cgh) {
+							  sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>				  x_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+							  sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>				  z_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+							  sycl::accessor<WindowFunction::ElementType, 1, sycl::access::mode::read_write, sycl::access::target::local> functionShared_acc_ct1(sycl::range<1>(maxWindowFunctionNumel),
+																																								 cgh);
+
+							  cgh.parallel_for(sycl::nd_range<3>(gridSize * blockSize, blockSize), [ = ](sycl::nd_item<3> item_ct1) {
+									rxBeamformingDTSPACE3DKernel<SampleBeamformer, false, true, 1024, maxWindowFunctionNumel>(
+										( uint32_t )numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout), ( uint32_t )numReceivedChannels, ( uint32_t )numTimesteps, RF,
+										( uint32_t )numTxScanlines, ( uint32_t )numRxScanlines, scanlines, ( uint32_t )numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F,
+										windowFunction, s, item_ct1, ( LocationType* )x_elemsDTsh_acc_ct1.get_pointer(), ( LocationType* )z_elemsDTsh_acc_ct1.get_pointer(),
+										functionShared_acc_ct1.get_pointer());
+							  });
+						});
+			}
+			else {
+				/*
+				DPCT1049:35: The workgroup size passed to the SYCL kernel may exceed the limit. To get the device limit, query info::device::max_work_group_size. Adjust the workgroup size if needed.
+				*/
+						stream->submit([ & ](sycl::handler& cgh) {
+							  sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>				  x_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+							  sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>				  z_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+							  sycl::accessor<WindowFunction::ElementType, 1, sycl::access::mode::read_write, sycl::access::target::local> functionShared_acc_ct1(sycl::range<1>(maxWindowFunctionNumel),
+																																								 cgh);
+
+							  cgh.parallel_for(sycl::nd_range<3>(gridSize * blockSize, blockSize), [ = ](sycl::nd_item<3> item_ct1) {
+									rxBeamformingDTSPACE3DKernel<SampleBeamformer, false, false, 1024, maxWindowFunctionNumel>(
+										( uint32_t )numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout), ( uint32_t )numReceivedChannels, ( uint32_t )numTimesteps, RF,
+										( uint32_t )numTxScanlines, ( uint32_t )numRxScanlines, scanlines, ( uint32_t )numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F,
+										windowFunction, s, item_ct1, ( LocationType* )x_elemsDTsh_acc_ct1.get_pointer(), ( LocationType* )z_elemsDTsh_acc_ct1.get_pointer(),
+										functionShared_acc_ct1.get_pointer());
+							  });
+						});
+			}
+		}
+		/*
+		DPCT1010:36: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+	}
+
+	template <class SampleBeamformer, typename RFType, typename ResultType, typename LocationType>
+	void rxBeamformingDTspaceCuda(bool interpolateRFlines, bool interpolateBetweenTransmits, size_t numTransducerElements, size_t numReceivedChannels, size_t numTimesteps, const RFType* RF,
+								  size_t numTxScanlines, size_t numRxScanlines, const ScanlineRxParameters3D* scanlines, size_t numZs, const LocationType* zs, const LocationType* x_elems,
+								  LocationType speedOfSound, LocationType dt, uint32_t additionalOffset, LocationType F, const WindowFunctionGpu windowFunction, sycl::queue* stream, ResultType* s)
+	{
+		sycl::range<3> blockSize(1, 256, 1);
+		sycl::range<3> gridSize(1, static_cast<unsigned int>((numZs + blockSize[ 1 ] - 1) / blockSize[ 1 ]), static_cast<unsigned int>((numRxScanlines + blockSize[ 2 ] - 1) / blockSize[ 2 ]));
+		if (interpolateRFlines)
+		{
+			if (interpolateBetweenTransmits)
+			{
+				/*
+				DPCT1049:37: The workgroup size passed to the SYCL kernel may exceed the limit. To get the device limit, query info::device::max_work_group_size. Adjust the workgroup size if needed.
+				*/
+						stream->submit([ & ](sycl::handler& cgh) {
+							  cgh.parallel_for(sycl::nd_range<3>(gridSize * blockSize, blockSize), [ = ](sycl::nd_item<3> item_ct1) {
+									rxBeamformingDTSPACEKernel<SampleBeamformer, true, true>(numTransducerElements, numReceivedChannels, numTimesteps, RF, numTxScanlines, numRxScanlines, scanlines,
+																							 numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s, item_ct1);
+							  });
+						});
+			}
+			else {
+				/*
+				DPCT1049:38: The workgroup size passed to the SYCL kernel may exceed the limit. To get the device limit, query info::device::max_work_group_size. Adjust the workgroup size if needed.
+				*/
+						stream->submit([ & ](sycl::handler& cgh) {
+							  cgh.parallel_for(sycl::nd_range<3>(gridSize * blockSize, blockSize), [ = ](sycl::nd_item<3> item_ct1) {
+									rxBeamformingDTSPACEKernel<SampleBeamformer, true, false>(numTransducerElements, numReceivedChannels, numTimesteps, RF, numTxScanlines, numRxScanlines, scanlines,
+																							  numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s, item_ct1);
+							  });
+						});
+			}
+		}
+		else {
+			if (interpolateBetweenTransmits)
+			{
+				/*
+				DPCT1049:39: The workgroup size passed to the SYCL kernel may exceed the limit. To get the device limit, query info::device::max_work_group_size. Adjust the workgroup size if needed.
+				*/
+						stream->submit([ & ](sycl::handler& cgh) {
+							  cgh.parallel_for(sycl::nd_range<3>(gridSize * blockSize, blockSize), [ = ](sycl::nd_item<3> item_ct1) {
+									rxBeamformingDTSPACEKernel<SampleBeamformer, false, true>(numTransducerElements, numReceivedChannels, numTimesteps, RF, numTxScanlines, numRxScanlines, scanlines,
+																							  numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s, item_ct1);
+							  });
+						});
+			}
+			else {
+				/*
+				DPCT1049:40: The workgroup size passed to the SYCL kernel may exceed the limit. To get the device limit, query info::device::max_work_group_size. Adjust the workgroup size if needed.
+				*/
+						stream->submit([ & ](sycl::handler& cgh) {
+							  cgh.parallel_for(sycl::nd_range<3>(gridSize * blockSize, blockSize), [ = ](sycl::nd_item<3> item_ct1) {
+									rxBeamformingDTSPACEKernel<SampleBeamformer, false, false>(numTransducerElements, numReceivedChannels, numTimesteps, RF, numTxScanlines, numRxScanlines, scanlines,
+																							   numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s, item_ct1);
+							  });
+						});
+			}
+		}
+		/*
+		DPCT1010:41: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+	}
+
+	template <typename ChannelDataType, typename ImageDataType>
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const
+	{
+		//Ensure the raw-data are on the gpu
+		auto gRawData = rawData->getData<ChannelDataType>();
+		if (!gRawData->isGPU() && !gRawData->isBoth())
+		{
+			gRawData = std::make_shared<Container<ChannelDataType> >(LocationGpu, *gRawData);
+		}
+
+		size_t numelOut = m_numRxScanlines*m_rxNumDepths;
+		shared_ptr<Container<ImageDataType> > pData = std::make_shared<Container<ImageDataType> >(ContainerLocation::LocationGpu, gRawData->getStream(), numelOut);
+
+		double dt = 1.0 / rawData->getSamplingFrequency();
+
+		if (!m_windowFunction || m_windowFunction->getType() != windowType || m_windowFunction->getParameter() != windowParameter)
+		{
+			m_windowFunction = std::unique_ptr<WindowFunction>(new WindowFunction(windowType, windowParameter, m_windowFunctionNumEntries));
+		}
+
+		auto beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndSum, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+		auto beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndSum, ChannelDataType, ImageDataType, LocationType>;
+		switch (sampleBeamformer)
+		{
+		case DelayAndSum:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndSum, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndSum, ChannelDataType, ImageDataType, LocationType>;
+			break;
+		case DelayAndStdDev:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndStdDev, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndStdDev, ChannelDataType, ImageDataType, LocationType>;
+			break;
+		case TestSignal:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerTestSignal, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerTestSignal, ChannelDataType, ImageDataType, LocationType>;
+			break;
+		case INVALID:
+		default:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndSum, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndSum, ChannelDataType, ImageDataType, LocationType>;
+		}
+
+
+		convertToDtSpace(dt, speedOfSoundMMperS, rawData->getNumElements());
+		if (m_is3D)
+		{
+			beamformingFunction3D(
+				true,
+				interpolateBetweenTransmits,
+				rawData->getNumElements(),
+				rawData->getElementLayout(),
+				rawData->getNumReceivedChannels(),
+				rawData->getNumSamples(),
+				gRawData->get(),
+				rawData->getNumScanlines(), // numTxScanlines
+				m_numRxScanlines,			// numRxScanlines
+				m_pRxScanlines->get(),
+				m_rxNumDepths, m_pRxDepths->get(),
+				m_pRxElementXs->get(),
+				m_pRxElementYs->get(),
+				static_cast<LocationType>(m_speedOfSoundMMperS),
+				static_cast<LocationType>(dt),
+				additionalOffset,
+				static_cast<LocationType>(fNumber),
+				*(m_windowFunction->getGpu()),
+				gRawData->getStream(),
+				pData->get()
+				);
+		}
+		else {
+			beamformingFunction2D(
+				true,
+				interpolateBetweenTransmits,
+				rawData->getNumElements(),
+				rawData->getNumReceivedChannels(),
+				rawData->getNumSamples(),
+				gRawData->get(),
+				rawData->getNumScanlines(), // numTxScanlines
+				m_numRxScanlines,			// numRxScanlines
+				m_pRxScanlines->get(),
+				m_rxNumDepths, m_pRxDepths->get(),
+				m_pRxElementXs->get(),
+				static_cast<LocationType>(m_speedOfSoundMMperS),
+				static_cast<LocationType>(dt),
+				additionalOffset,
+				static_cast<LocationType>(fNumber),
+				*(m_windowFunction->getGpu()),
+				gRawData->getStream(),
+				pData->get()
+				);
+		}
+
+		if (rawData->getImageProperties() != m_lastSeenImageProperties)
+		{
+			m_lastSeenImageProperties = rawData->getImageProperties();
+			shared_ptr<USImageProperties> newProps = std::make_shared<USImageProperties>(*m_lastSeenImageProperties);
+			newProps->setScanlineLayout(m_rxScanlineLayout);
+			newProps->setNumSamples(m_rxNumDepths);
+			newProps->setImageState(USImageProperties::RF);
+			m_editedImageProperties = std::const_pointer_cast<const USImageProperties>(newProps);
+		}
+
+		auto retImage = std::make_shared<USImage>(
+			vec2s{ m_numRxScanlines, m_rxNumDepths },
+			pData,
+			m_editedImageProperties,
+			rawData->getReceiveTimestamp(),
+			rawData->getSyncTimestamp());
+
+		return retImage;
+	}
+
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<int16_t, int16_t>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<int16_t, float>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<float, int16_t>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<float, float>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+}
\ No newline at end of file
diff --git a/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h b/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h
index e6e0e61..d72079d 100644
--- a/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h
+++ b/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h
@@ -12,6 +12,8 @@
 #ifndef __RXSAMPLEBEAMFORMERDELAYANDSTDDEV_H__
 #define __RXSAMPLEBEAMFORMERDELAYANDSTDDEV_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include "USImageProperties.h"
 #include "WindowFunction.h"
 #include "RxBeamformerCommon.h"
@@ -34,7 +36,7 @@ namespace supra
 	{
 	public:
 		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
-		static __device__ ResultType sampleBeamform3D(
+		static ResultType sampleBeamform3D(
 			ScanlineRxParameters3D::TransmitParameters txParams,
 			const RFType* RF,
 			vec2T<uint32_t> elementLayout,
@@ -134,7 +136,7 @@ namespace supra
 			}
 			if (numAdds > 0)
 			{
-				return sqrt(sd) / weightAcum * numAdds;
+				return sycl::sqrt(sd) / weightAcum * numAdds;
 			}
 			else
 			{
@@ -143,7 +145,7 @@ namespace supra
 		}
 
 		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
-		static __device__ ResultType sampleBeamform2D(
+		static ResultType sampleBeamform2D(
 			ScanlineRxParameters3D::TransmitParameters txParams,
 			const RFType* RF,
 			uint32_t numTransducerElements,
@@ -230,7 +232,7 @@ namespace supra
 			}
 			if (numAdds > 0)
 			{
-				return sqrt(sd) / weightAcum * numAdds;
+				return sycl::sqrt(sd) / weightAcum * numAdds;
 			}
 			else
 			{
diff --git a/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h b/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h
index 6547d6d..0684605 100644
--- a/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h
+++ b/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h
@@ -12,6 +12,8 @@
 #ifndef __RXSAMPLEBEAMFORMERDELAYANDSUM_H__
 #define __RXSAMPLEBEAMFORMERDELAYANDSUM_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include "USImageProperties.h"
 #include "WindowFunction.h"
 #include "RxBeamformerCommon.h"
@@ -23,7 +25,7 @@ namespace supra
 	{
 	public:
 		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
-		static __device__ ResultType sampleBeamform3D(
+		static ResultType sampleBeamform3D(
 			ScanlineRxParameters3D::TransmitParameters txParams,
 			const RFType* RF,
 			vec2T<uint32_t> elementLayout,
@@ -106,7 +108,7 @@ namespace supra
 		}
 
 		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
-		static __device__ ResultType sampleBeamform2D(
+		static ResultType sampleBeamform2D(
 			ScanlineRxParameters3D::TransmitParameters txParams,
 			const RFType* RF,
 			uint32_t numTransducerElements,
diff --git a/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h b/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h
index 9d131a9..9b44dc3 100644
--- a/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h
+++ b/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h
@@ -12,6 +12,8 @@
 #ifndef __RXSAMPLEBEAMFORMERTESTSIGNAL_H__
 #define __RXSAMPLEBEAMFORMERTESTSIGNAL_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include "USImageProperties.h"
 #include "WindowFunction.h"
 #include "RxBeamformerCommon.h"
@@ -23,7 +25,7 @@ namespace supra
 	{
 	public:
 		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
-		static __device__ ResultType sampleBeamform3D(
+		static ResultType sampleBeamform3D(
 			ScanlineRxParameters3D::TransmitParameters txParams,
 			const RFType* RF,
 			vec2T<uint32_t> elementLayout,
@@ -85,7 +87,7 @@ namespace supra
 		}
 
 		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
-		static __device__ ResultType sampleBeamform2D(
+		static ResultType sampleBeamform2D(
 			ScanlineRxParameters3D::TransmitParameters txParams,
 			const RFType* RF,
 			uint32_t numTransducerElements,
diff --git a/src/SupraLib/Beamformer/ScanConverter.dp.cpp b/src/SupraLib/Beamformer/ScanConverter.dp.cpp
new file mode 100644
index 0000000..fd49274
--- /dev/null
+++ b/src/SupraLib/Beamformer/ScanConverter.dp.cpp
@@ -0,0 +1,937 @@
+// ================================================================================================
+// 
+// Copyright (C) 2016, Rüdiger Göbl - all rights reserved
+// Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.
+//
+//          Rüdiger Göbl
+//          Email r.goebl@tum.de
+//          Chair for Computer Aided Medical Procedures
+//          Technische Universität München
+//          Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License, version 2.1, as published by the Free Software Foundation.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this program.  If not, see
+// <http://www.gnu.org/licenses/>.
+//
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "ScanConverter.h"
+#include <cassert>
+#include <utilities/cudaUtility.h>
+#include <utilities/Logging.h>
+
+#include <dpct/dpl_utils.hpp>
+#include <oneapi/dpl/execution>
+#include <oneapi/dpl/algorithm>
+#include <cmath>
+
+using namespace std;
+
+namespace supra
+{
+	class ScanConverterInternals {
+	public:
+		typedef ScanConverter::IndexType IndexType;
+		typedef ScanConverter::WeightType WeightType;
+
+		static constexpr double m_tetrahedronTestDistanceThreshold = 1e-9;
+		static constexpr int m_mappingMaxIterations = ScanConverter::m_mappingMaxIterations;
+		static constexpr double m_mappingDistanceThreshold = ScanConverter::m_mappingDistanceThreshold;
+
+		template <typename Tf, typename Ti>
+		static void computeParametersVoxel3D(
+			const Tf &sampleDistance,
+			const vec2T<Ti> &scanlineLayout,
+			const int &scanlineIdxX,
+			const int &scanlineIdxY,
+			const vec3T<Tf> &s1,
+			const vec3T<Tf> &e1,
+			const vec3T<Tf> &s2,
+			const vec3T<Tf> &e2,
+			const vec3T<Tf> &s3,
+			const vec3T<Tf> &e3,
+			const vec3T<Tf> &s4,
+			const vec3T<Tf> &e4,
+			const vec3T<Tf> &scanline1Pos,
+			const vec3T<Tf> &scanline1Dir,
+			const vec3T<Tf> &scanline2Pos,
+			const vec3T<Tf> &scanline2Dir,
+			const vec3T<Tf> &scanline3Pos,
+			const vec3T<Tf> &scanline3Dir,
+			const vec3T<Tf> &scanline4Pos,
+			const vec3T<Tf> &scanline4Dir,
+			const Tf &startDepth,
+			const Tf &endDepth,
+			const vec3T<Ti> &imageSize,
+			const vec3T<Ti> &voxel,
+			const vec3T<Tf> &voxelPos,
+			uint8_t* __restrict__ maskBuf,
+			uint32_t* __restrict__ sampleIdxBuf,
+			float* __restrict__ weightXBuf,
+			float* __restrict__ weightYBuf,
+			float* __restrict__ weightZBuf
+		)
+		{
+			if (pointInsideTetrahedron(s1, s2, s3, e1, voxelPos) ||
+				pointInsideTetrahedron(s2, s4, s3, e4, voxelPos) ||
+				pointInsideTetrahedron(s2, e1, e2, e4, voxelPos) ||
+				pointInsideTetrahedron(s3, e3, e1, e4, voxelPos) ||
+				pointInsideTetrahedron(s2, s3, e1, e4, voxelPos))
+			{
+
+				thrust::pair<vec3T<Tf>, bool> params = mapToParameters3D<Tf, Ti>(
+					scanline1Pos,
+					scanline2Pos,
+					scanline3Pos,
+					scanline4Pos,
+					scanline1Dir,
+					scanline2Dir,
+					scanline3Dir,
+					scanline4Dir,
+					startDepth, endDepth, voxelPos);
+
+				if (params.second)
+				{
+					size_t voxelIndex = voxel.x + voxel.y*imageSize.x + voxel.z*imageSize.x*imageSize.y;
+					maskBuf[voxelIndex] = 1;
+
+					Tf t1 = params.first.x;
+					Tf t2 = params.first.y;
+					Tf d = params.first.z + 0;
+
+					IndexType  sampleIdxScanline = static_cast<IndexType>(sycl::floor(d / sampleDistance));
+					WeightType weightY = static_cast<WeightType>(d / sampleDistance - sampleIdxScanline);
+					WeightType weightX = static_cast<WeightType>(t1);
+					WeightType weightZ = static_cast<WeightType>(t2);
+
+					IndexType sampleIdx = static_cast<IndexType>(sampleIdxScanline*scanlineLayout.x*scanlineLayout.y +
+						scanlineIdxX + scanlineIdxY*scanlineLayout.x);
+
+					sampleIdxBuf[voxelIndex] = sampleIdx;
+					weightXBuf[voxelIndex] = weightX;
+					weightYBuf[voxelIndex] = weightY;
+					weightZBuf[voxelIndex] = weightZ;
+				}
+			}
+		}
+
+		/**
+		 * Tests whether point p lies within the tetrahedron defined by a, b, c, d.
+		 *
+		 * For the test, the barycentric coordinates of p are computed and checked for equal sign.
+		 */
+		template <typename Tf>
+		static bool pointInsideTetrahedron(const vec3T<Tf> & a, const vec3T<Tf> & b, const vec3T<Tf> & c, const vec3T<Tf> & d, const vec3T<Tf> & p)
+		{
+			Tf w0 = barycentricCoordinate3D(a, b, c, d);
+
+			Tf w1 = barycentricCoordinate3D(p, b, c, d);
+			Tf w2 = barycentricCoordinate3D(a, p, c, d);
+			Tf w3 = barycentricCoordinate3D(a, b, p, d);
+			Tf w4 = barycentricCoordinate3D(a, b, c, p);
+
+			return w0 > 0 &&
+				w1 >= -m_tetrahedronTestDistanceThreshold &&
+				w2 >= -m_tetrahedronTestDistanceThreshold &&
+				w3 >= -m_tetrahedronTestDistanceThreshold &&
+				w4 >= -m_tetrahedronTestDistanceThreshold;
+		}
+
+		template <typename Tf>
+		static Tf barycentricCoordinate3D(const vec3T<Tf> & a, const vec3T<Tf> & b, const vec3T<Tf> & c, const vec3T<Tf> & p)
+		{
+			//computes the determinant of 
+			//[a_x, a_y, a_z, 1]
+			//[b_x, b_y, b_z, 1]
+			//[c_x, c_y, c_z, 1]
+			//[p_x, p_y, p_z, 1]
+
+			// reducing 12 multiplications per compute
+			const Tf axby = a.x*b.y;
+			const Tf cypz = c.y*p.z;
+			const Tf axbz = a.x*b.z;
+			const Tf czpy = c.z*p.y;
+			const Tf aybx = a.y*b.x;
+			const Tf cxpz = c.x*p.z;
+			const Tf aybz = a.y*b.z;
+			const Tf czpx = c.z*p.x;
+			const Tf azbx = a.z*b.x;
+			const Tf cxpy = c.x*p.y;
+			const Tf azby = a.z*b.y;
+			const Tf cypx = c.y*p.x;
+
+			return 
+				(axby-aybx)*(c.z-p.z) + (aybz-azby)*(c.x-p.x) +
+				(azbx-axbz)*(c.y-p.y) + (cypz-czpy)*(a.x-b.x) -
+				(cxpz-czpx)*(a.y-b.y) + (cxpy-cypx)*(a.z-b.z);
+			// reducing 18 multiplications with the updated return statement per compute 			
+		}
+
+		template <typename Tf>
+		static vec3T<Tf> pointPlaneConnection(const vec3T<Tf> & a, const vec3T<Tf> & na, const vec3T<Tf> & x)
+		{
+			return dot(na, (x - a))*na;
+		}
+
+		template <typename Tf, typename Ti>
+		static thrust::pair<vec3T<Tf>, bool> mapToParameters3D(
+			const vec3T<Tf> & a,
+			const vec3T<Tf> & ax,
+			const vec3T<Tf> & ay,
+			const vec3T<Tf> & axy,
+			const vec3T<Tf> & da,
+			const vec3T<Tf> & dax,
+			const vec3T<Tf> & day,
+			const vec3T<Tf> & daxy,
+			Tf startDepth,
+			Tf endDepth,
+			const vec3T<Tf> & x)
+		{
+			vec3T<Tf> normalXLow = normalize(cross(da, (ay + day) - a));
+			vec3T<Tf> normalYLow = normalize(cross((ax + dax) - a, da));
+			vec3T<Tf> normalXHigh = normalize(cross(dax, (axy + daxy) - ax));
+			vec3T<Tf> normalYHigh = normalize(cross((axy + daxy) - ay, day));
+
+			//find t via binary search
+			vec2T<Tf> lowT = { 0, 0 };
+			vec2T<Tf> highT = { 1, 1 };
+			vec3T<Tf> lowConnX = pointPlaneConnection(a, normalXLow, x);
+			vec3T<Tf> highConnX = pointPlaneConnection(ax, normalXHigh, x);
+			vec3T<Tf> lowConnY = pointPlaneConnection(a, normalYLow, x);
+			vec3T<Tf> highConnY = pointPlaneConnection(ay, normalYHigh, x);
+			vec2T<Tf> lowDist = { norm(lowConnX), norm(lowConnY) };
+			vec2T<Tf> highDist = { norm(highConnX), norm(highConnY) };
+
+			if (dot(lowConnX, highConnX) > 0 || dot(lowConnY, highConnY) > 0)
+			{
+				return thrust::pair<vec3T<Tf>, bool>(vec3T<Tf>{ 0, 0, 0 }, false);
+			}
+
+			vec2T<Tf> dist = { 1e10, 1e10 };
+			vec2T<Tf> t = (highT - lowT) / 2 + lowT;
+			vec3T<Tf> planeBaseX1;
+			vec3T<Tf> planeBaseY1;
+			vec3T<Tf> planeBaseX2;
+			vec3T<Tf> planeBaseY2;
+			for (int numIter = 0; numIter < m_mappingMaxIterations &&
+				(dist.x > m_mappingDistanceThreshold || dist.y > m_mappingDistanceThreshold); numIter++)
+			{
+				t = (1 - highDist / (highDist + lowDist))*highT + (1 - lowDist / (highDist + lowDist))*lowT;
+
+				planeBaseX1 = (1 - t.x)*a + t.x*ax;
+				planeBaseX2 = (1 - t.x)*ay + t.x*axy;
+				planeBaseY1 = (1 - t.y)*a + t.y*ay;
+				planeBaseY2 = (1 - t.y)*ax + t.y*axy;
+				vec3T<Tf> dir = slerp3(slerp3(da, dax, t.x), slerp3(day, daxy, t.x), t.y);
+				vec3T<Tf> normal_x = normalize(cross(dir, planeBaseX2 - planeBaseX1));
+				vec3T<Tf> normal_y = normalize(cross(planeBaseY2 - planeBaseY1, dir));
+
+				vec3T<Tf> connX = pointPlaneConnection(planeBaseX1, normal_x, x);
+				vec3T<Tf> connY = pointPlaneConnection(planeBaseY1, normal_y, x);
+
+				dist.x = norm(connX);
+				dist.y = norm(connY);
+
+				if (dot(highConnX, connX) > M_EPS)
+				{
+					highT.x = t.x;
+					highConnX = connX;
+					highDist.x = dist.x;
+				}
+				else if (dot(lowConnX, connX) > M_EPS)
+				{
+					lowT.x = t.x;
+					lowConnX = connX;
+					lowDist.x = dist.x;
+				}
+
+				if (dot(highConnY, connY) > M_EPS)
+				{
+					highT.y = t.y;
+					highConnY = connY;
+					highDist.y = dist.y;
+				}
+				else if (dot(lowConnY, connY) > M_EPS)
+				{
+					lowT.y = t.y;
+					lowConnY = connY;
+					lowDist.y = dist.y;
+				}
+			}
+
+			vec3T<Tf> lineBase = (1 - t.y)*planeBaseX1 + t.y*planeBaseX2;
+			Tf d = norm(x - lineBase);
+
+			return thrust::pair<vec3T<Tf>, bool>(vec3T<Tf>{ t.x, t.y, d }, true);
+		}
+	};
+
+	template <typename Tf, typename Ti>
+	void
+		
+		computeParameterBB3D(
+			const Tf sampleDistance,
+			const vec2T<Ti> scanlineLayout,
+			const int scanlineIdxX,
+			const int scanlineIdxY,
+			const vec3T<Tf> s1,
+			const vec3T<Tf> e1,
+			const vec3T<Tf> s2,
+			const vec3T<Tf> e2,
+			const vec3T<Tf> s3,
+			const vec3T<Tf> e3,
+			const vec3T<Tf> s4,
+			const vec3T<Tf> e4,
+			const vec3T<Tf> scanline1Pos,
+			const vec3T<Tf> scanline1Dir,
+			const vec3T<Tf> scanline2Pos,
+			const vec3T<Tf> scanline2Dir,
+			const vec3T<Tf> scanline3Pos,
+			const vec3T<Tf> scanline3Dir,
+			const vec3T<Tf> scanline4Pos,
+			const vec3T<Tf> scanline4Dir,
+			const Tf startDepth,
+			const Tf endDepth,
+			const vec3T<Ti> imageSize,
+			const vec3T<Tf> bbMin,
+			const vec3T<Ti> tetMinVoxel,
+			const vec3T<Ti> tetMaxVoxel,
+			const Tf resolution,
+			uint8_t* __restrict__ maskBuf,
+			uint32_t* __restrict__ sampleIdxBuf,
+			float* __restrict__ weightXBuf,
+			float* __restrict__ weightYBuf,
+			float* __restrict__ weightZBuf
+		,
+			sycl::nd_item<3> item_ct1)
+	{
+		vec3T<Ti> voxel = vec3T<Ti>{ static_cast<Ti>(item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2)),
+									 static_cast<Ti>(item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1)),
+									 static_cast<Ti>(item_ct1.get_local_range().get(0) * item_ct1.get_group(0)
+													 + item_ct1.get_local_id(0)) };	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		voxel = voxel + tetMinVoxel;
+
+		if (voxel.x <= tetMaxVoxel.x && voxel.y <= tetMaxVoxel.y && voxel.z <= tetMaxVoxel.z)
+		{
+			vec3T<Tf> voxelPos = static_cast<vec3T<Tf>>(voxel) * resolution + bbMin;
+			ScanConverterInternals::computeParametersVoxel3D(
+				sampleDistance,
+				scanlineLayout,
+				scanlineIdxX, scanlineIdxY,
+				s1, e1, s2, e2, s3, e3, s4, e4,
+				scanline1Pos,
+				scanline1Dir,
+				scanline2Pos,
+				scanline2Dir,
+				scanline3Pos,
+				scanline3Dir,
+				scanline4Pos,
+				scanline4Dir,
+				startDepth, endDepth,
+				imageSize,
+				voxel,
+				voxelPos,
+				maskBuf,
+				sampleIdxBuf,
+				weightXBuf,
+				weightYBuf,
+				weightZBuf);
+		}
+	}
+
+	template <typename InputType, typename OutputType, typename WeightType, typename IndexType>
+	void scanConvert2D(
+		uint32_t numScanlines,
+		uint32_t numSamples,
+		uint32_t width,
+		uint32_t height,
+		const uint8_t* __restrict__ mask,
+		const IndexType* __restrict__ sampleIdx,
+		const WeightType* __restrict__ weightX,
+		const WeightType* __restrict__ weightY,
+		const InputType* __restrict__ scanlines,
+		OutputType* __restrict__ image,
+		sycl::nd_item<3> item_ct1)
+	{
+		vec2T<uint32_t> pixelPos{ item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2),
+								  item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1) };  //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+
+		if (pixelPos.x < width && pixelPos.y < height)
+		{
+			IndexType pixelIdx = pixelPos.x + pixelPos.y*width;
+			float val = 0;
+			if (mask[pixelIdx])
+			{
+				IndexType sIdx = sampleIdx[pixelIdx];
+				WeightType wX = weightX[pixelIdx];
+				WeightType wY = weightY[pixelIdx];
+
+				val = (1 - wY)*((1 - wX)*scanlines[sIdx] +
+					wX *scanlines[sIdx + 1]) +
+					wY *((1 - wX)*scanlines[sIdx + numScanlines] +
+						wX *scanlines[sIdx + 1 + numScanlines]);
+			}
+			image[pixelIdx] = clampCast<OutputType>(val);
+		}
+	}
+
+	template <typename InputType, typename OutputType, typename WeightType, typename IndexType>
+	void scanConvert3D(
+		uint32_t numScanlinesX,
+		uint32_t numScanlinesY,
+		uint32_t numSamples,
+		uint32_t width,
+		uint32_t height,
+		uint32_t depth,
+		const uint8_t* __restrict__ mask,
+		const IndexType* __restrict__ sampleIdx,
+		const WeightType* __restrict__ weightX,
+		const WeightType* __restrict__ weightY,
+		const WeightType* __restrict__ weightZ,
+		const InputType* __restrict__ scanlines,
+		OutputType* __restrict__ image,
+		sycl::nd_item<3> item_ct1)
+	{
+		vec3T<uint32_t> pixelPos{ item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2),
+								  item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1),
+								  item_ct1.get_local_range().get(0) * item_ct1.get_group(0) + item_ct1.get_local_id(0) };  //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+
+		if (pixelPos.x < width && pixelPos.y < height)
+		{
+			IndexType pixelIdx = pixelPos.x + pixelPos.y*width + pixelPos.z*width*height;
+			float val = 0;
+			if (mask[pixelIdx])
+			{
+				uint32_t numScanlines = numScanlinesX*numScanlinesY;
+				IndexType sIdx = sampleIdx[pixelIdx];
+				WeightType wX = weightX[pixelIdx];
+				WeightType wY = weightY[pixelIdx];
+				WeightType wZ = weightZ[pixelIdx];
+
+
+				val =
+					(1 - wY)*((1 - wZ)*((1 - wX)*scanlines[sIdx] +
+						wX *scanlines[sIdx + 1]) +
+						wZ *((1 - wX)*scanlines[sIdx + numScanlinesX] +
+							wX *scanlines[sIdx + 1 + numScanlinesX])) +
+					wY* ((1 - wZ)*((1 - wX)*scanlines[sIdx + numScanlines] +
+						wX *scanlines[sIdx + 1 + numScanlines]) +
+						wZ *((1 - wX)*scanlines[sIdx + numScanlinesX + numScanlines] +
+							wX *scanlines[sIdx + 1 + numScanlinesX + numScanlines]));
+			}
+			image[pixelIdx] = clampCast<OutputType>(val);
+		}
+	}
+
+	shared_ptr<Container<uint8_t> > ScanConverter::getMask()
+	{
+		return m_mask;
+	}
+
+	template<typename InputType, typename OutputType>
+	shared_ptr<Container<OutputType> > ScanConverter::convert(const shared_ptr<USImage>& inImage)
+	{
+		uint32_t numScanlines = (uint32_t)inImage->getImageProperties()->getNumScanlines();
+		vec2s scanlineLayout = inImage->getImageProperties()->getScanlineLayout();
+		uint32_t numSamples = (uint32_t)inImage->getImageProperties()->getNumSamples();
+
+		shared_ptr<const Container<InputType> > pScanlineData = inImage->getData<InputType>();
+		if (pScanlineData->isHost())
+		{
+			pScanlineData = make_shared<Container<InputType> >(LocationGpu, *pScanlineData);
+		}
+		auto pConv = make_shared<Container<OutputType> >(LocationGpu, pScanlineData->getStream(), m_imageSize.x*m_imageSize.y*m_imageSize.z);
+
+		if (m_is2D)
+		{
+			sycl::range<3> blockSize(1, 256, 1);
+			sycl::range<3> gridSize(1, static_cast<unsigned int>((m_imageSize.y + blockSize[ 1 ] - 1) / blockSize[ 1 ]),
+									static_cast<unsigned int>((m_imageSize.x + blockSize[ 2 ] - 1) / blockSize[ 2 ]));
+			/*
+			DPCT1049:22: The workgroup size passed to the SYCL kernel may exceed the limit. To get the device limit, query info::device::max_work_group_size. Adjust the workgroup size if needed.
+			*/
+				  pScanlineData->getStream()->submit([ & ](sycl::handler& cgh) {
+						auto m_imageSize_x_ct2 = ( uint32_t )m_imageSize.x;
+						auto m_imageSize_y_ct3 = ( uint32_t )m_imageSize.y;
+						auto m_mask_get_ct4 = m_mask->get();
+						auto m_sampleIdx_get_ct5 = m_sampleIdx->get();
+						auto m_weightX_get_ct6 = m_weightX->get();
+						auto m_weightY_get_ct7 = m_weightY->get();
+						auto pScanlineData_get_ct8 = pScanlineData->get();
+						auto pConv_get_ct9 = pConv->get();
+
+						cgh.parallel_for(sycl::nd_range<3>(gridSize * blockSize, blockSize), [ = ](sycl::nd_item<3> item_ct1) {
+							  scanConvert2D(numScanlines, numSamples, m_imageSize_x_ct2, m_imageSize_y_ct3, m_mask_get_ct4, m_sampleIdx_get_ct5, m_weightX_get_ct6, m_weightY_get_ct7,
+											pScanlineData_get_ct8, pConv_get_ct9, item_ct1);
+						});
+				  });
+			/*
+			DPCT1010:20: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+			*/
+			cudaSafeCall(0);
+		}
+		else
+		{
+			sycl::range<3> blockSize(1, 256, 1);
+			sycl::range<3> gridSize(static_cast<unsigned int>((m_imageSize.z + blockSize[ 0 ] - 1) / blockSize[ 0 ]), static_cast<unsigned int>((m_imageSize.y + blockSize[ 1 ] - 1) / blockSize[ 1 ]),
+									static_cast<unsigned int>((m_imageSize.x + blockSize[ 2 ] - 1) / blockSize[ 2 ]));
+			/*
+			DPCT1049:23: The workgroup size passed to the SYCL kernel may exceed the limit. To get the device limit, query info::device::max_work_group_size. Adjust the workgroup size if needed.
+			*/
+				  pScanlineData->getStream()->submit([ & ](sycl::handler& cgh) {
+						auto m_imageSize_x_ct3 = ( uint32_t )m_imageSize.x;
+						auto m_imageSize_y_ct4 = ( uint32_t )m_imageSize.y;
+						auto m_imageSize_z_ct5 = ( uint32_t )m_imageSize.z;
+						auto m_mask_get_ct6 = m_mask->get();
+						auto m_sampleIdx_get_ct7 = m_sampleIdx->get();
+						auto m_weightX_get_ct8 = m_weightX->get();
+						auto m_weightY_get_ct9 = m_weightY->get();
+						auto m_weightZ_get_ct10 = m_weightZ->get();
+						auto pScanlineData_get_ct11 = pScanlineData->get();
+						auto pConv_get_ct12 = pConv->get();
+
+						cgh.parallel_for(sycl::nd_range<3>(gridSize * blockSize, blockSize), [ = ](sycl::nd_item<3> item_ct1) {
+							  scanConvert3D(( uint32_t )scanlineLayout.x, ( uint32_t )scanlineLayout.y, numSamples, m_imageSize_x_ct3, m_imageSize_y_ct4, m_imageSize_z_ct5, m_mask_get_ct6,
+											m_sampleIdx_get_ct7, m_weightX_get_ct8, m_weightY_get_ct9, m_weightZ_get_ct10, pScanlineData_get_ct11, pConv_get_ct12, item_ct1);
+						});
+				  });
+			/*
+			DPCT1010:21: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+			*/
+			cudaSafeCall(0);
+		}
+		return pConv;
+	}
+
+	template
+		std::shared_ptr<Container<uint8_t> > ScanConverter::convert<uint8_t, uint8_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<int16_t> > ScanConverter::convert<uint8_t, int16_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<float> > ScanConverter::convert<uint8_t, float>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<uint8_t> > ScanConverter::convert<int16_t, uint8_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<int16_t> > ScanConverter::convert<int16_t, int16_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<float> > ScanConverter::convert<int16_t, float>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<uint8_t> > ScanConverter::convert<float, uint8_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<int16_t> > ScanConverter::convert<float, int16_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<float> > ScanConverter::convert<float, float>(const std::shared_ptr<USImage>& inImage);
+
+	void ScanConverter::updateInternals(const std::shared_ptr<const USImageProperties>& inImageProps)
+	{
+  dpct::device_ext& dev_ct1 = dpct::get_current_device();
+  sycl::queue&	  q_ct1 = dev_ct1.default_queue();
+		logging::log_log("Scanconverter: Updating scanconversion internals");
+
+		//Check the scanline configuration for validity
+		m_is2D = inImageProps->is2D();
+
+		vec2s layout = inImageProps->getScanlineLayout();
+		double startDepth = 0;
+		double endDepth = inImageProps->getDepth();
+		double resolution = inImageProps->getImageResolution();
+		auto scanlines = inImageProps->getScanlineInfo();
+		logging::log_error_if(!scanlines, "ScanConverter: No scanlines have been attached to the USImageProperties!");
+
+		bool scanlinesGood = scanlines.operator bool();
+
+		if (scanlinesGood)
+		{
+			for (size_t scanlineIdxY = 0; scanlineIdxY < layout.y; scanlineIdxY++)
+			{
+				for (size_t scanlineIdxX = 0; scanlineIdxX < layout.x; scanlineIdxX++)
+				{
+					if (scanlineIdxX > 0)
+					{
+						vec start = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec startbefore = (*scanlines)[scanlineIdxX - 1][scanlineIdxY].getPoint(startDepth);
+						vec end = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec endbefore = (*scanlines)[scanlineIdxX - 1][scanlineIdxY].getPoint(endDepth);
+
+						//scanline start points are increasing in x
+						scanlinesGood = scanlinesGood &&
+							start.x >= startbefore.x;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  1 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanline end points are increasing in x, that means scanlines do not intersect
+						scanlinesGood = scanlinesGood &&
+							end.x >= endbefore.x;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  2 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines can not be identical
+						scanlinesGood = scanlinesGood &&
+							(start.x > startbefore.x || end.x > endbefore.x);
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  3 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines are not skew
+						scanlinesGood = scanlinesGood &&
+							abs(det(start - endbefore, startbefore - endbefore, end - endbefore)) < m_skewnessTestThreshold;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  4 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+					}
+
+					if (scanlineIdxY > 0)
+					{
+						vec start = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec startbefore = (*scanlines)[scanlineIdxX][scanlineIdxY - 1].getPoint(startDepth);
+						vec end = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec endbefore = (*scanlines)[scanlineIdxX][scanlineIdxY - 1].getPoint(endDepth);
+
+						//scanline start points are increasing in z
+						scanlinesGood = scanlinesGood &&
+							start.z >= startbefore.z;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  5 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanline end points are increasing in z, that means scanlines do not intersect
+						scanlinesGood = scanlinesGood &&
+							end.z >= endbefore.z;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  6 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines can not be identical
+						scanlinesGood = scanlinesGood &&
+							(start.z > startbefore.z || end.z > endbefore.z);
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  7 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines are not skew
+						scanlinesGood = scanlinesGood &&
+							abs(det(start - endbefore, startbefore - endbefore, end - endbefore)) < m_skewnessTestThreshold;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  8 ", scanlineIdxX, ", ", scanlineIdxY, "   det = ", det(start - endbefore, startbefore - endbefore, end - endbefore));
+						}
+					}
+				}
+			}
+		}
+
+		if (scanlinesGood)
+		{
+			//find scan bounding box
+			vec bbMin{ numeric_limits<double>::max(),  numeric_limits<double>::max(),  numeric_limits<double>::max() };
+			vec bbMax{ -numeric_limits<double>::max(), -numeric_limits<double>::max(), -numeric_limits<double>::max() };
+			for (size_t scanlineIdxY = 0; scanlineIdxY < layout.y; scanlineIdxY++)
+			{
+				for (size_t scanlineIdxX = 0; scanlineIdxX < layout.x; scanlineIdxX++)
+				{
+					vec p1 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+					vec p2 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+					bbMin = { min(bbMin.x, p1.x), min(bbMin.y, p1.y), min(bbMin.z, p1.z) };
+					bbMax = { max(bbMax.x, p1.x), max(bbMax.y, p1.y), max(bbMax.z, p1.z) };
+					bbMin = { min(bbMin.x, p2.x), min(bbMin.y, p2.y), min(bbMin.z, p2.z) };
+					bbMax = { max(bbMax.x, p2.x), max(bbMax.y, p2.y), max(bbMax.z, p2.z) };
+				}
+			}
+			m_bbMin = bbMin;
+			m_bbMax = bbMax;
+
+			//compute image size
+			m_imageSize = static_cast<vec3s>(ceil((bbMax - bbMin) / resolution)) + 1;
+			m_imageSize.x = max(m_imageSize.x, (size_t)1);
+			m_imageSize.y = max(m_imageSize.y, (size_t)1);
+			m_imageSize.z = max(m_imageSize.z, (size_t)1);
+
+			// create buffers
+			size_t numelBuffers = m_imageSize.x*m_imageSize.y*m_imageSize.z;
+			/*m_mask = make_shared<Container<uint8_t> >(ContainerLocation::LocationHost, numelBuffers);
+			m_sampleIdx = make_shared<Container<IndexType> >(ContainerLocation::LocationHost, numelBuffers);
+			m_weightX = make_shared<Container<WeightType> >(ContainerLocation::LocationHost, numelBuffers);
+			m_weightY = make_shared<Container<WeightType> >(ContainerLocation::LocationHost, numelBuffers);
+			m_weightZ = make_shared<Container<WeightType> >(ContainerLocation::LocationHost, numelBuffers);*/
+			m_mask = make_shared<Container<uint8_t>>(ContainerLocation::LocationGpu, &q_ct1, numelBuffers);
+			m_sampleIdx = make_shared<Container<IndexType>>(ContainerLocation::LocationGpu, &q_ct1, numelBuffers);
+			m_weightX = make_shared<Container<WeightType>>(ContainerLocation::LocationGpu, &q_ct1, numelBuffers);
+			m_weightY = make_shared<Container<WeightType>>(ContainerLocation::LocationGpu, &q_ct1, numelBuffers);
+			m_weightZ = make_shared<Container<WeightType>>(ContainerLocation::LocationGpu, &q_ct1, numelBuffers);
+
+			//create image mask
+			/*
+			DPCT1003:24: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((q_ct1.memset(m_mask->get(), 0, m_mask->size() * sizeof(uint8_t)), 0));
+
+			if (m_is2D)
+			{
+				//2D is computed on the cpu at the moment -> copy
+				m_mask = make_shared<Container<uint8_t> >(LocationHost, *m_mask);
+				m_sampleIdx = make_shared<Container<IndexType> >(LocationHost, *m_sampleIdx);
+				m_weightX = make_shared<Container<WeightType> >(LocationHost, *m_weightX);
+				m_weightY = make_shared<Container<WeightType> >(LocationHost, *m_weightY);
+				m_weightZ = make_shared<Container<WeightType> >(LocationHost, *m_weightZ);
+
+				vec2 bb2DMin{ m_bbMin.x, m_bbMin.y };
+				assert(layout.x > 1);
+				// From now on, we assume everything is in the xy-plane
+				// -----------------------------------------
+				for (size_t scanlineIdxY = 0; scanlineIdxY < layout.y; scanlineIdxY++)
+				{
+#pragma omp parallel for schedule(dynamic, 8)
+					for (int scanlineIdxX = 0; scanlineIdxX < layout.x - 1; scanlineIdxX++)
+					{
+						vec start3 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec startN3 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(startDepth);
+						vec end3 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec endN3 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(endDepth);
+						vec2 start = { start3.x, start3.y };
+						vec2 startN = { startN3.x, startN3.y };
+						vec2 end = { end3.x, end3.y };
+						vec2 endN = { endN3.x, endN3.y };
+
+						// find bounding box of the two scanlines
+						vec2 quadMinWorld = { std::min(std::min(std::min(start.x, startN.x), end.x), endN.x), std::min(std::min(std::min(start.y, startN.y), end.y), endN.y) };
+						vec2 quadMaxWorld = { std::max(std::max(std::max(start.x, startN.x), end.x), endN.x), std::max(std::max(std::max(start.y, startN.y), end.y), endN.y) };
+
+						vec2s quadMinPixel = static_cast<vec2s>(floor((quadMinWorld - bb2DMin) / resolution));
+						vec2s quadMaxPixel = static_cast<vec2s>(ceil((quadMaxWorld - bb2DMin) / resolution));
+
+						// check the pixels in the quad bounding box and mark the inside ones
+						vec2s pixel;
+						for (pixel.x = quadMinPixel.x; pixel.x <= quadMaxPixel.x; pixel.x++)
+						{
+							for (pixel.y = quadMinPixel.y; pixel.y <= quadMaxPixel.y; pixel.y++)
+							{
+								vec2 pixelPos = static_cast<vec2>(pixel) * resolution + bb2DMin;
+								if (pointInsideTriangle(endN, end, start, pixelPos) ||
+									pointInsideTriangle(start, startN, endN, pixelPos))
+								{
+									m_mask->get()[pixel.x + pixel.y*m_imageSize.x] = 1;
+
+									vec2 params = mapToParameters2D(
+										(*scanlines)[scanlineIdxX][scanlineIdxY].position,
+										(*scanlines)[scanlineIdxX + 1][scanlineIdxY].position,
+										(*scanlines)[scanlineIdxX][scanlineIdxY].direction,
+										(*scanlines)[scanlineIdxX + 1][scanlineIdxY].direction,
+										startDepth, endDepth, { pixelPos.x, pixelPos.y, 0.0 });
+									double t = params.x;
+									double d = params.y;
+
+									IndexType  sampleIdxScanline = static_cast<IndexType>(std::floor(d / inImageProps->getSampleDistance()));
+									WeightType weightY = static_cast<WeightType>(d - (sampleIdxScanline*inImageProps->getSampleDistance()));
+									WeightType weightX = static_cast<WeightType>(t);
+
+									IndexType sampleIdx = static_cast<IndexType>(sampleIdxScanline*inImageProps->getNumScanlines() +
+										scanlineIdxX + scanlineIdxY*layout.x);
+
+									m_sampleIdx->get()[pixel.x + pixel.y*m_imageSize.x] = sampleIdx;
+									m_weightX->get()[pixel.x + pixel.y*m_imageSize.x] = weightX;
+									m_weightY->get()[pixel.x + pixel.y*m_imageSize.x] = weightY;
+								}
+							}
+						}
+					}
+				}
+
+				//2D is computed on the cpu at the moment -> copy
+				m_mask = make_shared<Container<uint8_t> >(LocationGpu, *m_mask);
+				m_sampleIdx = make_shared<Container<IndexType> >(LocationGpu, *m_sampleIdx);
+				m_weightX = make_shared<Container<WeightType> >(LocationGpu, *m_weightX);
+				m_weightY = make_shared<Container<WeightType> >(LocationGpu, *m_weightY);
+				m_weightZ = make_shared<Container<WeightType> >(LocationGpu, *m_weightZ);
+			}
+			else {
+				// 3D case
+				for (int scanlineIdxY = 0; scanlineIdxY < layout.y - 1; scanlineIdxY++)
+				{
+					//#pragma omp parallel for schedule(dynamic, 1)
+					for (int scanlineIdxX = 0; scanlineIdxX < layout.x - 1; scanlineIdxX++)
+					{
+						vec s1 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec e1 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec s2 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(startDepth);
+						vec e2 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(endDepth);
+						vec s3 = (*scanlines)[scanlineIdxX][scanlineIdxY + 1].getPoint(startDepth);
+						vec e3 = (*scanlines)[scanlineIdxX][scanlineIdxY + 1].getPoint(endDepth);
+						vec s4 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY + 1].getPoint(startDepth);
+						vec e4 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY + 1].getPoint(endDepth);
+
+						// find bounding box of the four scanlines
+						vec tetMinWorld = min(min(min(s1, s2), min(s3, s4)),
+							min(min(e1, e2), min(e3, e4)));
+						vec tetMaxWorld = max(max(max(s1, s2), max(s3, s4)),
+							max(max(e1, e2), max(e3, e4)));
+
+						vec3s tetMinVoxel = static_cast<vec3s>(floor((tetMinWorld - bbMin) / resolution));
+						vec3s tetMaxVoxel = static_cast<vec3s>(ceil((tetMaxWorld - bbMin) / resolution));
+
+						vec3s numVoxels = tetMaxVoxel - tetMinVoxel + 1;
+						sycl::range<3> blockSize(4, 4, 16);
+						sycl::range<3> gridSize(static_cast<unsigned int>((numVoxels.z + blockSize[ 0 ] - 1) / blockSize[ 0 ]),
+												static_cast<unsigned int>((numVoxels.y + blockSize[ 1 ] - 1) / blockSize[ 1 ]),
+												static_cast<unsigned int>((numVoxels.x + blockSize[ 2 ] - 1) / blockSize[ 2 ]));
+
+						typedef float Tf;
+						typedef int Ti;
+
+						/*
+						DPCT1049:25: The workgroup size passed to the SYCL kernel may exceed the limit. To get the device limit, query info::device::max_work_group_size. Adjust the workgroup size if
+						needed.
+						*/
+									q_ct1.submit([ & ](sycl::handler& cgh) {
+										  auto inImageProps_getSampleDistance_ct0 = static_cast<Tf>(inImageProps->getSampleDistance());
+										  auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct12 = static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY ].position);
+										  auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct13 = static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY ].direction);
+										  auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct14 =
+											  static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY ].position);
+										  auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct15 =
+											  static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY ].direction);
+										  auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct16 =
+											  static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY + 1 ].position);
+										  auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct17 =
+											  static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY + 1 ].direction);
+										  auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct18 =
+											  static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY + 1 ].position);
+										  auto static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct19 =
+											  static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY + 1 ].direction);
+										  auto static_cast_vec3T_Ti_m_imageSize_ct22 = static_cast<vec3T<Ti>>(m_imageSize);
+										  auto m_mask_get_ct27 = m_mask->get();
+										  auto m_sampleIdx_get_ct28 = m_sampleIdx->get();
+										  auto m_weightX_get_ct29 = m_weightX->get();
+										  auto m_weightY_get_ct30 = m_weightY->get();
+										  auto m_weightZ_get_ct31 = m_weightZ->get();
+
+										  cgh.parallel_for(sycl::nd_range<3>(gridSize * blockSize, blockSize), [ = ](sycl::nd_item<3> item_ct1) {
+												computeParameterBB3D<Tf, Ti>(
+													inImageProps_getSampleDistance_ct0, static_cast<vec2T<Ti>>(layout), scanlineIdxX, scanlineIdxY, static_cast<vec3T<Tf>>(s1),
+													static_cast<vec3T<Tf>>(e1), static_cast<vec3T<Tf>>(s2), static_cast<vec3T<Tf>>(e2), static_cast<vec3T<Tf>>(s3), static_cast<vec3T<Tf>>(e3),
+													static_cast<vec3T<Tf>>(s4), static_cast<vec3T<Tf>>(e4), static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct12,
+													static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct13, static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct14,
+													static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct15, static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct16,
+													static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct17, static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_position_ct18,
+													static_cast_vec3T_Tf_scanlines_scanlineIdxX_scanlineIdxY_direction_ct19, static_cast<Tf>(startDepth), static_cast<Tf>(endDepth),
+													static_cast_vec3T_Ti_m_imageSize_ct22, static_cast<vec3T<Tf>>(bbMin), static_cast<vec3T<Ti>>(tetMinVoxel), static_cast<vec3T<Ti>>(tetMaxVoxel),
+													static_cast<Tf>(resolution), m_mask_get_ct27, m_sampleIdx_get_ct28, m_weightX_get_ct29, m_weightY_get_ct30, m_weightZ_get_ct31, item_ct1);
+										  });
+									});
+						/*
+						DPCT1010:26: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+						*/
+						cudaSafeCall(0);
+					}
+				}
+			}
+			/*
+			DPCT1003:27: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((q_ct1.wait(), 0));
+		}
+		else
+		{
+			logging::log_error("ScanConverter: The scanlines are not in the required configuration.");
+		}
+	}
+
+	double ScanConverter::barycentricCoordinate2D(const vec2 & a, const vec2 & b, const vec2 & c)
+	{
+		return (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);
+	}
+
+	bool ScanConverter::pointInsideTriangle(const vec2 & a, const vec2 & b, const vec2 & c, const vec2 & p)
+	{
+		double w0 = barycentricCoordinate2D(b, c, p);
+		double w1 = barycentricCoordinate2D(c, a, p);
+		double w2 = barycentricCoordinate2D(a, b, p);
+
+		// Test if p is on or inside all edges
+		return (w0 >= 0 && w1 >= 0 && w2 >= 0);
+	}
+
+	vec ScanConverter::pointLineConnection(const vec & a, const vec & da, const vec & x)
+	{
+		vec conn = x - a;
+		vec r = conn - dot(da, conn) *da;
+		return r;
+	}
+
+	vec2 ScanConverter::mapToParameters2D(const vec & a, const vec & b, const vec & da, const vec & db, double startDepth, double endDepth, const vec & x)
+	{
+		//find t via binary search
+		double lowT = 0;
+		double highT = 1;
+		vec lowConn = pointLineConnection(a, da, x);
+		vec highConn = pointLineConnection(b, db, x);
+		double lowDist = norm(lowConn);
+		double highDist = norm(highConn);
+
+		if (highConn.x == 0 && highConn.y == 0 && highConn.z == 0)
+		{
+			double t = highT;
+			double d = norm(x - b);
+			return{ t, d };
+		}
+		else if (lowConn.x == 0 && lowConn.y == 0 && lowConn.z == 0)
+		{
+			double t = lowT;
+			double d = norm(x - a);
+			return{ t, d };
+		}
+
+		assert(dot(lowConn, highConn) < 0);
+
+		double dist = 1e10;
+		double t = (highT - lowT) / 2 + lowT;
+		vec lineBase;
+		for (size_t numIter = 0; numIter < m_mappingMaxIterations && dist > m_mappingDistanceThreshold; numIter++)
+		{
+			t = (1 - highDist / (highDist + lowDist))*highT + (1 - lowDist / (highDist + lowDist))*lowT;
+
+			lineBase = (1 - t)*a + t*b;
+			vec lineDir = slerp3(da, db, t);
+
+			vec conn = pointLineConnection(lineBase, lineDir, x);
+			dist = norm(conn);
+
+			if (dot(lowConn, conn) < 0)
+			{
+				highT = t;
+				highConn = conn;
+				highDist = dist;
+			}
+			else
+			{
+				lowT = t;
+				lowConn = conn;
+				lowDist = dist;
+			}
+		}
+		double d = norm(x - lineBase);
+
+		return{ t, d };
+	}
+}
diff --git a/src/SupraLib/Beamformer/WindowFunction.h b/src/SupraLib/Beamformer/WindowFunction.h
index 21c559b..2158d3a 100644
--- a/src/SupraLib/Beamformer/WindowFunction.h
+++ b/src/SupraLib/Beamformer/WindowFunction.h
@@ -12,23 +12,26 @@
 #ifndef __WINDOWFUNCTION_H__
 #define __WINDOWFUNCTION_H__
 
-#ifndef __CUDACC__
+#ifndef SYCL_LANGUAGE_VERSION
 #include <algorithm>
 #endif
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include <memory>
 #include <Container.h>
 #include <utilities/utility.h>
 #include <utilities/cudaUtility.h>
+#include <cmath>
 
 namespace supra
 {
-#ifndef __CUDACC__
+#ifndef SYCL_LANGUAGE_VERSION
 	using std::max;
 	using std::min;
 #else
-	using ::max;
-	using ::min;
+	using sycl::max;
+	using sycl::min;
 #endif
 
 	//forward declaration
@@ -55,25 +58,23 @@ namespace supra
 
 		//Returns the weight of chosen window a the relative index 
 		// relativeIndex has to be normalized to [-1, 1] (inclusive)
-		__device__ inline ElementType get(float relativeIndex) const
+		inline ElementType get(float relativeIndex) const
 		{
-			float relativeIndexClamped = min(max(relativeIndex, -1.0f), 1.0f);
-			uint32_t absoluteIndex =
-				static_cast<uint32_t>(roundf(m_scale*(relativeIndexClamped + 1.0f)));
+			float	 relativeIndexClamped = sycl::min(sycl::max(relativeIndex, -1.0f), 1.0f);
+			uint32_t absoluteIndex = static_cast<uint32_t>(sycl::round(m_scale * (relativeIndexClamped + 1.0f)));
 			return m_data[absoluteIndex];
 		}
 
 		//Returns the weight of chosen window a the relative index
 		// relativeIndex has to be normalized to [-1, 1] (inclusive)
-		__device__ inline ElementType getShared(const ElementType * __restrict__ sharedData, float relativeIndex) const
+		inline ElementType getShared(const ElementType * __restrict__ sharedData, float relativeIndex) const
 		{
-			float relativeIndexClamped = min(max(relativeIndex, -1.0f), 1.0f);
-			uint32_t absoluteIndex =
-				static_cast<uint32_t>(roundf(m_scale*(relativeIndexClamped + 1.0f)));
+			float	 relativeIndexClamped = sycl::min(sycl::max(relativeIndex, -1.0f), 1.0f);
+			uint32_t absoluteIndex = static_cast<uint32_t>(sycl::round(m_scale * (relativeIndexClamped + 1.0f)));
 			return sharedData[absoluteIndex];
 		}
 
-		__device__ inline ElementType getDirect(uint32_t idx) const
+		inline ElementType getDirect(uint32_t idx) const
 		{
 			ElementType ret = 0;
 			if (idx < m_numEntriesPerFunction)
@@ -83,14 +84,14 @@ namespace supra
 			return ret;
 		}
 
-		__device__ inline uint32_t numElements() const
+		inline uint32_t numElements() const
 		{
 			return m_numEntriesPerFunction;
 		}
 
 	private:
 		friend WindowFunction;
-		__host__ WindowFunctionGpu(size_t numEntriesPerFunction, const ElementType* data)
+		WindowFunctionGpu(size_t numEntriesPerFunction, const ElementType* data)
 			: m_numEntriesPerFunction(static_cast<uint32_t>(numEntriesPerFunction))
 			, m_data(data)
 			, m_scale(static_cast<float>(numEntriesPerFunction - 1)*0.5f) {};
@@ -119,7 +120,7 @@ namespace supra
 
 		// relativeIndex has to be normalized to [-1, 1] (inclusive)
 		template <typename T>
-		static __device__ __host__ inline T windowFunction(const WindowType& type, const T& relativeIndex, const T& windowParameter)
+		static inline T windowFunction(const WindowType& type, const T& relativeIndex, const T& windowParameter)
 		{
 			switch (type)
 			{
@@ -130,8 +131,7 @@ namespace supra
 			case WindowHamming:
 				return (1 - windowParameter)*(0.54f - 0.46f*std::cos(2*static_cast<T>(M_PI)*((relativeIndex + 1) *0.5f))) + windowParameter;
 			case WindowGauss:
-				return static_cast<T>(
-					1.0 / (windowParameter * sqrt(2.0 * M_PI)) * exp((-1.0 / 2.0) * (relativeIndex / windowParameter)*(relativeIndex / windowParameter)));
+				return static_cast<T>(1.0 / (windowParameter * sycl::sqrt(2.0 * M_PI)) * std::exp((-1.0 / 2.0) * (relativeIndex / windowParameter) * (relativeIndex / windowParameter)));
 			default:
 				return 0;
 			}
diff --git a/src/SupraLib/Container.h b/src/SupraLib/Container.h
index c6bb6bd..eac0fca 100644
--- a/src/SupraLib/Container.h
+++ b/src/SupraLib/Container.h
@@ -12,6 +12,8 @@
 #ifndef __CONTAINER_H__
 #define __CONTAINER_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include "ContainerFactory.h"
 #ifdef HAVE_CUDA
 #include "utilities/cudaUtility.h"
@@ -22,6 +24,9 @@
 #include <memory>
 #include <vector>
 #include <cassert>
+#include <chrono>
+
+#include <future>
 
 namespace supra
 {
@@ -59,12 +64,18 @@ namespace supra
 #ifdef HAVE_CUDA
 			if(location == LocationGpu)
 			{
-				cudaSafeCall(cudaMemcpyAsync(this->get(), data.data(), this->size() * sizeof(T), cudaMemcpyDefault, associatedStream));
+				/*
+				DPCT1003:10: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((associatedStream->memcpy(this->get(), data.data(), this->size() * sizeof(T)), 0));
 				createAndRecordEvent();
 			}
 			else if(location == LocationBoth)
 			{
-				cudaSafeCall(cudaMemcpyAsync(this->get(), data.data(), this->size() * sizeof(T), cudaMemcpyDefault, associatedStream));
+				/*
+				DPCT1003:11: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((associatedStream->memcpy(this->get(), data.data(), this->size() * sizeof(T)), 0));
 				createAndRecordEvent();
 			}
 			else
@@ -83,7 +94,10 @@ namespace supra
 			:Container(location, associatedStream, dataEnd - dataBegin)
 		{
 #ifdef HAVE_CUDA
-			cudaSafeCall(cudaMemcpyAsync(this->get(), dataBegin, this->size() * sizeof(T), cudaMemcpyDefault, associatedStream));
+			/*
+			DPCT1003:12: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((associatedStream->memcpy(this->get(), dataBegin, this->size() * sizeof(T)), 0));
 			createAndRecordEvent();
 			if (waitFinished)
 			{
@@ -103,22 +117,34 @@ namespace supra
 #ifdef HAVE_CUDA
 			else if (source.m_location == LocationHost && location == LocationGpu)
 			{
-				cudaSafeCall(cudaMemcpyAsync(this->get(), source.get(), source.size() * sizeof(T), cudaMemcpyDefault, source.getStream()));
+				/*
+				DPCT1003:13: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T)), 0));
 				createAndRecordEvent();
 			}
 			else if (source.m_location == LocationGpu && location == LocationHost)
 			{
-				cudaSafeCall(cudaMemcpyAsync(this->get(), source.get(), source.size() * sizeof(T), cudaMemcpyDefault, source.getStream()));
+				/*
+				DPCT1003:14: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T)), 0));
 				createAndRecordEvent();
 			}
 			else if (source.m_location == LocationGpu && location == LocationGpu)
 			{
-				cudaSafeCall(cudaMemcpyAsync(this->get(), source.get(), source.size() * sizeof(T), cudaMemcpyDefault, source.getStream()));
+				/*
+				DPCT1003:15: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T)), 0));
 				createAndRecordEvent();
 			}
 			else
 			{
-				cudaSafeCall(cudaMemcpyAsync(this->get(), source.get(), source.size() * sizeof(T), cudaMemcpyDefault, source.getStream()));
+				/*
+				DPCT1003:16: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T)), 0));
 				createAndRecordEvent();
 			}
 			if (waitFinished)
@@ -130,17 +156,20 @@ namespace supra
 #endif
 		};
 		~Container()
-		{
+		 try {
 #ifdef HAVE_CUDA
-			auto ret = cudaStreamQuery(m_associatedStream);
-			if (ret != cudaSuccess && ret != cudaErrorNotReady && ret != cudaErrorCudartUnloading)
+			/*
+			DPCT1027:3: The call to cudaStreamQuery was replaced with 0, because DPC++ currently does not support query operations on queues.
+			*/
+			auto ret = 0;
+			if (ret != 0 && ret != 600 && ret != 4)
 			{
 				cudaSafeCall(ret);
 			}
 			// If the driver is currently unloading, we cannot free the memory in any way. Exit will clean up.
-			else if(ret != cudaErrorCudartUnloading)
+			else if (ret != 4)
 			{
-				if (ret == cudaSuccess)
+				if (ret == 0)
 				{
 					ContainerFactoryContainerInterface::returnMemory(reinterpret_cast<uint8_t*>(m_buffer), m_numel * sizeof(T), m_location);
 				}
@@ -149,7 +178,7 @@ namespace supra
 					auto buffer = m_buffer;
 					auto numel = m_numel;
 					auto location = m_location;
-					addCallbackStream([buffer, numel, location](cudaStream_t s, cudaError_t e) -> void {
+					addCallbackStream([ buffer, numel, location ](sycl::queue* s, int e) -> void {
 						ContainerFactoryContainerInterface::returnMemory(reinterpret_cast<uint8_t*>(buffer), numel * sizeof(T), location);
 					});
 				}
@@ -157,6 +186,10 @@ namespace supra
 #else
 			ContainerFactoryContainerInterface::returnMemory(reinterpret_cast<uint8_t*>(m_buffer), m_numel * sizeof(T), m_location);
 #endif
+		}
+		catch (sycl::exception const& exc) {
+		  std::cerr << exc.what() << "Exception caught at file:" << __FILE__ << ", line:" << __LINE__ << std::endl;
+		  std::exit(1);
 		};
 
 		const T* get() const { return m_buffer; };
@@ -173,12 +206,18 @@ namespace supra
 			}
 			else if(m_location == LocationGpu)
 			{
-				cudaSafeCall(cudaMemcpyAsync(ret, this->get(), this->size() * sizeof(T), cudaMemcpyDeviceToHost, getStream()));
+				/*
+				DPCT1003:17: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((getStream()->memcpy(ret, this->get(), this->size() * sizeof(T)), 0));
 				cudaSafeCall(cudaStreamSynchronize(getStream()));				
 			}
 			else 
 			{
-				cudaSafeCall(cudaMemcpy(ret, this->get(), this->size() * sizeof(T), cudaMemcpyDefault));
+				/*
+				DPCT1003:18: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((dpct::get_default_queue().memcpy(ret, this->get(), this->size() * sizeof(T)).wait(), 0));
 			}
 			return ret;
 #else
@@ -190,7 +229,10 @@ namespace supra
 		{
 #ifdef HAVE_CUDA
 			assert(maxSize >= this->size());
-			cudaSafeCall(cudaMemcpy(dst, this->get(), this->size() * sizeof(T), cudaMemcpyDefault));
+			/*
+			DPCT1003:19: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((dpct::get_default_queue().memcpy(dst, this->get(), this->size() * sizeof(T)).wait(), 0));
 #endif
 		}
 
@@ -199,8 +241,14 @@ namespace supra
 #ifdef HAVE_CUDA
 			if (m_creationEvent)
 			{
-				cudaSafeCall(cudaEventSynchronize(m_creationEvent));
-				cudaSafeCall(cudaEventDestroy(m_creationEvent));
+				/*
+				DPCT1003:4: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((m_creationEvent.wait_and_throw(), 0));
+				/*
+				DPCT1027:5: The call to cudaEventDestroy was replaced with 0, because this call is redundant in DPC++.
+				*/
+				cudaSafeCall(0);
 				m_creationEvent = nullptr;
 			}
 #endif
@@ -226,26 +274,41 @@ namespace supra
 			if (!m_creationEvent)
 			{
 				//cudaSafeCall(cudaEventCreateWithFlags(&m_creationEvent, cudaEventBlockingSync | cudaEventDisableTiming));
-				cudaSafeCall(cudaEventCreateWithFlags(&m_creationEvent, cudaEventDisableTiming));
+				/*
+				DPCT1027:6: The call to cudaEventCreateWithFlags was replaced with 0, because this call is redundant in DPC++.
+				*/
+				cudaSafeCall(0);
 			}
-			cudaSafeCall(cudaEventRecord(m_creationEvent, m_associatedStream));
+			/*
+			DPCT1012:7: Detected kernel execution time measurement pattern and generated an initial code for time measurements in SYCL. You can change the way time is measured depending on your goals.
+			*/
+			/*
+			DPCT1024:8: The original code returned the error code that was further consumed by the program logic. This original code was replaced with 0. You may need to rewrite the program logic
+			consuming the error code.
+			*/
+			m_creationEvent_ct1 = std::chrono::steady_clock::now();
+			cudaSafeCall(0);
 #endif
 		}
 
 #ifdef HAVE_CUDA
-		void addCallbackStream(std::function<void(cudaStream_t, cudaError_t)> func)
+		void addCallbackStream(std::function<void(sycl::queue*, int)> func)
 		{
-			auto funcPointer = new std::function<void(cudaStream_t, cudaError_t)>(func);
-			cudaSafeCall(cudaStreamAddCallback(m_associatedStream, &(Container<T>::cudaDeleteCallback), funcPointer, 0));
+			auto funcPointer = new std::function<void(sycl::queue*, int)>(func);
+			/*
+			DPCT1003:9: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((std::async([ & ]() {
+											 m_associatedStream->wait(); &(Container<T>::cudaDeleteCallback)(m_associatedStream, 0, funcPointer);
+						  }),
+						  0));
 		}
 #endif
 
 #ifdef HAVE_CUDA
-		static void CUDART_CB cudaDeleteCallback(cudaStream_t stream, cudaError_t status, void* userData)
+		static void cudaDeleteCallback(sycl::queue* stream, int status, void* userData)
 		{
-			std::unique_ptr<std::function<void(cudaStream_t, cudaError_t)> > func =
-				std::unique_ptr<std::function<void(cudaStream_t, cudaError_t)> >(
-					reinterpret_cast<std::function<void(cudaStream_t, cudaError_t)>*>(userData));
+			std::unique_ptr<std::function<void(sycl::queue*, int)>> func = std::unique_ptr<std::function<void(sycl::queue*, int)>>(reinterpret_cast<std::function<void(sycl::queue*, int)>*>(userData));
 			(*func)(stream, status);
 		}
 #endif
@@ -257,7 +320,8 @@ namespace supra
 		T* m_buffer;
 
 #ifdef HAVE_CUDA
-		cudaEvent_t m_creationEvent;
+		sycl::event										   m_creationEvent;
+		std::chrono::time_point<std::chrono::steady_clock> m_creationEvent_ct1;
 #endif
 	};
 }
diff --git a/src/SupraLib/ContainerFactory.cpp.dp.cpp b/src/SupraLib/ContainerFactory.cpp.dp.cpp
new file mode 100644
index 0000000..464a762
--- /dev/null
+++ b/src/SupraLib/ContainerFactory.cpp.dp.cpp
@@ -0,0 +1,290 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2017, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "ContainerFactory.h"
+
+#include <utilities/Logging.h>
+#include <utilities/utility.h>
+
+#include <sstream>
+#include <cassert>
+using namespace std;
+
+namespace supra
+{
+	ContainerFactory::ContainerStreamType ContainerFactory::getNextStream()
+	{
+		std::lock_guard<std::mutex> streamLock(sm_streamMutex);
+
+		if (sm_streams.size() == 0)
+		{
+			initStreams();
+		}
+
+		size_t streamIndex = sm_streamIndex;
+		sm_streamIndex = (sm_streamIndex + 1) % sm_numberStreams;
+		return sm_streams[streamIndex];
+	}
+	uint8_t* ContainerFactory::acquireMemory(size_t numBytes, ContainerLocation location)
+	{
+		assert(location < LocationINVALID);
+		
+		// Check whether the queue for this location and size has a buffer left
+		uint8_t* buffer = nullptr;
+		{
+			// by directly accessing the desired length in the map sm_bufferMaps[location],
+			// the map entry is created if it does not already exist. That means the map is
+			// modified here
+			tbb::concurrent_queue<std::pair<uint8_t*, double> >* queuePointer =
+				&(sm_bufferMaps[location][numBytes]);
+
+			std::pair<uint8_t*, double> queueEntry;
+			if (queuePointer->try_pop(queueEntry))
+			{
+				// If yes, just return this already allocated buffer
+				buffer = queueEntry.first;
+			}
+		}
+
+		// If the queue did not contain a buffer, allocate a new one
+		if (!buffer)
+		{
+			// Check whether there is enough free space for the requested buffer. 
+			size_t memoryFree;
+#ifdef HAVE_CUDA
+			size_t memoryTotal;
+			if (location == LocationGpu || location == LocationBoth)
+			{
+				cudaSafeCall(cudaMemGetInfo(&memoryFree, &memoryTotal));
+				memoryFree = static_cast<size_t>(std::max(static_cast<double>(memoryFree) - (static_cast<double>(memoryTotal) * 0.02), 0.0));
+			}
+			else
+#endif
+			{
+				// For the host memory we just rely on the 
+				memoryFree = numBytes;
+			}
+
+			// If not, relase enough unused buffers, starting with the ones that have been returned the longest time ago.
+			if (memoryFree < numBytes)
+			{
+				freeBuffers(numBytes, location);
+			}
+
+			// additionaly, release memory that has been returned over XX (e.g. 30) seconds ago
+			freeOldBuffers();
+
+			// Now that we have made the required memory available, we can allocate the buffer
+			buffer = allocateMemory(numBytes, location);
+		}
+
+		return buffer;
+	}
+
+	void ContainerFactory::returnMemory(uint8_t* pointer, size_t numBytes, ContainerLocation location)
+	{
+		assert(location < LocationINVALID);
+
+		// do not free here, just put it back to the queues with the time it was returned at
+		double returnTime = getCurrentTime();
+
+		// Put buffer back to queue
+		{
+			tbb::concurrent_queue<std::pair<uint8_t*, double> >* queuePointer =
+				&(sm_bufferMaps[location][numBytes]);
+
+			queuePointer->push(std::make_pair(pointer, returnTime));
+		}
+	}
+	void ContainerFactory::initStreams()
+	{
+		logging::log_log("ContainerFactory: Initializing ", sm_numberStreams, " streams.");
+		sm_streamIndex = 0;
+#ifdef HAVE_CUDA
+		sm_streams.resize(sm_numberStreams);
+		for (size_t k = 0; k < sm_numberStreams; k++)
+		{
+			/*
+			DPCT1003:32: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			/*
+			DPCT1025:33: The SYCL queue is created ignoring the flag/priority options.
+			*/
+			cudaSafeCall(((sm_streams[ k ]) = dpct::get_current_device().create_queue(), 0));
+		}
+#else
+		sm_streams.resize(sm_numberStreams, 0);
+#endif
+	}
+
+	uint8_t * ContainerFactory::allocateMemory(size_t numBytes, ContainerLocation location)
+	{
+  dpct::device_ext& dev_ct1 = dpct::get_current_device();
+  sycl::queue&	  q_ct1 = dev_ct1.default_queue();
+		uint8_t* buffer = nullptr;
+		switch (location)
+		{
+		case LocationGpu:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:34: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((buffer = ( uint8_t* )sycl::malloc_device(numBytes, q_ct1), 0));
+#endif
+			break;
+		case LocationBoth:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:35: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((buffer = ( uint8_t* )sycl::malloc_shared(numBytes, q_ct1), 0));
+#endif
+			break;
+		case LocationHost:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:36: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((buffer = ( uint8_t* )sycl::malloc_host(numBytes, q_ct1), 0));
+#else
+			buffer = new uint8_t[numBytes];
+#endif
+			break;
+		default:
+			throw std::runtime_error("invalid argument: Container: Unknown location given");
+		}
+		if (!buffer)
+		{
+			std::stringstream s;
+			s << "bad alloc: Container: Error allocating buffer of size " << numBytes << " in "
+				<< (location == LocationHost ? "LocationHost" : (location == LocationGpu ? "LocationGpu" : "LocationBoth"));
+			throw std::runtime_error(s.str());
+		}
+
+		return buffer;
+	}
+
+	void ContainerFactory::freeBuffers(size_t numBytesMin, ContainerLocation location)
+	{
+		size_t numBytesFreed = 0;
+		size_t numBuffersFreed;
+		do 
+		{
+			numBuffersFreed = 0;
+			// by traversing the map sm_bufferMaps[location] we never create new entries, but only modifiy those already present.
+			for (auto mapIterator = sm_bufferMaps[location].begin(); mapIterator != sm_bufferMaps[location].end(); mapIterator++)
+			{
+				size_t numBytesBuffer = mapIterator->first;
+				std::pair<uint8_t*, double> queueEntry;
+				if(mapIterator->second.try_pop(queueEntry))
+				{
+					// If there is an element in this queue, remove it and free the memory
+					freeMemory(queueEntry.first, numBytesBuffer, location);
+					numBytesFreed += numBytesBuffer;
+					numBuffersFreed++;
+				}
+			}
+		} while (numBytesFreed < numBytesMin && numBuffersFreed > 0);
+	}
+
+	void ContainerFactory::freeOldBuffers()
+	{
+		double currentTime = getCurrentTime();
+		double deleteTime = currentTime - sm_deallocationTimeout;
+		for (ContainerLocation location = LocationHost; location < LocationINVALID; location = static_cast<ContainerLocation>(location + 1))
+		{
+			for (auto mapIterator = sm_bufferMaps[location].begin(); mapIterator != sm_bufferMaps[location].end(); mapIterator++)
+			{
+				size_t numBytesBuffer = mapIterator->first;
+
+				double lastTime = 0.0;
+				while(!mapIterator->second.empty() && lastTime < deleteTime)
+				{
+					// If there is an element in this queue, remove it and free the memory
+					std::pair<uint8_t*, double> bufferPair;
+					if (mapIterator->second.try_pop(bufferPair))
+					{
+						lastTime = bufferPair.second;
+						if (lastTime < deleteTime)
+						{
+							freeMemory(bufferPair.first, numBytesBuffer, location);
+						}
+						else
+						{
+							// oops, we should not have taken that element from the queue. Let's just put it back.
+							// Yes, it will be in the wrong temporal order, but that will be solved in a while on its own
+							mapIterator->second.push(bufferPair);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	void ContainerFactory::garbageCollectionThreadFunction()
+	{
+		sm_garbageCollectionThread.detach();
+		while (true)
+		{
+			ContainerFactory::freeOldBuffers();
+			std::this_thread::sleep_for(std::chrono::duration<double>(sm_deallocationTimeout));
+		}
+	}
+
+	void ContainerFactory::freeMemory(uint8_t * pointer, size_t numBytes, ContainerLocation location)
+	{
+  dpct::device_ext& dev_ct1 = dpct::get_current_device();
+  sycl::queue&	  q_ct1 = dev_ct1.default_queue();
+		switch (location)
+		{
+		case LocationGpu:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:37: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			(sycl::free(pointer, q_ct1), 0);
+#endif
+			break;
+		case LocationBoth:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:38: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			(sycl::free(pointer, q_ct1), 0);
+#endif
+			break;
+		case LocationHost:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:39: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			(sycl::free(pointer, q_ct1), 0);
+#else
+			delete[] pointer;
+#endif
+			break;
+		default:
+			break;
+		}
+	}
+
+	std::vector<ContainerFactory::ContainerStreamType> ContainerFactory::sm_streams = {};
+	size_t ContainerFactory::sm_streamIndex = 0;
+	std::mutex ContainerFactory::sm_streamMutex;
+
+	constexpr double ContainerFactory::sm_deallocationTimeout;
+
+	std::array<tbb::concurrent_unordered_map<size_t, tbb::concurrent_queue<std::pair<uint8_t*, double> > >, LocationINVALID> ContainerFactory::sm_bufferMaps;
+
+	std::thread ContainerFactory::sm_garbageCollectionThread(&ContainerFactory::garbageCollectionThreadFunction);
+}
diff --git a/src/SupraLib/ContainerFactory.h b/src/SupraLib/ContainerFactory.h
index 855558a..e39c914 100644
--- a/src/SupraLib/ContainerFactory.h
+++ b/src/SupraLib/ContainerFactory.h
@@ -13,6 +13,8 @@
 #define __CONTAINERFACTORY_H__
 
 #ifdef HAVE_CUDA
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include "utilities/cudaUtility.h"
 #endif
 
@@ -36,7 +38,7 @@ namespace supra
 	{
 	public:
 #ifdef HAVE_CUDA
-		typedef cudaStream_t ContainerStreamType;
+		typedef sycl::queue* ContainerStreamType;
 #else
 		typedef int ContainerStreamType;
 #endif
diff --git a/src/SupraLib/utilities/DataType.h b/src/SupraLib/utilities/DataType.h
index 005fb51..6a97bba 100644
--- a/src/SupraLib/utilities/DataType.h
+++ b/src/SupraLib/utilities/DataType.h
@@ -12,12 +12,13 @@
 #ifndef __DATATYPE_H__
 #define __DATATYPE_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include <stdint.h>
 #include <string>
 #include "utilities/utility.h"
 
 #ifdef HAVE_CUDA
-#include <cuda_fp16.h>
 #endif
 
 namespace supra
@@ -69,8 +70,7 @@ namespace supra
 	template <>
 	DataType DataTypeGet<uint64_t>();
 #ifdef HAVE_CUDA
-	template<>
-	DataType DataTypeGet<__half>();
+	template <> DataType DataTypeGet<sycl::half>();
 #endif
 	template <>
 	DataType DataTypeGet<float>();
diff --git a/src/SupraLib/utilities/FirFilterFactory.h b/src/SupraLib/utilities/FirFilterFactory.h
index 5b68392..09283ba 100644
--- a/src/SupraLib/utilities/FirFilterFactory.h
+++ b/src/SupraLib/utilities/FirFilterFactory.h
@@ -27,9 +27,12 @@
 #ifndef __FIRFILTERFACTORY_H__
 #define __FIRFILTERFACTORY_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include <memory>
 #include <functional>
 #include "Container.h"
+#include <cmath>
 
 namespace supra
 {
@@ -86,7 +89,7 @@ namespace supra
 			ElementType omegaBandwidth = static_cast<ElementType>(2 * M_PI* bandwidth / samplingFrequency);
 			int halfWidth = ((int)length - 1) / 2;
 
-			auto filter = std::make_shared<Container<ElementType> >(LocationHost, cudaStreamPerThread, length);
+			auto filter = std::make_shared<Container<ElementType>>(LocationHost, &dpct::get_default_queue(), length);
 
 			//determine the filter function
 			std::function<ElementType(int)> filterFunction = [&halfWidth](int n) -> ElementType {
@@ -181,7 +184,7 @@ namespace supra
 				break;
 			case FilterWindowKaiser:
 				windowFunction = [maxN, beta](int n) -> ElementType {
-					double argument = beta * sqrt(1.0 - pow(2 * ((ElementType)n - maxN / 2) / maxN, 2.0));
+					double argument = beta * sqrt(1.0 - (2 * (( ElementType )n - maxN / 2) / maxN) * (2 * (( ElementType )n - maxN / 2) / maxN));
 					return static_cast<ElementType>(bessel0_1stKind(argument) / bessel0_1stKind(beta)); };
 				break;
 			case FilterWindowRectangular:
@@ -223,9 +226,9 @@ namespace supra
 			static const int factorial[9] = { 1, 2, 6, 24, 120, 720, 5040, 40320, 362880 };
 			for (int k = 1; k < 10; k++)
 			{
-				T xPower = pow(x / (T)2.0, (T)k);
+				T xPower = pow(x / ( T )2.0, ( T )k);
 				// 1, 2, 6, 24, 120, 720, 5040, 40320, 362880
-				sum += pow(xPower / (T)factorial[k-1], (T)2.0);
+				sum += pow(xPower / ( T )factorial[ k - 1 ], ( T )2.0);
 			}
 			return (T)1.0 + sum;
 		}
diff --git a/src/SupraLib/utilities/cudaUtility.h b/src/SupraLib/utilities/cudaUtility.h
index 5dcde51..8d5356c 100644
--- a/src/SupraLib/utilities/cudaUtility.h
+++ b/src/SupraLib/utilities/cudaUtility.h
@@ -12,9 +12,10 @@
 #ifndef __CUDAUTILITY_H__
 #define __CUDAUTILITY_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include <cmath>
 #ifdef HAVE_CUDA
-#include <cuda_runtime_api.h>
 #ifdef HAVE_CUFFT
 #include <cufft.h>
 #endif
@@ -27,12 +28,12 @@
 
 namespace supra
 {
-#ifdef __CUDACC__
-	using ::max;
-	using ::min;
-	using ::round;
-	using ::floor;
-	using ::ceil;
+#ifdef SYCL_LANGUAGE_VERSION
+	using sycl::max;
+	using sycl::min;
+	using sycl::round;
+	using sycl::floor;
+	using sycl::ceil;
 #else
 	using std::max;
 	using std::min;
@@ -59,12 +60,21 @@ namespace supra
 
 	/// Verifies a cuda call returned "cudaSuccess". Prints error message otherwise.
 	/// returns true if no error occured, false otherwise. Calles by cudaSafeCall
-	inline bool cudaSafeCall2(cudaError err, const char* file, int line, const char* func) {
+	inline bool cudaSafeCall2(int err, const char* file, int line, const char* func) {
 
 		//#ifdef CUDA_ERROR_CHECK
-		if (cudaSuccess != err) {
+		/*
+		DPCT1000:1: Error handling if-stmt was detected but could not be rewritten.
+		*/
+		if (0 != err) {
 			char buf[1024];
-			sprintf(buf, "CUDA Error (in \"%s\", Line: %d, %s): %d - %s\n", file, line, func, err, cudaGetErrorString(err));
+			/*
+			DPCT1001:0: The statement could not be removed.
+			*/
+			/*
+			DPCT1009:2: SYCL uses exceptions to report errors and does not use the error codes. The original code was commented out and a warning string was inserted. You need to rewrite this code.
+			*/
+			sprintf(buf, "CUDA Error (in \"%s\", Line: %d, %s): %d - %s\n", file, line, func, err, "cudaGetErrorString not supported" /*cudaGetErrorString(err)*/);
 			printf("%s", buf);
 			logging::log_error(buf);
 			return false;
@@ -99,7 +109,7 @@ namespace supra
 
 	/// Returns the square of x. CUDA constexpr version
 	template <typename T>
-	__device__ constexpr inline T squ(const T& x)
+	constexpr inline T squ(const T& x)
 	{
 		return x*x;
 	}
@@ -112,43 +122,43 @@ namespace supra
 	class LimitProxy
 	{
 	public:
-		inline __host__ __device__ static T max();
-		inline __host__ __device__ static T min();
+		inline static T max();
+		inline static T min();
 	};
 
 	template <>
 	class LimitProxy<float>
 	{
 	public:
-		inline __host__ __device__ static float max() { return FLT_MAX; }
-		inline __host__ __device__ static float min() { return -FLT_MAX; }
+		inline static float max() { return FLT_MAX; }
+		inline static float min() { return -FLT_MAX; }
 	};
 
 	template <>
 	class LimitProxy<int16_t>
 	{
 	public:
-		inline __host__ __device__ static int16_t max() { return 32767; }
-		inline __host__ __device__ static int16_t min() { return -32767; }
+		inline static int16_t max() { return 32767; }
+		inline static int16_t min() { return -32767; }
 	};
 
 	template <>
 	class LimitProxy<uint8_t>
 	{
 	public:
-		inline __host__ __device__ static uint8_t max() { return 255; }
-		inline __host__ __device__ static uint8_t min() { return 0; }
+		inline static uint8_t max() { return 255; }
+		inline static uint8_t min() { return 0; }
 	};
 
 	template <typename ResultType, typename InputType>
-	__host__ __device__ ResultType clampCast(const InputType& x)
+	ResultType clampCast(const InputType& x)
 	{
-		return static_cast<ResultType>(min(max(x, static_cast<InputType>(LimitProxy<ResultType>::min())), static_cast<InputType>(LimitProxy<ResultType>::max())));
+		return static_cast<ResultType>(std::min(std::max(x, static_cast<InputType>(LimitProxy<ResultType>::min())), static_cast<InputType>(LimitProxy<ResultType>::max())));
 	}
 
 	template <typename ResultType, typename InputType>
 	struct clampCaster {
-		__host__ __device__ ResultType operator()(const InputType& a) const
+		ResultType operator()(const InputType& a) const
 		{
 			return clampCast<ResultType>(a);
 		}
diff --git a/src/SupraLib/utilities/utility.h b/src/SupraLib/utilities/utility.h
index af80e0f..729de80 100644
--- a/src/SupraLib/utilities/utility.h
+++ b/src/SupraLib/utilities/utility.h
@@ -12,6 +12,8 @@
 #ifndef __UTILITY_H__
 #define __UTILITY_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include <cctype>
 #include <algorithm>
 #include <vector>
diff --git a/src/SupraLib/vec.h b/src/SupraLib/vec.h
index 9def0e5..8b10d3e 100644
--- a/src/SupraLib/vec.h
+++ b/src/SupraLib/vec.h
@@ -12,8 +12,11 @@
 #ifndef __VEC_H__
 #define __VEC_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include "utilities/utility.h"
 #include "utilities/cudaUtility.h"
+#include <cmath>
 
 namespace supra
 {
@@ -35,7 +38,7 @@ namespace supra
 
 		/// Explicit numeric conversion operator. Casts both elements seperately to NewElementType
 		template <typename NewElementType>
-		__host__ __device__ explicit operator vec2T<NewElementType>() const
+		explicit operator vec2T<NewElementType>() const
 		{
 			return vec2T<NewElementType>{
 				static_cast<NewElementType>(this->x),
@@ -43,13 +46,13 @@ namespace supra
 		}
 
 		/// Equality operator. Compares this and b elementwise for equality
-		__host__ __device__ bool operator==(const vec2T<ElementType>& b) const
+		bool operator==(const vec2T<ElementType>& b) const
 		{
 			return x == b.x && y == b.y;
 		}
 
 		/// Inequality operator. Compares this and b elementwise for inequality
-		__host__ __device__ bool operator!=(const vec2T<ElementType>& b) const
+		bool operator!=(const vec2T<ElementType>& b) const
 		{
 			return x != b.x || y != b.y;
 		}
@@ -67,16 +70,16 @@ namespace supra
 		ElementType z;
 
 		/// Conversion of a 3-vector representing a POINT to homogeneous coordinates
-		__host__ __device__ vec4T<ElementType> pointToHom() const { return vec4T<ElementType>({ this->x, this->y, this->z, 1 }); }
+		vec4T<ElementType> pointToHom() const { return vec4T<ElementType>({ this->x, this->y, this->z, 1 }); }
 		/// Explicit conversion of a 3-vector representing a POINT to homogeneous coordinates
-		__host__ __device__ explicit operator vec4T<ElementType>() const { return pointToHom(); };
+		explicit operator vec4T<ElementType>() const { return pointToHom(); };
 
 		/// Conversion of a 3-vector representing a VECTOR to homogeneous coordinates
-		__host__ __device__ vec4T<ElementType> vectorToHom() const { return vec4T<ElementType>({ this->x, this->y, this->z, 0 }); }
+		vec4T<ElementType> vectorToHom() const { return vec4T<ElementType>({ this->x, this->y, this->z, 0 }); }
 
 		/// Explicit numeric conversion operator. Casts both elements seperately to NewElementType
 		template <typename NewElementType>
-		__host__ __device__ explicit operator vec3T<NewElementType>() const
+		explicit operator vec3T<NewElementType>() const
 		{
 			return vec3T<NewElementType>{
 				static_cast<NewElementType>(this->x),
@@ -85,13 +88,13 @@ namespace supra
 		}
 
 		/// Equality operator. Compares this and b elementwise for equality
-		__host__ __device__ bool operator==(const vec3T<ElementType>& b) const
+		bool operator==(const vec3T<ElementType>& b) const
 		{
 			return x == b.x && y == b.y && z == b.z;
 		}
 
 		/// Inequality operator. Compares this and b elementwise for inequality
-		__host__ __device__ bool operator!=(const vec3T<ElementType>& b) const
+		bool operator!=(const vec3T<ElementType>& b) const
 		{
 			return x != b.x || y != b.y || z != b.z;
 		}
@@ -174,197 +177,167 @@ namespace supra
 	typedef rect2 rect;
 
 	/// Element-wise sum of a two-vector and a scalar
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator+(const vec2T<Ta>& a, const Tb& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator+(const vec2T<Ta>& a, const Tb& b) {
 		return vec2T<Ta>({ a.x + b, a.y + b });
 	}
 	/// Negation of a two-vector
-	template <typename Ta>
-	__host__ __device__ inline vec2T<Ta> operator-(const vec2T<Ta>& a) {
+	template <typename Ta> SYCL_EXTERNAL inline vec2T<Ta> operator-(const vec2T<Ta>& a) {
 		return vec2T<Ta>({ -a.x, -a.y });
 	}
 	/// Element-wise subtraction of a two-vector and a scalar
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator-(const vec2T<Ta>& a, const Tb& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator-(const vec2T<Ta>& a, const Tb& b) {
 		return vec2T<Ta>({ a.x - b, a.y - b });
 	}
 	/// Product of a two-vector and a scalar
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator*(const vec2T<Ta>& a, const Tb& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator*(const vec2T<Ta>& a, const Tb& b) {
 		return vec2T<Ta>({ a.x * b, a.y * b });
 	}
 	/// Element-wise division of a two-vector and a scalar
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator/(const vec2T<Ta>& a, const Tb& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator/(const vec2T<Ta>& a, const Tb& b) {
 		return vec2T<Ta>({ a.x / b, a.y / b });
 	}
 	/// Element-wise sum of a scalar and a two-vector
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator+(const Tb& b, const vec2T<Ta>& a) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator+(const Tb& b, const vec2T<Ta>& a) {
 		return vec2T<Ta>({ a.x + b, a.y + b });
 	}
 	/// Element-wise difference of a scalar and a two-vector
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator-(const Tb& b, const vec2T<Ta>& a) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator-(const Tb& b, const vec2T<Ta>& a) {
 		return vec2T<Ta>({ b - a.x, b - a.y });
 	}
 	/// Product of a scalar and a two-vector
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator*(const Tb& b, const vec2T<Ta>& a) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator*(const Tb& b, const vec2T<Ta>& a) {
 		return vec2T<Ta>({ a.x * b, a.y * b });
 	}
 	/// Element-wise division of two-vectors
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator/(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator/(const vec2T<Ta>& a, const vec2T<Tb>& b) {
 		return vec2T<Ta>({ a.x / b.x, a.y / b.y });
 	}
 	/// Sum of two-vectors
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator+(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator+(const vec2T<Ta>& a, const vec2T<Tb>& b) {
 		return vec2T<Ta>({ a.x + b.x, a.y + b.y });
 	}
 	/// Difference of two-vectors
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator-(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator-(const vec2T<Ta>& a, const vec2T<Tb>& b) {
 		return vec2T<Ta>({ a.x - b.x, a.y - b.y });
 	}
 	/// Element-wise product of two-vectors
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator*(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec2T<Ta> operator*(const vec2T<Ta>& a, const vec2T<Tb>& b) {
 		return vec2T<Ta>({ a.x * b.x, a.y * b.y });
 	}
 	/// Euclidean norm of a two-vector
 	template <typename Ta>
-	__host__ __device__ inline Ta norm(const vec2T<Ta>& a)
+	inline Ta norm(const vec2T<Ta>& a)
 	{
 		return sqrt(a.x*a.x + a.y*a.y);
 	}
 	/// Normalization of a two-vector
 	template <typename Ta>
-	__host__ __device__ inline vec2T<Ta> normalize(const vec2T<Ta>& a)
+	inline vec2T<Ta> normalize(const vec2T<Ta>& a)
 	{
 		return a / norm(a);
 	}
 
 	/// Element-wise round of a two-vector
 	template <typename Ta>
-	__host__ __device__ inline vec2T<Ta> round(const vec2T<Ta>& a)
+	inline vec2T<Ta> round(const vec2T<Ta>& a)
 	{
 		return{ round(a.x), round(a.y) };
 	}
 	/// Element-wise floor of a two-vector
 	template <typename Ta>
-	__host__ __device__ inline vec2T<Ta> floor(const vec2T<Ta>& a)
+	inline vec2T<Ta> floor(const vec2T<Ta>& a)
 	{
-		return{ floor(a.x), floor(a.y) };
+		return { sycl::floor(( double )(a.x)), sycl::floor(( double )(a.y)) };
 	}
 	/// Element-wise ceil of a two-vector
 	template <typename Ta>
-	__host__ __device__ inline vec2T<Ta> ceil(const vec2T<Ta>& a)
+	inline vec2T<Ta> ceil(const vec2T<Ta>& a)
 	{
-		return{ ceil(a.x), ceil(a.y) };
+		return { sycl::ceil(( double )(a.x)), sycl::ceil(( double )(a.y)) };
 	}
 	/// Element-wise minimum of two-vectors
 	template <typename Ta>
-	__host__ __device__ inline vec2T<Ta> min(const vec2T<Ta>& a, const vec2T<Ta>& b)
+	inline vec2T<Ta> min(const vec2T<Ta>& a, const vec2T<Ta>& b)
 	{
-		return{
-			min(a.x, b.x),
-			min(a.y, b.y)
-		};
+		return { std::min(a.x, b.x), std::min(a.y, b.y) };
 	}
 	/// Element-wise maximum of two-vectors
 	template <typename Ta>
-	__host__ __device__ inline vec2T<Ta> max(const vec2T<Ta>& a, const vec2T<Ta>& b)
+	inline vec2T<Ta> max(const vec2T<Ta>& a, const vec2T<Ta>& b)
 	{
-		return{
-			max(a.x, b.x),
-			max(a.y, b.y)
-		};
+		return { std::max(a.x, b.x), std::max(a.y, b.y) };
 	}
 
 	/// Element-wise sum of a three-vector and a scalar
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator+(const vec3T<Ta>& a, const Tb& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator+(const vec3T<Ta>& a, const Tb& b) {
 		return vec3T<Ta>({ a.x + b, a.y + b, a.z + b });
 	}
 	/// Negation of a three-vector
-	template <typename Ta>
-	__host__ __device__ inline vec3T<Ta> operator-(const vec3T<Ta>& a) {
+	template <typename Ta> SYCL_EXTERNAL inline vec3T<Ta> operator-(const vec3T<Ta>& a) {
 		return vec3T<Ta>({ -a.x, -a.y, -a.z });
 	}
 	/// Element-wise subtraction of a three-vector and a scalar
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator-(const vec3T<Ta>& a, const Tb& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator-(const vec3T<Ta>& a, const Tb& b) {
 		return vec3T<Ta>({ a.x - b, a.y - b, a.z - b });
 	}
 	/// Product of a three-vector and a scalar
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator*(const vec3T<Ta>& a, const Tb& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator*(const vec3T<Ta>& a, const Tb& b) {
 		return vec3T<Ta>({ a.x * b, a.y * b, a.z * b });
 	}
 	/// Element-wise division of a three-vector and a scalar
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator/(const vec3T<Ta>& a, const Tb& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator/(const vec3T<Ta>& a, const Tb& b) {
 		return vec3T<Ta>({ a.x / b, a.y / b, a.z / b });
 	}
 	/// Element-wise sum of a scalar and a three-vector
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator+(const Tb& b, const vec3T<Ta>& a) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator+(const Tb& b, const vec3T<Ta>& a) {
 		return vec3T<Ta>({ a.x + b, a.y + b, a.z + b });
 	}
 	/// Element-wise difference of a scalar and a three-vector
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator-(const Tb& b, const vec3T<Ta>& a) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator-(const Tb& b, const vec3T<Ta>& a) {
 		return vec3T<Ta>({ b - a.x, b - a.y, b - a.z });
 	}
 	/// Product of a scalar and a three-vector
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator*(const Tb& b, const vec3T<Ta>& a) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator*(const Tb& b, const vec3T<Ta>& a) {
 		return vec3T<Ta>({ a.x * b, a.y * b, a.z * b });
 	}
 	/// Element-wise division of three-vectors
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator/(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator/(const vec3T<Ta>& a, const vec3T<Tb>& b) {
 		return vec3T<Ta>({ a.x / b.x, a.y / b.y, a.z / b.z });
 	}
 	/// Sum of three-vectors
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator+(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator+(const vec3T<Ta>& a, const vec3T<Tb>& b) {
 		return vec3T<Ta>({ a.x + b.x, a.y + b.y, a.z + b.z });
 	}
 	/// Difference of three-vectors
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator-(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator-(const vec3T<Ta>& a, const vec3T<Tb>& b) {
 		return vec3T<Ta>({ a.x - b.x, a.y - b.y, a.z - b.z });
 	}
 	/// Element-wise product of three-vectors
-	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator*(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+	template <typename Ta, typename Tb> SYCL_EXTERNAL inline vec3T<Ta> operator*(const vec3T<Ta>& a, const vec3T<Tb>& b) {
 		return vec3T<Ta>({ a.x * b.x, a.y * b.y, a.z * b.z });
 	}
 
 	/// Euclidean norm of a three-vector
 	template <typename Ta>
-	__host__ __device__ inline Ta norm(const vec3T<Ta>& a)
+	inline Ta norm(const vec3T<Ta>& a)
 	{
-		return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);
+		return sycl::sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
 	}
 	/// Normalization of a three-vector
 	template <typename Ta>
-	__host__ __device__ inline vec3T<Ta> normalize(const vec3T<Ta>& a)
+	inline vec3T<Ta> normalize(const vec3T<Ta>& a)
 	{
 		return a / norm(a);
 	}
 	/// Dot-product of two three-vectors
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline typename std::common_type<Ta, Tb>::type dot(const vec3T<Ta>& a, const vec3T<Tb>& b)
+	inline typename std::common_type<Ta, Tb>::type dot(const vec3T<Ta>& a, const vec3T<Tb>& b)
 	{
 		return a.x*b.x + a.y*b.y + a.z*b.z;
 	}
 	/// Cross-product of two three-vectors
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<typename std::common_type<Ta, Tb>::type > cross(const vec3T<Ta>& a, const vec3T<Tb>& b)
+	inline vec3T<typename std::common_type<Ta, Tb>::type > cross(const vec3T<Ta>& a, const vec3T<Tb>& b)
 	{
 		return{
 			a.y*b.z - a.z*b.y,
@@ -374,56 +347,48 @@ namespace supra
 	}
 	/// Determinant of matric \f$[a, b, c]\f$
 	template <typename Ta, typename Tb, typename Tc>
-	__host__ __device__ inline typename std::common_type<Ta, Tb, Tc>::type det(const vec3T<Ta>& a, const vec3T<Tb>& b, const vec3T<Tc>& c)
+	inline typename std::common_type<Ta, Tb, Tc>::type det(const vec3T<Ta>& a, const vec3T<Tb>& b, const vec3T<Tc>& c)
 	{
-		return abs(dot(a, cross(b, c)));
+		return sycl::fabs(dot(a, cross(b, c)));
 	}
 	/// Element-wise round of a three-vector
 	template <typename Ta>
-	__host__ __device__ inline vec3T<Ta> round(const vec3T<Ta>& a)
+	inline vec3T<Ta> round(const vec3T<Ta>& a)
 	{
 		return{ round(a.x), round(a.y), round(a.z) };
 	}
 	/// Element-wise floor of a three-vector
 	template <typename Ta>
-	__host__ __device__ inline vec3T<Ta> floor(const vec3T<Ta>& a)
+	inline vec3T<Ta> floor(const vec3T<Ta>& a)
 	{
-		return{ floor(a.x), floor(a.y), floor(a.z) };
+		return { sycl::floor(( double )(a.x)), sycl::floor(( double )(a.y)), sycl::floor(( double )(a.z)) };
 	}
 	/// Element-wise ceil of a three-vector
 	template <typename Ta>
-	__host__ __device__ inline vec3T<Ta> ceil(const vec3T<Ta>& a)
+	inline vec3T<Ta> ceil(const vec3T<Ta>& a)
 	{
-		return{ ceil(a.x), ceil(a.y), ceil(a.z) };
+		return { sycl::ceil(( double )(a.x)), sycl::ceil(( double )(a.y)), sycl::ceil(( double )(a.z)) };
 	}
 
 	/// Element-wise minimum of three-vectors
 	template <typename Ta>
-	__host__ __device__ inline vec3T<Ta> min(const vec3T<Ta>& a, const vec3T<Ta>& b)
+	inline vec3T<Ta> min(const vec3T<Ta>& a, const vec3T<Ta>& b)
 	{
-		return{
-			min(a.x, b.x),
-			min(a.y, b.y),
-			min(a.z, b.z)
-		};
+		return { std::min(a.x, b.x), std::min(a.y, b.y), std::min(a.z, b.z) };
 	}
 
 	/// Element-wise maximum of three-vectors
 	template <typename Ta>
-	__host__ __device__ inline vec3T<Ta> max(const vec3T<Ta>& a, const vec3T<Ta>& b)
+	inline vec3T<Ta> max(const vec3T<Ta>& a, const vec3T<Ta>& b)
 	{
-		return{
-			max(a.x, b.x),
-			max(a.y, b.y),
-			max(a.z, b.z)
-		};
+		return { std::max(a.x, b.x), std::max(a.y, b.y), std::max(a.z, b.z) };
 	}
 
 	/// Spherical Linear Interpolation (SLERP) of two three-vectors
 	template <typename T>
-	__host__ __device__ vec3T<T> inline slerp3(const vec3T<T>& a, const vec3T<T>& b, const T& t)
+	vec3T<T> inline slerp3(const vec3T<T>& a, const vec3T<T>& b, const T& t)
 	{
-		T omega = acos(dot(a, b));
+		T omega = sycl::acos(( double )(dot(a, b)));
 		if (omega < M_EPS)
 		{
 			return a;
@@ -438,8 +403,7 @@ namespace supra
 			ret = b;
 		}
 		else {
-			ret = (sin(((T)1.0 - t)*omega) / sin(omega))*a +
-				(sin(t *omega) / sin(omega))*b;
+			ret = (sycl::sin((( T )1.0 - t) * omega) / sycl::sin(omega)) * a + (sycl::sin(t * omega) / sycl::sin(omega)) * b;
 		}
 		return ret;
 	}
-- 
2.17.1

