From f5a1a14ccc0b3f8dce180b2e936376de7c7c41fa Mon Sep 17 00:00:00 2001
From: wangyon1 <yong4.wang@intel.com>
Date: Mon, 3 Aug 2020 14:15:07 +0800
Subject: [PATCH 1/4] remove spaces in *.cu files, generate new files in
 oneapi/ folder

---
 .../Beamformer/HilbertFirEnvelope.dp.cpp      | 130 +++
 .../SupraLib/Beamformer/HilbertFirEnvelope.h  |  44 +
 .../SupraLib/Beamformer/LogCompressor.dp.cpp  |  89 ++
 .../src/SupraLib/Beamformer/LogCompressor.h   |  32 +
 .../SupraLib/Beamformer/RxBeamformerCommon.h  |  57 ++
 .../Beamformer/RxBeamformerCuda.dp.cpp        | 633 ++++++++++++
 .../SupraLib/Beamformer/RxBeamformerCuda.h    |  81 ++
 .../Beamformer/RxBeamformerParameters.h       | 109 +++
 .../RxSampleBeamformerDelayAndStdDev.h        | 244 +++++
 .../RxSampleBeamformerDelayAndSum.h           | 185 ++++
 .../Beamformer/RxSampleBeamformerTestSignal.h | 137 +++
 .../SupraLib/Beamformer/ScanConverter.dp.cpp  | 901 ++++++++++++++++++
 .../src/SupraLib/Beamformer/ScanConverter.h   |  68 ++
 oneapi/src/SupraLib/Beamformer/USRawData.h    |  84 ++
 oneapi/src/SupraLib/Beamformer/USTransducer.h | 125 +++
 .../src/SupraLib/Beamformer/WindowFunction.h  | 149 +++
 oneapi/src/SupraLib/Container.h               | 336 +++++++
 .../src/SupraLib/ContainerFactory.cpp.dp.cpp  | 290 ++++++
 oneapi/src/SupraLib/ContainerFactory.h        |  79 ++
 oneapi/src/SupraLib/RecordObject.h            |  64 ++
 oneapi/src/SupraLib/USImage.h                 | 133 +++
 oneapi/src/SupraLib/USImageProperties.h       | 210 ++++
 oneapi/src/SupraLib/utilities/DataType.h      |  90 ++
 .../src/SupraLib/utilities/FirFilterFactory.h | 236 +++++
 oneapi/src/SupraLib/utilities/Logging.h       | 332 +++++++
 oneapi/src/SupraLib/utilities/cudaUtility.h   | 180 ++++
 oneapi/src/SupraLib/utilities/utility.h       | 216 +++++
 oneapi/src/SupraLib/vec.h                     | 439 +++++++++
 src/SupraLib/Beamformer/HilbertFirEnvelope.cu |  22 +-
 src/SupraLib/Beamformer/LogCompressor.cu      |  16 +-
 src/SupraLib/Beamformer/RxBeamformerCuda.cu   |  44 +-
 src/SupraLib/Beamformer/ScanConverter.cu      |  72 +-
 32 files changed, 5750 insertions(+), 77 deletions(-)
 create mode 100644 oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp
 create mode 100644 oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/LogCompressor.dp.cpp
 create mode 100644 oneapi/src/SupraLib/Beamformer/LogCompressor.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxBeamformerCommon.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxBeamformerParameters.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/ScanConverter.dp.cpp
 create mode 100644 oneapi/src/SupraLib/Beamformer/ScanConverter.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/USRawData.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/USTransducer.h
 create mode 100644 oneapi/src/SupraLib/Beamformer/WindowFunction.h
 create mode 100644 oneapi/src/SupraLib/Container.h
 create mode 100644 oneapi/src/SupraLib/ContainerFactory.cpp.dp.cpp
 create mode 100644 oneapi/src/SupraLib/ContainerFactory.h
 create mode 100644 oneapi/src/SupraLib/RecordObject.h
 create mode 100644 oneapi/src/SupraLib/USImage.h
 create mode 100644 oneapi/src/SupraLib/USImageProperties.h
 create mode 100644 oneapi/src/SupraLib/utilities/DataType.h
 create mode 100644 oneapi/src/SupraLib/utilities/FirFilterFactory.h
 create mode 100644 oneapi/src/SupraLib/utilities/Logging.h
 create mode 100644 oneapi/src/SupraLib/utilities/cudaUtility.h
 create mode 100644 oneapi/src/SupraLib/utilities/utility.h
 create mode 100644 oneapi/src/SupraLib/vec.h

diff --git a/oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp b/oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp
new file mode 100644
index 0000000..c321fe1
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp
@@ -0,0 +1,130 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2019, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "HilbertFirEnvelope.h"
+#include <utilities/utility.h>
+#include <utilities/FirFilterFactory.h>
+
+#include <dpct/dpstd_utils.hpp>
+#include <dpstd/execution>
+#include <dpstd/algorithm>
+
+#include <algorithm>
+
+using namespace std;
+using namespace thrust::placeholders;
+
+namespace supra
+{
+	template <typename InputType, typename OutputType>
+	void kernelFilterDemodulation(
+		const InputType* __restrict__ signal,
+		const HilbertFirEnvelope::WorkType * __restrict__ filter,
+		OutputType * __restrict__ out,
+		const int numSamples,
+		const int numScanlines,
+		const int filterLength,
+		sycl::nd_item<3> item_ct1) {
+		int scanlineIdx = item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2);
+		int sampleIdx = item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1);
+
+		if (scanlineIdx < numScanlines && sampleIdx < numSamples)
+		{
+			HilbertFirEnvelope::WorkType accumulator = 0;
+			
+			int startPoint = sampleIdx - filterLength / 2;
+			int endPoint = sampleIdx + filterLength / 2;
+			int currentFilterElement = 0;
+			for (int currentSample = startPoint;
+				currentSample <= endPoint;
+				currentSample++, currentFilterElement++)
+			{
+				if (currentSample >= 0 && currentSample < numSamples)
+				{
+					HilbertFirEnvelope::WorkType sample = static_cast<HilbertFirEnvelope::WorkType>(signal[scanlineIdx + currentSample*numScanlines]);
+					HilbertFirEnvelope::WorkType filterElement = filter[currentFilterElement];
+					accumulator += sample*filterElement;
+				}
+			}
+
+			HilbertFirEnvelope::WorkType signalValue = static_cast<HilbertFirEnvelope::WorkType>(signal[scanlineIdx + sampleIdx*numScanlines]);
+			out[ scanlineIdx + sampleIdx * numScanlines ] = sycl::sqrt(squ(signalValue) + squ(accumulator));
+		}
+
+	}
+
+	HilbertFirEnvelope::HilbertFirEnvelope(size_t filterLength)
+		: m_filterLength(filterLength)
+		, m_hilbertFilter(nullptr)
+	{
+		prepareFilter();
+	}
+
+	HilbertFirEnvelope::~HilbertFirEnvelope()
+	{
+	}
+
+	void HilbertFirEnvelope::prepareFilter()
+	{
+		m_hilbertFilter = FirFilterFactory::createFilter<float>(
+			m_filterLength,
+			FirFilterFactory::FilterTypeHilbertTransformer,
+			FirFilterFactory::FilterWindowHamming);
+		m_hilbertFilter = make_shared<Container<float>>(LocationGpu, *m_hilbertFilter);
+	}
+
+	template<typename InputType, typename OutputType>
+	shared_ptr<Container<OutputType>> HilbertFirEnvelope::demodulate(
+		const shared_ptr<const Container<InputType>>& inImageData,
+		int numScanlines, int numSamples)
+	{
+		auto pEnv = make_shared<Container<OutputType>>(LocationGpu, inImageData->getStream(), numScanlines*numSamples);
+		sycl::range<3> blockSizeFilter(16, 8, 1);
+		sycl::range<3> gridSizeFilter(static_cast<unsigned int>((numScanlines + blockSizeFilter.x - 1) / blockSizeFilter.x),
+									  static_cast<unsigned int>((numSamples + blockSizeFilter.y - 1) / blockSizeFilter.y), 1);
+
+		inImageData->getStream()->submit([ & ](sycl::handler& cgh) {
+			auto dpct_global_range = gridSizeFilter * blockSizeFilter;
+
+			auto m_filterLength_ct5 = ( int )m_filterLength;
+
+			cgh.parallel_for(
+				sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+								  sycl::range<3>(blockSizeFilter.get(2), blockSizeFilter.get(1), blockSizeFilter.get(0))),
+				[ = ](sycl::nd_item<3> item_ct1) { kernelFilterDemodulation(inImageData->get(), m_hilbertFilter->get(), pEnv->get(), numSamples, numScanlines, m_filterLength_ct5, item_ct1); });
+		});
+		/*
+		DPCT1010:27: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+
+		return pEnv;
+	}
+
+	template 
+	shared_ptr<Container<int16_t>> HilbertFirEnvelope::demodulate<int16_t, int16_t>(
+		const shared_ptr<const Container<int16_t>>& inImageData,
+		int numScanlines, int numSamples);
+	template
+		shared_ptr<Container<int16_t>> HilbertFirEnvelope::demodulate<float, int16_t>(
+			const shared_ptr<const Container<float>>& inImageData,
+			int numScanlines, int numSamples);
+	template
+		shared_ptr<Container<float>> HilbertFirEnvelope::demodulate<int16_t, float>(
+			const shared_ptr<const Container<int16_t>>& inImageData,
+			int numScanlines, int numSamples);
+	template
+		shared_ptr<Container<float>> HilbertFirEnvelope::demodulate<float, float>(
+			const shared_ptr<const Container<float>>& inImageData,
+			int numScanlines, int numSamples);
+}
\ No newline at end of file
diff --git a/oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.h b/oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.h
new file mode 100644
index 0000000..b76d74e
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/HilbertFirEnvelope.h
@@ -0,0 +1,44 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2019, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __HILBERTFIRENVELOPE_H__
+#define __HILBERTFIRENVELOPE_H__
+
+#include "Container.h"
+
+#include <memory>
+
+namespace supra
+{
+	class HilbertFirEnvelope
+	{
+	public:
+		typedef float WorkType;
+
+		HilbertFirEnvelope(size_t filterLength);
+		~HilbertFirEnvelope();
+
+		template<typename InputType, typename OutputType>
+		std::shared_ptr<Container<OutputType> >
+			demodulate(
+				const std::shared_ptr<const Container<InputType> >& inImageData,
+				int numScanlines, int numSamples);
+
+	private:
+		void prepareFilter();
+
+		size_t m_filterLength;
+
+		std::shared_ptr<Container<WorkType> > m_hilbertFilter;
+	};
+}
+
+#endif //!__HILBERTFIRENVELOPE_H__
diff --git a/oneapi/src/SupraLib/Beamformer/LogCompressor.dp.cpp b/oneapi/src/SupraLib/Beamformer/LogCompressor.dp.cpp
new file mode 100644
index 0000000..216b76e
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/LogCompressor.dp.cpp
@@ -0,0 +1,89 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "LogCompressor.h"
+
+#include <dpct/dpstd_utils.hpp>
+#include <dpstd/execution>
+#include <dpstd/algorithm>
+#include <cmath>
+
+using namespace std;
+
+namespace supra
+{
+	template <typename In, typename Out, typename WorkType>
+	struct thrustLogcompress : public thrust::unary_function<In, Out>
+	{
+		WorkType _inScale;
+		WorkType _scaleOverDenominator;
+
+		// Thrust functor that computes
+		// signal = log10(1 + a*signal)./log10(1 + a) 
+		// of the downscaled (_inMax) input signal
+		thrustLogcompress(double dynamicRange, In inMax, Out outMax, double scale)
+			: _inScale(static_cast<WorkType>(dynamicRange / inMax)), _scaleOverDenominator(static_cast<WorkType>(scale * outMax / log10(dynamicRange + 1))){};
+
+		Out operator()(const In& a) const
+		{
+			WorkType val = log10(abs(static_cast<WorkType>(a))*_inScale + (WorkType)1) * _scaleOverDenominator;
+			return clampCast<Out>(val);
+		}
+	};
+
+	template <typename InputType, typename OutputType>
+	shared_ptr<Container<OutputType>> LogCompressor::compress(const shared_ptr<const Container<InputType>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax)
+	{
+		size_t width = size.x;
+		size_t height = size.y;
+		size_t depth = size.z;
+
+		auto pComprGpu = make_shared<Container<OutputType>>(LocationGpu, inImageData->getStream(), width*height*depth);
+
+		OutputType outMax;
+		if (std::is_integral<OutputType>::value)
+		{
+			outMax = std::numeric_limits<OutputType>::max();
+		}
+		else if (std::is_floating_point<OutputType>::value)
+		{
+			outMax = static_cast<OutputType>(255.0);
+		}
+
+		thrustLogcompress<InputType, OutputType, WorkType> c(sycl::pow(( double )(10), (dynamicRange / 20)), static_cast<InputType>(inMax), outMax, scale);
+		/*
+		DPCT1007:30: Migration of this CUDA API is not supported by the Intel(R) DPC++ Compatibility Tool.
+		*/
+		std::transform(dpstd::execution::make_sycl_policy<class Policy_7d1962>(dpct::get_default_queue()), thrust::cuda::par.on(inImageData->getStream()), inImageData->get(),
+					   inImageData->get() + (width * height * depth), pComprGpu->get(), c);
+		/*
+		DPCT1010:31: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+
+		return pComprGpu;
+	}
+
+	template
+	shared_ptr<Container<uint8_t>> LogCompressor::compress<int16_t, uint8_t>(const shared_ptr<const Container<int16_t>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<uint8_t>> LogCompressor::compress<float, uint8_t>(const shared_ptr<const Container<float>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<uint8_t>> LogCompressor::compress<uint8_t, uint8_t>(const shared_ptr<const Container<uint8_t>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<float>> LogCompressor::compress<int16_t, float>(const shared_ptr<const Container<int16_t>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<float>> LogCompressor::compress<float, float>(const shared_ptr<const Container<float>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<float>> LogCompressor::compress<uint8_t, float>(const shared_ptr<const Container<uint8_t>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+}
\ No newline at end of file
diff --git a/oneapi/src/SupraLib/Beamformer/LogCompressor.h b/oneapi/src/SupraLib/Beamformer/LogCompressor.h
new file mode 100644
index 0000000..fe9481e
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/LogCompressor.h
@@ -0,0 +1,32 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __LOGCOMPRESSOR_H__
+#define __LOGCOMPRESSOR_H__
+
+#include "USImage.h"
+
+#include <memory>
+
+namespace supra
+{
+	class LogCompressor
+	{
+	public:
+		typedef float WorkType;
+
+		template<typename InputType, typename OutputType>
+		std::shared_ptr<Container<OutputType> >
+			compress(const std::shared_ptr<const Container<InputType> > & inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	};
+}
+
+#endif //!__LOGCOMPRESSOR_H__
diff --git a/oneapi/src/SupraLib/Beamformer/RxBeamformerCommon.h b/oneapi/src/SupraLib/Beamformer/RxBeamformerCommon.h
new file mode 100644
index 0000000..cb0eaa3
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxBeamformerCommon.h
@@ -0,0 +1,57 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __RXBEAMFORMERCOMMON_H__
+#define __RXBEAMFORMERCOMMON_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "WindowFunction.h"
+
+//TODO ALL ELEMENT/SCANLINE Y positons are actually Z! Change all variable names accordingly
+namespace supra
+{
+
+	template <typename T>
+	inline T computeAperture_D(T F, T z)
+	{
+		return z / (2 * F);
+	}
+
+	template <typename T>
+	inline T computeDelayDTSPACE_D(T dirX, T dirY, T dirZ, T x_element, T x, T z)
+	{
+		return sycl::sqrt((x_element - (x + dirX * z)) * (x_element - (x + dirX * z)) + (dirY * z) * (dirY * z)) + z;
+	}
+
+	template <typename T>
+	inline T computeDelayDTSPACE3D_D(T dirX, T dirY, T dirZ, T x_element, T z_element, T x, T z, T d)
+	{
+		return sycl::sqrt(squ(x_element - (x + dirX * d)) + squ(z_element - (z + dirZ * d)) + squ(dirY * d)) + d;
+	}
+
+	// distance has to be normalized to [-1, 1] (inclusive)
+	inline WindowFunctionGpu::ElementType
+		computeWindow3D(const WindowFunctionGpu& windowFunction, const vec2f& distance)
+	{
+		return sycl::sqrt(windowFunction.get(distance.x) * windowFunction.get(distance.y));
+	}
+
+
+	// distance has to be normalized to [-1, 1] (inclusive)
+	inline WindowFunctionGpu::ElementType
+		computeWindow3DShared(const WindowFunctionGpu& windowFunction, const WindowFunctionGpu::ElementType * __restrict__ sharedData, const vec2f& distance)
+	{
+		return sycl::sqrt(windowFunction.getShared(sharedData, distance.x) * windowFunction.getShared(sharedData, distance.y));
+	}
+}
+
+#endif //!__RXBEAMFORMERCOMMON_H__
\ No newline at end of file
diff --git a/oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp b/oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp
new file mode 100644
index 0000000..6fbf368
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp
@@ -0,0 +1,633 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "RxBeamformerCuda.h"
+#include "USImage.h"
+#include "USRawData.h"
+#include "RxSampleBeamformerDelayAndSum.h"
+#include "RxSampleBeamformerDelayAndStdDev.h"
+#include "RxSampleBeamformerTestSignal.h"
+#include "RxBeamformerCommon.h"
+#include "utilities/cudaUtility.h"
+
+//TODO ALL ELEMENT/SCANLINE Y positons are actually Z! Change all variable names accordingly
+namespace supra
+{
+	RxBeamformerCuda::RxBeamformerCuda(const RxBeamformerParameters & parameters)
+		: m_windowFunction(nullptr)
+	{
+		m_lastSeenDt = 0;
+		m_numRxScanlines = parameters.getNumRxScanlines();
+		m_rxScanlineLayout = parameters.getRxScanlineLayout();
+
+		m_is3D = (m_rxScanlineLayout.x > 1 && m_rxScanlineLayout.y > 1);
+		m_speedOfSoundMMperS = parameters.getSpeedOfSoundMMperS();
+		m_rxNumDepths = parameters.getRxNumDepths();
+
+		// create and fill new buffers
+		m_pRxDepths = std::unique_ptr<Container<LocationType>>(
+			new Container<LocationType>(LocationGpu, cudaStreamDefault, parameters.getRxDepths()));
+
+		m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D>>(
+			new Container<ScanlineRxParameters3D>(LocationGpu, cudaStreamDefault, parameters.getRxScanlines()));
+
+		m_pRxElementXs = std::unique_ptr<Container<LocationType>>(
+			new Container<LocationType>(LocationGpu, cudaStreamDefault, parameters.getRxElementXs()));
+		m_pRxElementYs = std::unique_ptr<Container<LocationType>>(
+			new Container<LocationType>(LocationGpu, cudaStreamDefault, parameters.getRxElementYs()));
+	}
+
+	RxBeamformerCuda::~RxBeamformerCuda()
+	{
+	}
+
+	void RxBeamformerCuda::convertToDtSpace(double dt, double speedOfSoundMMperS, size_t numTransducerElements) const
+	{
+		if (m_lastSeenDt != dt || m_speedOfSoundMMperS != speedOfSoundMMperS)
+		{
+			double oldFactor = 1;
+			double oldFactorTime = 1;
+			if (m_lastSeenDt != 0 && m_speedOfSoundMMperS != 0)
+			{
+				oldFactor = 1 / (m_speedOfSoundMMperS * m_lastSeenDt);
+				oldFactorTime = 1 / m_lastSeenDt;
+			}
+
+			double factor = 1 / oldFactor / (speedOfSoundMMperS * dt);
+			double factorTime = 1 / oldFactorTime / dt;
+
+			m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D>>(new Container<ScanlineRxParameters3D>(LocationHost, *m_pRxScanlines));
+			for (size_t i = 0; i < m_numRxScanlines; i++)
+			{
+				ScanlineRxParameters3D p = m_pRxScanlines->get()[i];
+				p.position = p.position*factor;
+				for (size_t k = 0; k < std::extent<decltype(p.txWeights)>::value; k++)
+				{
+					p.txParameters[k].initialDelay *= factorTime;
+				}
+				p.maxElementDistance = p.maxElementDistance*factor;
+				m_pRxScanlines->get()[i] = p;
+			}
+			m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D>>(new Container<ScanlineRxParameters3D>(LocationGpu, *m_pRxScanlines));
+
+			m_pRxDepths = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationHost, *m_pRxDepths));
+			for (size_t i = 0; i < m_rxNumDepths; i++)
+			{
+				m_pRxDepths->get()[i] = static_cast<LocationType>(m_pRxDepths->get()[i] * factor);
+			}
+			m_pRxDepths = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationGpu, *m_pRxDepths));
+
+			m_pRxElementXs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationHost, *m_pRxElementXs));
+			m_pRxElementYs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationHost, *m_pRxElementYs));
+			for (size_t i = 0; i < numTransducerElements; i++)
+			{
+				m_pRxElementXs->get()[i] = static_cast<LocationType>(m_pRxElementXs->get()[i] * factor);
+				m_pRxElementYs->get()[i] = static_cast<LocationType>(m_pRxElementYs->get()[i] * factor);
+			}
+			m_pRxElementXs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationGpu, *m_pRxElementXs));
+			m_pRxElementYs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationGpu, *m_pRxElementYs));
+
+			m_lastSeenDt = dt;
+			m_speedOfSoundMMperS = speedOfSoundMMperS;
+		}
+	}
+
+	template <class SampleBeamformer, bool interpolateRFlines, bool interpolateBetweenTransmits, unsigned int maxNumElements, unsigned int maxNumFunctionElements, typename RFType, typename ResultType, typename LocationType>
+	
+		void rxBeamformingDTSPACE3DKernel(
+			uint32_t numTransducerElements,
+			vec2T<uint32_t> elementLayout,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const RFType* __restrict__ RF,
+			uint32_t numTxScanlines,
+			uint32_t numRxScanlines,
+			const ScanlineRxParameters3D* __restrict__ scanlinesDT,
+			uint32_t numDs,
+			const LocationType* __restrict__ dsDT,
+			const LocationType* __restrict__ x_elemsDT,
+			const LocationType* __restrict__ z_elemsDT,
+			LocationType speedOfSound,
+			LocationType dt,
+			uint32_t additionalOffset,
+			LocationType F,
+			const WindowFunctionGpu windowFunction,
+			ResultType* __restrict__ s,
+			sycl::nd_item<3> item_ct1,
+			LocationType *x_elemsDTsh,
+			LocationType *z_elemsDTsh,
+			supra::WindowFunction::ElementType *functionShared)
+	{
+
+		//fetch element positions to shared memory
+		for (int threadId = (item_ct1.get_local_id(1) * item_ct1.get_local_range().get(2)) + item_ct1.get_local_id(2);	//@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+			 threadId < maxNumElements && threadId < numTransducerElements;
+			 threadId += item_ct1.get_local_range().get(2) * item_ct1.get_local_range().get(1))	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		{
+			x_elemsDTsh[threadId] = x_elemsDT[threadId];
+			z_elemsDTsh[threadId] = z_elemsDT[threadId];
+		}
+		for (int threadId = (item_ct1.get_local_id(1) * item_ct1.get_local_range().get(2)) + item_ct1.get_local_id(2);	//@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+			 threadId < maxNumFunctionElements && threadId < windowFunction.numElements();
+			 threadId += item_ct1.get_local_range().get(2) * item_ct1.get_local_range().get(1))	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		{
+			functionShared[threadId] = windowFunction.getDirect(threadId);
+		}
+		item_ct1.barrier();	 //@suppress("Function cannot be resolved")
+
+		int r = item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1);			 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		int scanlineIdx = item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2);	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+
+		if (r < numDs && scanlineIdx < numRxScanlines)
+		{
+			LocationType d = dsDT[r];
+			//TODO should this also depend on the angle?
+			LocationType aDT = squ(computeAperture_D(F, d*dt*speedOfSound) / speedOfSound / dt);
+			ScanlineRxParameters3D scanline = scanlinesDT[scanlineIdx];
+
+			LocationType scanline_x = scanline.position.x;
+			LocationType scanline_z = scanline.position.z;
+			LocationType dirX = scanline.direction.x;
+			LocationType dirY = scanline.direction.y;
+			LocationType dirZ = scanline.direction.z;
+			vec2f maxElementDistance = static_cast<vec2f>(scanline.maxElementDistance);
+			vec2f		 invMaxElementDistance = vec2f{ 1.0f, 1.0f } / min(vec2f{ sycl::sqrt(aDT), sycl::sqrt(aDT) }, maxElementDistance);
+
+			float sInterp = 0.0f;
+
+			int highestWeightIndex;
+			if (!interpolateBetweenTransmits)
+			{
+				highestWeightIndex = 0;
+				float highestWeight = scanline.txWeights[0];
+				for (int k = 1; k < std::extent<decltype(scanline.txWeights)>::value; k++)
+				{
+					if (scanline.txWeights[k] > highestWeight)
+					{
+						highestWeight = scanline.txWeights[k];
+						highestWeightIndex = k;
+					}
+				}
+			}
+
+			// now iterate over all four txScanlines to interpolate beamformed scanlines from those transmits
+			for (int k = (interpolateBetweenTransmits ? 0 : highestWeightIndex);
+				(interpolateBetweenTransmits && k < std::extent<decltype(scanline.txWeights)>::value) ||
+				(!interpolateBetweenTransmits && k == highestWeightIndex);
+				k++)
+			{
+				if (scanline.txWeights[k] > 0.0)
+				{
+					ScanlineRxParameters3D::TransmitParameters txParams = scanline.txParameters[k];
+					uint32_t txScanlineIdx = txParams.txScanlineIdx;
+					if (txScanlineIdx >= numTxScanlines)
+					{
+						//ERROR!
+						return;
+					}
+					float sLocal = 0.0f;
+					
+					sLocal = SampleBeamformer::template sampleBeamform3D<interpolateRFlines, RFType, float, LocationType>(
+						txParams, RF, elementLayout, numReceivedChannels, numTimesteps,
+						x_elemsDTsh, z_elemsDTsh, scanline_x, scanline_z, dirX, dirY, dirZ,
+						aDT, d, invMaxElementDistance, speedOfSound, dt, additionalOffset, &windowFunction, functionShared);
+
+					if (interpolateBetweenTransmits)
+					{
+						sInterp += static_cast<float>(scanline.txWeights[k])* sLocal;
+					}
+					else
+					{
+						sInterp += sLocal;
+					}
+				}
+			}
+			s[scanlineIdx + r * numRxScanlines] = clampCast<ResultType>(sInterp);
+		}
+	}
+
+	template <class SampleBeamformer, bool interpolateRFlines, bool interpolateBetweenTransmits, typename RFType, typename ResultType, typename LocationType>
+	
+		void rxBeamformingDTSPACEKernel(
+			size_t numTransducerElements,
+			size_t numReceivedChannels,
+			size_t numTimesteps,
+			const RFType* __restrict__ RF,
+			size_t numTxScanlines,
+			size_t numRxScanlines,
+			const ScanlineRxParameters3D* __restrict__ scanlinesDT,
+			size_t numDs,
+			const LocationType* __restrict__ dsDT,
+			const LocationType* __restrict__ x_elemsDT,
+			LocationType speedOfSound,
+			LocationType dt,
+			uint32_t additionalOffset,
+			LocationType F,
+			const WindowFunctionGpu windowFunction,
+			ResultType* __restrict__ s,
+			sycl::nd_item<3> item_ct1)
+	{
+		int r = item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1);			 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		int scanlineIdx = item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2);	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		if (r < numDs && scanlineIdx < numRxScanlines)
+		{
+			LocationType d = dsDT[r];
+			//TODO should this also depend on the angle?
+			LocationType aDT = computeAperture_D(F, d*dt*speedOfSound) / speedOfSound / dt;
+			ScanlineRxParameters3D scanline = scanlinesDT[scanlineIdx];
+			LocationType scanline_x = scanline.position.x;
+			LocationType dirX = scanline.direction.x;
+			LocationType dirY = scanline.direction.y;
+			LocationType dirZ = scanline.direction.z;
+			LocationType maxElementDistance = static_cast<LocationType>(scanline.maxElementDistance.x);
+			LocationType		   invMaxElementDistance = 1 / sycl::min(aDT, maxElementDistance);
+
+			float sInterp = 0.0f;
+
+			int highestWeightIndex;
+			if (!interpolateBetweenTransmits)
+			{
+				highestWeightIndex = 0;
+				float highestWeight = scanline.txWeights[0];
+				for (int k = 1; k < std::extent<decltype(scanline.txWeights)>::value; k++)
+				{
+					if (scanline.txWeights[k] > highestWeight)
+					{
+						highestWeight = scanline.txWeights[k];
+						highestWeightIndex = k;
+					}
+				}
+			}
+
+			// now iterate over all four txScanlines to interpolate beamformed scanlines from those transmits
+			for (int k = (interpolateBetweenTransmits ? 0 : highestWeightIndex);
+				(interpolateBetweenTransmits && k < std::extent<decltype(scanline.txWeights)>::value) ||
+				(!interpolateBetweenTransmits && k == highestWeightIndex);
+				k++)
+			{
+				if (scanline.txWeights[k] > 0.0)
+				{
+					ScanlineRxParameters3D::TransmitParameters txParams = scanline.txParameters[k];
+					uint32_t txScanlineIdx = txParams.txScanlineIdx;
+					if (txScanlineIdx >= numTxScanlines)
+					{
+						//ERROR!
+						return;
+					}
+
+					float sLocal = 0.0f;
+					sLocal = SampleBeamformer::template sampleBeamform2D<interpolateRFlines, RFType, float, LocationType>(
+						txParams, RF, numTransducerElements, numReceivedChannels, numTimesteps,
+						x_elemsDT, scanline_x, dirX, dirY, dirZ,
+						aDT, d, invMaxElementDistance, speedOfSound, dt, additionalOffset, &windowFunction);
+
+					if (interpolateBetweenTransmits)
+					{
+						sInterp += static_cast<float>(scanline.txWeights[k])* sLocal;
+					}
+					else
+					{
+						sInterp += sLocal;
+					}
+				}
+			}
+			s[scanlineIdx + r * numRxScanlines] = clampCast<ResultType>(sInterp);
+		}
+	}
+
+	template <class SampleBeamformer, unsigned int maxWindowFunctionNumel, typename RFType, typename ResultType, typename LocationType>
+	void rxBeamformingDTspaceCuda3D(bool interpolateRFlines, bool interpolateBetweenTransmits, size_t numTransducerElements, vec2s elementLayout, size_t numReceivedChannels, size_t numTimesteps,
+									const RFType* RF, size_t numTxScanlines, size_t numRxScanlines, const ScanlineRxParameters3D* scanlines, size_t numZs, const LocationType* zs,
+									const LocationType* x_elems, const LocationType* y_elems, LocationType speedOfSound, LocationType dt, uint32_t additionalOffset, LocationType F,
+									const WindowFunctionGpu windowFunction, sycl::queue* stream, ResultType* s)
+	{
+		sycl::range<3> blockSize(1, 256, 1);
+		sycl::range<3> gridSize(static_cast<unsigned int>((numRxScanlines + blockSize.x - 1) / blockSize.x), static_cast<unsigned int>((numZs + blockSize.y - 1) / blockSize.y), 1);
+
+		if (interpolateRFlines)
+		{
+			if (interpolateBetweenTransmits)
+			{
+				stream->submit([ & ](sycl::handler& cgh) {
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   x_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   z_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<supra::WindowFunction::ElementType, 1, sycl::access::mode::read_write, sycl::access::target::local> functionShared_acc_ct1(sycl::range<1>(maxWindowFunctionNumel),
+																																							  cgh);
+
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACE3DKernel<SampleBeamformer, true, true, 1024, maxWindowFunctionNumel>(
+											 ( uint32_t )numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout), ( uint32_t )numReceivedChannels, ( uint32_t )numTimesteps, RF,
+											 ( uint32_t )numTxScanlines, ( uint32_t )numRxScanlines, scanlines, ( uint32_t )numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F,
+											 windowFunction, s, item_ct1, x_elemsDTsh_acc_ct1.get_pointer(), z_elemsDTsh_acc_ct1.get_pointer(), functionShared_acc_ct1.get_pointer());
+									 });
+				});
+			}
+			else {
+				stream->submit([ & ](sycl::handler& cgh) {
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   x_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   z_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<supra::WindowFunction::ElementType, 1, sycl::access::mode::read_write, sycl::access::target::local> functionShared_acc_ct1(sycl::range<1>(maxWindowFunctionNumel),
+																																							  cgh);
+
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACE3DKernel<SampleBeamformer, true, false, 1024, maxWindowFunctionNumel>(
+											 ( uint32_t )numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout), ( uint32_t )numReceivedChannels, ( uint32_t )numTimesteps, RF,
+											 ( uint32_t )numTxScanlines, ( uint32_t )numRxScanlines, scanlines, ( uint32_t )numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F,
+											 windowFunction, s, item_ct1, x_elemsDTsh_acc_ct1.get_pointer(), z_elemsDTsh_acc_ct1.get_pointer(), functionShared_acc_ct1.get_pointer());
+									 });
+				});
+			}
+		}
+		else {
+			if (interpolateBetweenTransmits)
+			{
+				stream->submit([ & ](sycl::handler& cgh) {
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   x_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   z_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<supra::WindowFunction::ElementType, 1, sycl::access::mode::read_write, sycl::access::target::local> functionShared_acc_ct1(sycl::range<1>(maxWindowFunctionNumel),
+																																							  cgh);
+
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACE3DKernel<SampleBeamformer, false, true, 1024, maxWindowFunctionNumel>(
+											 ( uint32_t )numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout), ( uint32_t )numReceivedChannels, ( uint32_t )numTimesteps, RF,
+											 ( uint32_t )numTxScanlines, ( uint32_t )numRxScanlines, scanlines, ( uint32_t )numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F,
+											 windowFunction, s, item_ct1, x_elemsDTsh_acc_ct1.get_pointer(), z_elemsDTsh_acc_ct1.get_pointer(), functionShared_acc_ct1.get_pointer());
+									 });
+				});
+			}
+			else {
+				stream->submit([ & ](sycl::handler& cgh) {
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   x_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   z_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<supra::WindowFunction::ElementType, 1, sycl::access::mode::read_write, sycl::access::target::local> functionShared_acc_ct1(sycl::range<1>(maxWindowFunctionNumel),
+																																							  cgh);
+
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACE3DKernel<SampleBeamformer, false, false, 1024, maxWindowFunctionNumel>(
+											 ( uint32_t )numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout), ( uint32_t )numReceivedChannels, ( uint32_t )numTimesteps, RF,
+											 ( uint32_t )numTxScanlines, ( uint32_t )numRxScanlines, scanlines, ( uint32_t )numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F,
+											 windowFunction, s, item_ct1, x_elemsDTsh_acc_ct1.get_pointer(), z_elemsDTsh_acc_ct1.get_pointer(), functionShared_acc_ct1.get_pointer());
+									 });
+				});
+			}
+		}
+		/*
+		DPCT1010:34: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+	}
+
+	template <class SampleBeamformer, typename RFType, typename ResultType, typename LocationType>
+	void rxBeamformingDTspaceCuda(bool interpolateRFlines, bool interpolateBetweenTransmits, size_t numTransducerElements, size_t numReceivedChannels, size_t numTimesteps, const RFType* RF,
+								  size_t numTxScanlines, size_t numRxScanlines, const ScanlineRxParameters3D* scanlines, size_t numZs, const LocationType* zs, const LocationType* x_elems,
+								  LocationType speedOfSound, LocationType dt, uint32_t additionalOffset, LocationType F, const WindowFunctionGpu windowFunction, sycl::queue* stream, ResultType* s)
+	{
+		sycl::range<3> blockSize(1, 256, 1);
+		sycl::range<3> gridSize(static_cast<unsigned int>((numRxScanlines + blockSize.x - 1) / blockSize.x), static_cast<unsigned int>((numZs + blockSize.y - 1) / blockSize.y), 1);
+		if (interpolateRFlines)
+		{
+			if (interpolateBetweenTransmits)
+			{
+				stream->submit([ & ](sycl::handler& cgh) {
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACEKernel<SampleBeamformer, true, true>(numTransducerElements, numReceivedChannels, numTimesteps, RF, numTxScanlines, numRxScanlines,
+																								  scanlines, numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s, item_ct1);
+									 });
+				});
+			}
+			else {
+				stream->submit([ & ](sycl::handler& cgh) {
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACEKernel<SampleBeamformer, true, false>(numTransducerElements, numReceivedChannels, numTimesteps, RF, numTxScanlines, numRxScanlines,
+																								   scanlines, numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s, item_ct1);
+									 });
+				});
+			}
+		}
+		else {
+			if (interpolateBetweenTransmits)
+			{
+				stream->submit([ & ](sycl::handler& cgh) {
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACEKernel<SampleBeamformer, false, true>(numTransducerElements, numReceivedChannels, numTimesteps, RF, numTxScanlines, numRxScanlines,
+																								   scanlines, numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s, item_ct1);
+									 });
+				});
+			}
+			else {
+				stream->submit([ & ](sycl::handler& cgh) {
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACEKernel<SampleBeamformer, false, false>(numTransducerElements, numReceivedChannels, numTimesteps, RF, numTxScanlines, numRxScanlines,
+																									scanlines, numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s, item_ct1);
+									 });
+				});
+			}
+		}
+		/*
+		DPCT1010:35: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+	}
+
+	template <typename ChannelDataType, typename ImageDataType>
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const
+	{
+		//Ensure the raw-data are on the gpu
+		auto gRawData = rawData->getData<ChannelDataType>();
+		if (!gRawData->isGPU() && !gRawData->isBoth())
+		{
+			gRawData = std::make_shared<Container<ChannelDataType>>(LocationGpu, *gRawData);
+		}
+
+		size_t numelOut = m_numRxScanlines*m_rxNumDepths;
+		shared_ptr<Container<ImageDataType>> pData = std::make_shared<Container<ImageDataType>>(ContainerLocation::LocationGpu, gRawData->getStream(), numelOut);
+
+		double dt = 1.0 / rawData->getSamplingFrequency();
+
+		if (!m_windowFunction || m_windowFunction->getType() != windowType || m_windowFunction->getParameter() != windowParameter)
+		{
+			m_windowFunction = std::unique_ptr<WindowFunction>(new WindowFunction(windowType, windowParameter, m_windowFunctionNumEntries));
+		}
+
+		auto beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndSum, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+		auto beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndSum, ChannelDataType, ImageDataType, LocationType>;
+		switch (sampleBeamformer)
+		{
+		case DelayAndSum:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndSum, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndSum, ChannelDataType, ImageDataType, LocationType>;
+			break;
+		case DelayAndStdDev:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndStdDev, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndStdDev, ChannelDataType, ImageDataType, LocationType>;
+			break;
+		case TestSignal:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerTestSignal, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerTestSignal, ChannelDataType, ImageDataType, LocationType>;
+			break;
+		case INVALID:
+		default:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndSum, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndSum, ChannelDataType, ImageDataType, LocationType>;
+		}
+
+
+		convertToDtSpace(dt, speedOfSoundMMperS, rawData->getNumElements());
+		if (m_is3D)
+		{
+			beamformingFunction3D(
+				true,
+				interpolateBetweenTransmits,
+				rawData->getNumElements(),
+				rawData->getElementLayout(),
+				rawData->getNumReceivedChannels(),
+				rawData->getNumSamples(),
+				gRawData->get(),
+				rawData->getNumScanlines(), // numTxScanlines
+				m_numRxScanlines,			// numRxScanlines
+				m_pRxScanlines->get(),
+				m_rxNumDepths, m_pRxDepths->get(),
+				m_pRxElementXs->get(),
+				m_pRxElementYs->get(),
+				static_cast<LocationType>(m_speedOfSoundMMperS),
+				static_cast<LocationType>(dt),
+				additionalOffset,
+				static_cast<LocationType>(fNumber),
+				*(m_windowFunction->getGpu()),
+				gRawData->getStream(),
+				pData->get()
+				);
+		}
+		else {
+			beamformingFunction2D(
+				true,
+				interpolateBetweenTransmits,
+				rawData->getNumElements(),
+				rawData->getNumReceivedChannels(),
+				rawData->getNumSamples(),
+				gRawData->get(),
+				rawData->getNumScanlines(), // numTxScanlines
+				m_numRxScanlines,			// numRxScanlines
+				m_pRxScanlines->get(),
+				m_rxNumDepths, m_pRxDepths->get(),
+				m_pRxElementXs->get(),
+				static_cast<LocationType>(m_speedOfSoundMMperS),
+				static_cast<LocationType>(dt),
+				additionalOffset,
+				static_cast<LocationType>(fNumber),
+				*(m_windowFunction->getGpu()),
+				gRawData->getStream(),
+				pData->get()
+				);
+		}
+
+		if (rawData->getImageProperties() != m_lastSeenImageProperties)
+		{
+			m_lastSeenImageProperties = rawData->getImageProperties();
+			shared_ptr<USImageProperties> newProps = std::make_shared<USImageProperties>(*m_lastSeenImageProperties);
+			newProps->setScanlineLayout(m_rxScanlineLayout);
+			newProps->setNumSamples(m_rxNumDepths);
+			newProps->setImageState(USImageProperties::RF);
+			m_editedImageProperties = std::const_pointer_cast<const USImageProperties>(newProps);
+		}
+
+		auto retImage = std::make_shared<USImage>(
+			vec2s{ m_numRxScanlines, m_rxNumDepths },
+			pData,
+			m_editedImageProperties,
+			rawData->getReceiveTimestamp(),
+			rawData->getSyncTimestamp());
+
+		return retImage;
+	}
+
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<int16_t, int16_t>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<int16_t, float>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<float, int16_t>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<float, float>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+}
\ No newline at end of file
diff --git a/oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.h b/oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.h
new file mode 100644
index 0000000..5d9f3cf
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxBeamformerCuda.h
@@ -0,0 +1,81 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __RXBEAMFORMERCUDA_H__
+#define __RXBEAMFORMERCUDA_H__
+
+#include "USImage.h"
+#include "WindowFunction.h"
+#include "RxBeamformerParameters.h"
+
+#include <memory>
+
+namespace supra
+{
+	struct ScanlineRxParameters3D;
+	class USRawData;
+
+	using std::shared_ptr;
+
+	class RxBeamformerCuda
+	{
+	public:
+		enum RxSampleBeamformer {
+			DelayAndSum,
+			DelayAndStdDev,
+			TestSignal,
+			INVALID
+		};
+
+		RxBeamformerCuda(const RxBeamformerParameters& parameters);
+		~RxBeamformerCuda();
+
+		// perform the receive beamforming
+		template <typename ChannelDataType, typename ImageDataType>
+		shared_ptr<USImage> performRxBeamforming(
+			RxSampleBeamformer sampleBeamformer,
+			shared_ptr<const USRawData> rawData,
+			double fNumber,
+			double speedOfSoundMMperS,
+			WindowType windowType,
+			WindowFunction::ElementType windowParameters,
+			bool interpolateBetweenTransmits,
+			int32_t additionalOffset) const;
+
+	private:
+		typedef RxBeamformerParameters::LocationType LocationType;
+
+		void convertToDtSpace(double dt, double speedOfSoundMMperS, size_t numTransducerElements) const;
+
+		// Imaging parameters
+		size_t m_numRxScanlines;
+		vec2s m_rxScanlineLayout;
+
+		// prepared Rx parameters
+		mutable std::unique_ptr<Container<LocationType> > m_pRxDepths;
+		mutable std::unique_ptr<Container<ScanlineRxParameters3D> > m_pRxScanlines;
+		mutable std::unique_ptr<Container<LocationType> > m_pRxElementXs;
+		mutable std::unique_ptr<Container<LocationType> > m_pRxElementYs;
+		size_t m_rxNumDepths;
+
+		mutable double m_speedOfSoundMMperS;
+		mutable double m_lastSeenDt;
+		mutable shared_ptr<const USImageProperties> m_lastSeenImageProperties;
+		mutable shared_ptr<const USImageProperties> m_editedImageProperties;
+
+		bool m_is3D;
+
+		static constexpr size_t m_windowFunctionNumEntries = 64;
+		mutable std::unique_ptr<WindowFunction> m_windowFunction;
+	};
+}
+
+#endif //!__RXBEAMFORMERCUDA_H__
diff --git a/oneapi/src/SupraLib/Beamformer/RxBeamformerParameters.h b/oneapi/src/SupraLib/Beamformer/RxBeamformerParameters.h
new file mode 100644
index 0000000..cf17ab3
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxBeamformerParameters.h
@@ -0,0 +1,109 @@
+// ================================================================================================
+// 
+// Copyright (C) 2017, Rüdiger Göbl - all rights reserved
+// Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.
+//
+//          Rüdiger Göbl
+//          Email r.goebl@tum.de
+//          Chair for Computer Aided Medical Procedures
+//          Technische Universität München
+//          Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License, version 2.1, as published by the Free Software Foundation.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this program.  If not, see
+// <http://www.gnu.org/licenses/>.
+//
+// ================================================================================================
+
+#ifndef __RXBEAMFORMERPARAMETERS_H__
+#define __RXBEAMFORMERPARAMETERS_H__
+
+#include "USTransducer.h"
+#include <memory>
+
+namespace supra
+{
+	struct ScanlineRxParameters3D;
+	class USRawData;
+
+	class RxBeamformerParameters
+	{
+	public:
+		typedef float LocationType;
+
+		RxBeamformerParameters(
+			std::shared_ptr<std::vector<std::vector<ScanlineRxParameters3D> > > rxParameters,
+			size_t numDepths,
+			double depth,
+			double speedOfSoundMMperS,
+			const USTransducer* pTransducer);
+
+		RxBeamformerParameters(
+			size_t numRxScanlines,
+			vec2s rxScanlineLayout,
+			double speedOfSoundMMperS,
+			const std::vector<LocationType> & rxDepths,
+			const std::vector<ScanlineRxParameters3D> & rxScanlines,
+			const std::vector<LocationType> & rxElementXs,
+			const std::vector<LocationType> & rxElementYs,
+			size_t rxNumDepths)
+			: m_rxScanlineLayout(rxScanlineLayout)
+			, m_numRxScanlines(numRxScanlines)
+			, m_speedOfSoundMMperS(speedOfSoundMMperS)
+			, m_rxNumDepths(rxNumDepths)
+			, m_rxDepths(rxDepths)
+			, m_rxScanlines(rxScanlines)
+			, m_rxElementXs(rxElementXs)
+			, m_rxElementYs(rxElementYs) {};
+
+		size_t getNumRxScanlines() const { return m_numRxScanlines; }
+		vec2s getRxScanlineLayout() const { return m_rxScanlineLayout; }
+		double getSpeedOfSoundMMperS() const { return m_speedOfSoundMMperS; }
+		const std::vector<LocationType> & getRxDepths() const { return m_rxDepths; }
+		const std::vector<ScanlineRxParameters3D> & getRxScanlines() const { return m_rxScanlines; }
+		const std::vector<LocationType> & getRxElementXs() const { return m_rxElementXs; }
+		const std::vector<LocationType> & getRxElementYs() const { return m_rxElementYs; }
+		size_t getRxNumDepths() const { return m_rxNumDepths; }
+
+
+		bool operator== (const RxBeamformerParameters& b) const
+		{
+			return
+				m_numRxScanlines == b.m_numRxScanlines &&
+				m_rxScanlineLayout == b.m_rxScanlineLayout &&
+				m_speedOfSoundMMperS == b.m_speedOfSoundMMperS &&
+				m_rxDepths == b.m_rxDepths &&
+				m_rxScanlines == b.m_rxScanlines &&
+				m_rxElementXs == b.m_rxElementXs &&
+				m_rxElementYs == b.m_rxElementYs &&
+				m_rxNumDepths == b.m_rxNumDepths;
+		}
+
+		void writeMetaDataForMock(std::string filename, std::shared_ptr<const USRawData> rawData) const;
+		static std::shared_ptr<USRawData> readMetaDataForMock(const std::string & mockMetadataFilename);
+		static std::shared_ptr<USRawData> readMetaDataForMockAscii(const std::string & mockAsciiMetadataFilename);
+		static std::shared_ptr<USRawData> readMetaDataForMockJson(const std::string & mockJsonMetadataFilename);
+		
+	private:
+
+		size_t m_numRxScanlines;
+		vec2s m_rxScanlineLayout;
+		double m_speedOfSoundMMperS;
+		std::vector<LocationType> m_rxDepths;
+		std::vector<ScanlineRxParameters3D> m_rxScanlines;
+		std::vector<LocationType> m_rxElementXs;
+		std::vector<LocationType> m_rxElementYs;
+		size_t m_rxNumDepths;
+	};
+}
+
+#endif //!__RXBEAMFORMERPARAMETERS_H__
diff --git a/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h
new file mode 100644
index 0000000..36f1226
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h
@@ -0,0 +1,244 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2017, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __RXSAMPLEBEAMFORMERDELAYANDSTDDEV_H__
+#define __RXSAMPLEBEAMFORMERDELAYANDSTDDEV_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "USImageProperties.h"
+#include "WindowFunction.h"
+#include "RxBeamformerCommon.h"
+
+#include "RxSampleBeamformerDelayAndSum.h"
+
+// Beamformer accoring to
+//
+// R.S.Bandaru, A.R.Sornes, J.Hermans, E.Samset, and J.D’Hooge, 
+// “Delay and Standard Deviation Beamforming to Enhance Specular Reflections in Ultrasound Imaging,”
+// IEEE Trans.Ultrason.Ferroelectr.Freq.Control, vol. 63, no. 12, 2016.
+//
+// with the modification of calculating the std dev for the real channel data, 
+// instead of IQ as proposed in the article.
+
+//TODO ALL ELEMENT/SCANLINE Y positons are actually Z! Change all variable names accordingly
+namespace supra
+{
+	class RxSampleBeamformerDelayAndStdDev
+	{
+	public:
+		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
+		static ResultType sampleBeamform3D(
+			ScanlineRxParameters3D::TransmitParameters txParams,
+			const RFType* RF,
+			vec2T<uint32_t> elementLayout,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const LocationType* x_elemsDTsh,
+			const LocationType* z_elemsDTsh,
+			LocationType scanline_x,
+			LocationType scanline_z,
+			LocationType dirX,
+			LocationType dirY,
+			LocationType dirZ,
+			LocationType aDT,
+			LocationType depth,
+			vec2f invMaxElementDistance,
+			LocationType speedOfSound,
+			LocationType dt,
+			int32_t additionalOffset,
+			const WindowFunctionGpu* windowFunction,
+			const WindowFunction::ElementType* functionShared
+		)
+		{
+			float value = 0.0f;
+			float sd = 0.0f;
+			float weightAcum = 0.0f;
+			int numAdds = 0;
+			LocationType initialDelay = txParams.initialDelay;
+			uint32_t txScanlineIdx = txParams.txScanlineIdx;
+
+			ResultType mean = RxSampleBeamformerDelayAndSum::sampleBeamform3D<interpolateRFlines, RFType, ResultType, LocationType>(
+				txParams,
+				RF,
+				elementLayout,
+				numReceivedChannels,
+				numTimesteps,
+				x_elemsDTsh,
+				z_elemsDTsh,
+				scanline_x,
+				scanline_z,
+				dirX,
+				dirY,
+				dirZ,
+				aDT,
+				depth,
+				invMaxElementDistance,
+				speedOfSound,
+				dt,
+				additionalOffset,
+				windowFunction,
+				functionShared);
+
+			for (uint32_t elemIdxX = txParams.firstActiveElementIndex.x; elemIdxX < txParams.lastActiveElementIndex.x; elemIdxX++)
+			{
+				for (uint32_t elemIdxY = txParams.firstActiveElementIndex.y; elemIdxY < txParams.lastActiveElementIndex.y; elemIdxY++)
+				{
+					uint32_t elemIdx = elemIdxX + elemIdxY*elementLayout.x;
+					uint32_t  channelIdx = elemIdx % numReceivedChannels;
+					LocationType x_elem = x_elemsDTsh[elemIdx];
+					LocationType z_elem = z_elemsDTsh[elemIdx];
+
+					if ((squ(x_elem - scanline_x) + squ(z_elem - scanline_z)) <= aDT)
+					{
+						vec2f elementScanlineDistance = { x_elem - scanline_x, z_elem - scanline_z };
+						float weight = computeWindow3DShared(*windowFunction, functionShared, elementScanlineDistance * invMaxElementDistance);
+						weightAcum += weight;
+						numAdds++;
+						if (interpolateRFlines)
+						{
+							LocationType delayf = initialDelay +
+								computeDelayDTSPACE3D_D(dirX, dirY, dirZ, x_elem, z_elem, scanline_x, scanline_z, depth) + additionalOffset;
+							uint32_t delay = static_cast<uint32_t>(sycl::floor(delayf));
+							delayf -= delay;
+							if (delay < (numTimesteps - 1))
+							{
+								value = 
+									weight * ((1.0f - delayf) * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps] +
+										delayf  * RF[(delay + 1) + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps]);
+							}
+							else if (delay < numTimesteps && delayf == 0.0)
+							{
+								value = weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+							}
+						}
+						else
+						{
+							uint32_t delay =
+								static_cast<uint32_t>(sycl::round(initialDelay + computeDelayDTSPACE3D_D(dirX, dirY, dirZ, x_elem, z_elem, scanline_x, scanline_z, depth)) + additionalOffset);
+							if (delay < numTimesteps)
+							{
+								value = weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+							}
+						}
+
+						sd += squ(value - mean);
+					}
+				}
+			}
+			if (numAdds > 0)
+			{
+				return sycl::sqrt(sd) / weightAcum * numAdds;
+			}
+			else
+			{
+				return 0;
+			}
+		}
+
+		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
+		static ResultType sampleBeamform2D(
+			ScanlineRxParameters3D::TransmitParameters txParams,
+			const RFType* RF,
+			uint32_t numTransducerElements,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const LocationType* x_elemsDT,
+			LocationType scanline_x,
+			LocationType dirX,
+			LocationType dirY,
+			LocationType dirZ,
+			LocationType aDT,
+			LocationType depth,
+			LocationType invMaxElementDistance,
+			LocationType speedOfSound,
+			LocationType dt,
+			int32_t additionalOffset,
+			const WindowFunctionGpu* windowFunction
+		)
+		{
+			float value = 0.0f;
+			float sd = 0.0f;
+			float weightAcum = 0.0f;
+			int numAdds = 0;
+			LocationType initialDelay = txParams.initialDelay;
+			uint32_t txScanlineIdx = txParams.txScanlineIdx;
+
+			ResultType mean = RxSampleBeamformerDelayAndSum::sampleBeamform2D<interpolateRFlines, RFType, ResultType, LocationType>(
+				txParams,
+				RF,
+				numTransducerElements,
+				numReceivedChannels,
+				numTimesteps,
+				x_elemsDT,
+				scanline_x,
+				dirX,
+				dirY,
+				dirZ,
+				aDT,
+				depth,
+				invMaxElementDistance,
+				speedOfSound,
+				dt,
+				additionalOffset,
+				windowFunction);
+
+			for (int32_t elemIdxX = txParams.firstActiveElementIndex.x; elemIdxX < txParams.lastActiveElementIndex.x; elemIdxX++)
+			{
+				int32_t  channelIdx = elemIdxX % numReceivedChannels;
+				LocationType x_elem = x_elemsDT[elemIdxX];
+				if (sycl::fabs(x_elem - scanline_x) <= aDT)
+				{
+					float weight = windowFunction->get((x_elem - scanline_x) * invMaxElementDistance);
+					weightAcum += weight;
+					numAdds++;
+					if (interpolateRFlines)
+					{
+						LocationType delayf = initialDelay +
+							computeDelayDTSPACE_D(dirX, dirY, dirZ, x_elem, scanline_x, depth) + additionalOffset;
+						int32_t delay = static_cast<int32_t>(sycl::floor(delayf));
+						delayf -= delay;
+						if (delay < (numTimesteps - 1))
+						{
+							value =
+								weight * ((1.0f - delayf) * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps] +
+									delayf  * RF[(delay + 1) + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps]);
+						}
+						else if (delay < numTimesteps && delayf == 0.0)
+						{
+							value = weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+						}
+					}
+					else
+					{
+						int32_t delay = static_cast<int32_t>(sycl::round(initialDelay + computeDelayDTSPACE_D(dirX, dirY, dirZ, x_elem, scanline_x, depth)) + additionalOffset);
+						if (delay < numTimesteps)
+						{
+							value = weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+						}
+					}
+
+					sd += squ(value - mean);
+				}
+			}
+			if (numAdds > 0)
+			{
+				return sycl::sqrt(sd) / weightAcum * numAdds;
+			}
+			else
+			{
+				return 0;
+			}
+		}
+	};
+}
+
+#endif //!__RXSAMPLEBEAMFORMERDELAYANDSTDDEV_H__
diff --git a/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h
new file mode 100644
index 0000000..26c8b00
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h
@@ -0,0 +1,185 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2017, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __RXSAMPLEBEAMFORMERDELAYANDSUM_H__
+#define __RXSAMPLEBEAMFORMERDELAYANDSUM_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "USImageProperties.h"
+#include "WindowFunction.h"
+#include "RxBeamformerCommon.h"
+
+//TODO ALL ELEMENT/SCANLINE Y positons are actually Z! Change all variable names accordingly
+namespace supra
+{
+	class RxSampleBeamformerDelayAndSum
+	{
+	public:
+		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
+		static ResultType sampleBeamform3D(
+			ScanlineRxParameters3D::TransmitParameters txParams,
+			const RFType* RF,
+			vec2T<uint32_t> elementLayout,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const LocationType* x_elemsDTsh,
+			const LocationType* z_elemsDTsh,
+			LocationType scanline_x,
+			LocationType scanline_z,
+			LocationType dirX,
+			LocationType dirY,
+			LocationType dirZ,
+			LocationType aDT,
+			LocationType depth,
+			vec2f invMaxElementDistance,
+			LocationType speedOfSound,
+			LocationType dt,
+			int32_t additionalOffset,
+			const WindowFunctionGpu* windowFunction,
+			const WindowFunction::ElementType* functionShared
+		)
+		{
+			float sample = 0.0f;
+			float weightAcum = 0.0f;
+			int numAdds = 0;
+			LocationType initialDelay = txParams.initialDelay;
+			uint32_t txScanlineIdx = txParams.txScanlineIdx;
+			for (uint32_t elemIdxX = txParams.firstActiveElementIndex.x; elemIdxX < txParams.lastActiveElementIndex.x; elemIdxX++)
+			{
+				for (uint32_t elemIdxY = txParams.firstActiveElementIndex.y; elemIdxY < txParams.lastActiveElementIndex.y; elemIdxY++)
+				{
+					uint32_t elemIdx = elemIdxX + elemIdxY*elementLayout.x;
+					uint32_t  channelIdx = elemIdx % numReceivedChannels;
+					LocationType x_elem = x_elemsDTsh[elemIdx];
+					LocationType z_elem = z_elemsDTsh[elemIdx];
+
+					if ((squ(x_elem - scanline_x) + squ(z_elem - scanline_z)) <= aDT)
+					{
+						vec2f elementScanlineDistance = { x_elem - scanline_x, z_elem - scanline_z };
+						float weight = computeWindow3DShared(*windowFunction, functionShared, elementScanlineDistance * invMaxElementDistance);
+						weightAcum += weight;
+						numAdds++;
+						if (interpolateRFlines)
+						{
+							LocationType delayf = initialDelay +
+								computeDelayDTSPACE3D_D(dirX, dirY, dirZ, x_elem, z_elem, scanline_x, scanline_z, depth) + additionalOffset;
+							uint32_t delay = static_cast<uint32_t>(sycl::floor(delayf));
+							delayf -= delay;
+							if (delay < (numTimesteps - 1))
+							{
+								sample +=
+									weight * ((1.0f - delayf) * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps] +
+										delayf  * RF[(delay + 1) + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps]);
+							}
+							else if (delay < numTimesteps && delayf == 0.0)
+							{
+								sample += weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+							}
+						}
+						else
+						{
+							uint32_t delay =
+								static_cast<uint32_t>(sycl::round(initialDelay + computeDelayDTSPACE3D_D(dirX, dirY, dirZ, x_elem, z_elem, scanline_x, scanline_z, depth)) + additionalOffset);
+							if (delay < numTimesteps)
+							{
+								sample += weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+							}
+						}
+					}
+				}
+			}
+			if (numAdds > 0)
+			{
+				return sample / weightAcum * numAdds;
+			}
+			else
+			{
+				return 0;
+			}
+		}
+
+		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
+		static ResultType sampleBeamform2D(
+			ScanlineRxParameters3D::TransmitParameters txParams,
+			const RFType* RF,
+			uint32_t numTransducerElements,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const LocationType* x_elemsDT,
+			LocationType scanline_x,
+			LocationType dirX,
+			LocationType dirY,
+			LocationType dirZ,
+			LocationType aDT,
+			LocationType depth,
+			LocationType invMaxElementDistance,
+			LocationType speedOfSound,
+			LocationType dt,
+			int32_t additionalOffset,
+			const WindowFunctionGpu* windowFunction
+		)
+		{
+			float sample = 0.0f;
+			float weightAcum = 0.0f;
+			int numAdds = 0;
+			LocationType initialDelay = txParams.initialDelay;
+			uint32_t txScanlineIdx = txParams.txScanlineIdx;
+
+			for (int32_t elemIdxX = txParams.firstActiveElementIndex.x; elemIdxX < txParams.lastActiveElementIndex.x; elemIdxX++)
+			{
+				int32_t  channelIdx = elemIdxX % numReceivedChannels;
+				LocationType x_elem = x_elemsDT[elemIdxX];
+				if (sycl::fabs(x_elem - scanline_x) <= aDT)
+				{
+					float weight = windowFunction->get((x_elem - scanline_x) * invMaxElementDistance);
+					weightAcum += weight;
+					numAdds++;
+					if (interpolateRFlines)
+					{
+						LocationType delayf = initialDelay +
+							computeDelayDTSPACE_D(dirX, dirY, dirZ, x_elem, scanline_x, depth) + additionalOffset;
+						int32_t delay = static_cast<int32_t>(sycl::floor(delayf));
+						delayf -= delay;
+						if (delay < (numTimesteps - 1))
+						{
+							sample +=
+								weight * ((1.0f - delayf) * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps] +
+									delayf  * RF[(delay + 1) + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps]);
+						}
+						else if (delay < numTimesteps && delayf == 0.0)
+						{
+							sample += weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+						}
+					}
+					else
+					{
+						int32_t delay = static_cast<int32_t>(sycl::round(initialDelay + computeDelayDTSPACE_D(dirX, dirY, dirZ, x_elem, scanline_x, depth)) + additionalOffset);
+						if (delay < numTimesteps)
+						{
+							sample += weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
+						}
+					}
+				}
+			}
+			if (numAdds > 0)
+			{
+				return sample / weightAcum * numAdds;
+			}
+			else
+			{
+				return 0;
+			}
+		}
+	};
+}
+
+#endif //!__RXSAMPLEBEAMFORMERDELAYANDSUM_H__
diff --git a/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h
new file mode 100644
index 0000000..9b44dc3
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h
@@ -0,0 +1,137 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2017, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __RXSAMPLEBEAMFORMERTESTSIGNAL_H__
+#define __RXSAMPLEBEAMFORMERTESTSIGNAL_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "USImageProperties.h"
+#include "WindowFunction.h"
+#include "RxBeamformerCommon.h"
+
+//TODO ALL ELEMENT/SCANLINE Y positons are actually Z! Change all variable names accordingly
+namespace supra
+{
+	class RxSampleBeamformerTestSignal
+	{
+	public:
+		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
+		static ResultType sampleBeamform3D(
+			ScanlineRxParameters3D::TransmitParameters txParams,
+			const RFType* RF,
+			vec2T<uint32_t> elementLayout,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const LocationType* x_elemsDTsh,
+			const LocationType* z_elemsDTsh,
+			LocationType scanline_x,
+			LocationType scanline_z,
+			LocationType dirX,
+			LocationType dirY,
+			LocationType dirZ,
+			LocationType aDT,
+			LocationType depth,
+			vec2f invMaxElementDistance,
+			LocationType speedOfSound,
+			LocationType dt,
+			int32_t additionalOffset,
+			const WindowFunctionGpu* windowFunction,
+			const WindowFunction::ElementType* functionShared
+		)
+		{
+			constexpr float cylinderSpacing = 6; //[mm]
+			constexpr float cylinderDiameter = 2; //[mm]
+			constexpr float cylinderDepth = 30; //[mm]
+			constexpr int numCylindersHalf = 3;
+
+			float sample = 0.0f;
+
+			vec3f point{ scanline_x + dirX*depth, dirY*depth, scanline_z + dirZ*depth };
+			point = point *dt*speedOfSound; // bring point position back from dt space to world space
+			//check for all cylinders
+			// cylinders along z axis
+			for (int cylinderNo = -numCylindersHalf; cylinderNo <= numCylindersHalf; cylinderNo++)
+			{
+				vec3f cylinderCenter = vec3f{ cylinderNo * cylinderSpacing, cylinderDepth, 0 };
+				vec3f pointInPlane = point;
+				pointInPlane.z = 0;
+				float distance = norm(pointInPlane - cylinderCenter);
+				if (distance <= cylinderDiameter)
+				{
+					sample = 1000;
+				}
+			}
+			// cylinders along x axis
+			for (int cylinderNo = -numCylindersHalf; cylinderNo <= numCylindersHalf; cylinderNo++)
+			{
+				vec3f cylinderCenter = vec3f{ 0, cylinderDepth,  cylinderNo * cylinderSpacing };
+				vec3f pointInPlane = point;
+				pointInPlane.x = 0;
+				float distance = norm(pointInPlane - cylinderCenter);
+				if (distance <= cylinderDiameter)
+				{
+					sample = 1000;
+				}
+			}
+
+			return sample;
+		}
+
+		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
+		static ResultType sampleBeamform2D(
+			ScanlineRxParameters3D::TransmitParameters txParams,
+			const RFType* RF,
+			uint32_t numTransducerElements,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const LocationType* x_elemsDT,
+			LocationType scanline_x,
+			LocationType dirX,
+			LocationType dirY,
+			LocationType dirZ,
+			LocationType aDT,
+			LocationType depth,
+			LocationType invMaxElementDistance,
+			LocationType speedOfSound,
+			LocationType dt,
+			int32_t additionalOffset,
+			const WindowFunctionGpu* windowFunction
+		)
+		{
+			constexpr float cylinderSpacing = 6; //[mm]
+			constexpr float cylinderDiameter = 2; //[mm]
+			constexpr float cylinderDepth = 30; //[mm]
+			constexpr int numCylindersHalf = 3;
+
+			float sample = 0.0f;
+
+			vec3f point{ scanline_x + dirX*depth, dirY*depth, dirZ*depth };
+			point = point *dt*speedOfSound; // bring point position back from dt space to world space
+			//check for all cylinders
+			// cylinders along z axis
+			for (int cylinderNo = -numCylindersHalf; cylinderNo <= numCylindersHalf; cylinderNo++)
+			{
+				vec3f cylinderCenter = vec3f{ cylinderNo * cylinderSpacing, cylinderDepth, 0 };
+				vec3f pointInPlane = point;
+				pointInPlane.z = 0;
+				float distance = norm(pointInPlane - cylinderCenter);
+				if (distance <= cylinderDiameter)
+				{
+					sample = 1000;
+				}
+			}
+			return sample;
+		}
+	};
+}
+
+#endif //!__RXSAMPLEBEAMFORMERTESTSIGNAL_H__
diff --git a/oneapi/src/SupraLib/Beamformer/ScanConverter.dp.cpp b/oneapi/src/SupraLib/Beamformer/ScanConverter.dp.cpp
new file mode 100644
index 0000000..050784c
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/ScanConverter.dp.cpp
@@ -0,0 +1,901 @@
+// ================================================================================================
+// 
+// Copyright (C) 2016, Rüdiger Göbl - all rights reserved
+// Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.
+//
+//          Rüdiger Göbl
+//          Email r.goebl@tum.de
+//          Chair for Computer Aided Medical Procedures
+//          Technische Universität München
+//          Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License, version 2.1, as published by the Free Software Foundation.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this program.  If not, see
+// <http://www.gnu.org/licenses/>.
+//
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "ScanConverter.h"
+#include <cassert>
+#include <utilities/cudaUtility.h>
+#include <utilities/Logging.h>
+
+#include <dpct/dpstd_utils.hpp>
+#include <dpstd/execution>
+#include <dpstd/algorithm>
+#include <cmath>
+
+using namespace std;
+
+namespace supra
+{
+	class ScanConverterInternals {
+	public:
+		typedef ScanConverter::IndexType IndexType;
+		typedef ScanConverter::WeightType WeightType;
+
+		static constexpr double m_tetrahedronTestDistanceThreshold = 1e-9;
+		static constexpr int m_mappingMaxIterations = ScanConverter::m_mappingMaxIterations;
+		static constexpr double m_mappingDistanceThreshold = ScanConverter::m_mappingDistanceThreshold;
+
+		template <typename Tf, typename Ti>
+		static void computeParametersVoxel3D(
+			const Tf &sampleDistance,
+			const vec2T<Ti> &scanlineLayout,
+			const int &scanlineIdxX,
+			const int &scanlineIdxY,
+			const vec3T<Tf> &s1,
+			const vec3T<Tf> &e1,
+			const vec3T<Tf> &s2,
+			const vec3T<Tf> &e2,
+			const vec3T<Tf> &s3,
+			const vec3T<Tf> &e3,
+			const vec3T<Tf> &s4,
+			const vec3T<Tf> &e4,
+			const vec3T<Tf> &scanline1Pos,
+			const vec3T<Tf> &scanline1Dir,
+			const vec3T<Tf> &scanline2Pos,
+			const vec3T<Tf> &scanline2Dir,
+			const vec3T<Tf> &scanline3Pos,
+			const vec3T<Tf> &scanline3Dir,
+			const vec3T<Tf> &scanline4Pos,
+			const vec3T<Tf> &scanline4Dir,
+			const Tf &startDepth,
+			const Tf &endDepth,
+			const vec3T<Ti> &imageSize,
+			const vec3T<Ti> &voxel,
+			const vec3T<Tf> &voxelPos,
+			uint8_t* __restrict__ maskBuf,
+			uint32_t* __restrict__ sampleIdxBuf,
+			float* __restrict__ weightXBuf,
+			float* __restrict__ weightYBuf,
+			float* __restrict__ weightZBuf
+		)
+		{
+			if (pointInsideTetrahedron(s1, s2, s3, e1, voxelPos) ||
+				pointInsideTetrahedron(s2, s4, s3, e4, voxelPos) ||
+				pointInsideTetrahedron(s2, e1, e2, e4, voxelPos) ||
+				pointInsideTetrahedron(s3, e3, e1, e4, voxelPos) ||
+				pointInsideTetrahedron(s2, s3, e1, e4, voxelPos))
+			{
+
+				thrust::pair<vec3T<Tf>, bool> params = mapToParameters3D<Tf, Ti>(
+					scanline1Pos,
+					scanline2Pos,
+					scanline3Pos,
+					scanline4Pos,
+					scanline1Dir,
+					scanline2Dir,
+					scanline3Dir,
+					scanline4Dir,
+					startDepth, endDepth, voxelPos);
+
+				if (params.second)
+				{
+					size_t voxelIndex = voxel.x + voxel.y*imageSize.x + voxel.z*imageSize.x*imageSize.y;
+					maskBuf[voxelIndex] = 1;
+
+					Tf t1 = params.first.x;
+					Tf t2 = params.first.y;
+					Tf d = params.first.z + 0;
+
+					IndexType  sampleIdxScanline = static_cast<IndexType>(sycl::floor(d / sampleDistance));
+					WeightType weightY = static_cast<WeightType>(d / sampleDistance - sampleIdxScanline);
+					WeightType weightX = static_cast<WeightType>(t1);
+					WeightType weightZ = static_cast<WeightType>(t2);
+
+					IndexType sampleIdx = static_cast<IndexType>(sampleIdxScanline*scanlineLayout.x*scanlineLayout.y +
+						scanlineIdxX + scanlineIdxY*scanlineLayout.x);
+
+					sampleIdxBuf[voxelIndex] = sampleIdx;
+					weightXBuf[voxelIndex] = weightX;
+					weightYBuf[voxelIndex] = weightY;
+					weightZBuf[voxelIndex] = weightZ;
+				}
+			}
+		}
+
+		/**
+		 * Tests whether point p lies within the tetrahedron defined by a, b, c, d.
+		 *
+		 * For the test, the barycentric coordinates of p are computed and checked for equal sign.
+		 */
+		template <typename Tf>
+		static bool pointInsideTetrahedron(const vec3T<Tf> & a, const vec3T<Tf> & b, const vec3T<Tf> & c, const vec3T<Tf> & d, const vec3T<Tf> & p)
+		{
+			Tf w0 = barycentricCoordinate3D(a, b, c, d);
+
+			Tf w1 = barycentricCoordinate3D(p, b, c, d);
+			Tf w2 = barycentricCoordinate3D(a, p, c, d);
+			Tf w3 = barycentricCoordinate3D(a, b, p, d);
+			Tf w4 = barycentricCoordinate3D(a, b, c, p);
+
+			return w0 > 0 &&
+				w1 >= -m_tetrahedronTestDistanceThreshold &&
+				w2 >= -m_tetrahedronTestDistanceThreshold &&
+				w3 >= -m_tetrahedronTestDistanceThreshold &&
+				w4 >= -m_tetrahedronTestDistanceThreshold;
+		}
+
+		template <typename Tf>
+		static Tf barycentricCoordinate3D(const vec3T<Tf> & a, const vec3T<Tf> & b, const vec3T<Tf> & c, const vec3T<Tf> & p)
+		{
+			//computes the determinant of 
+			//[a_x, a_y, a_z, 1]
+			//[b_x, b_y, b_z, 1]
+			//[c_x, c_y, c_z, 1]
+			//[p_x, p_y, p_z, 1]
+
+			// reducing 12 multiplications per compute
+			const Tf axby = a.x*b.y;
+			const Tf cypz = c.y*p.z;
+			const Tf axbz = a.x*b.z;
+			const Tf czpy = c.z*p.y;
+			const Tf aybx = a.y*b.x;
+			const Tf cxpz = c.x*p.z;
+			const Tf aybz = a.y*b.z;
+			const Tf czpx = c.z*p.x;
+			const Tf azbx = a.z*b.x;
+			const Tf cxpy = c.x*p.y;
+			const Tf azby = a.z*b.y;
+			const Tf cypx = c.y*p.x;
+
+			return 
+				(axby-aybx)*(c.z-p.z) + (aybz-azby)*(c.x-p.x) +
+				(azbx-axbz)*(c.y-p.y) + (cypz-czpy)*(a.x-b.x) -
+				(cxpz-czpx)*(a.y-b.y) + (cxpy-cypx)*(a.z-b.z);
+			// reducing 18 multiplications with the updated return statement per compute 			
+		}
+
+		template <typename Tf>
+		static vec3T<Tf> pointPlaneConnection(const vec3T<Tf> & a, const vec3T<Tf> & na, const vec3T<Tf> & x)
+		{
+			return dot(na, (x - a))*na;
+		}
+
+		template <typename Tf, typename Ti>
+		static thrust::pair<vec3T<Tf>, bool> mapToParameters3D(
+			const vec3T<Tf> & a,
+			const vec3T<Tf> & ax,
+			const vec3T<Tf> & ay,
+			const vec3T<Tf> & axy,
+			const vec3T<Tf> & da,
+			const vec3T<Tf> & dax,
+			const vec3T<Tf> & day,
+			const vec3T<Tf> & daxy,
+			Tf startDepth,
+			Tf endDepth,
+			const vec3T<Tf> & x)
+		{
+			vec3T<Tf> normalXLow = normalize(cross(da, (ay + day) - a));
+			vec3T<Tf> normalYLow = normalize(cross((ax + dax) - a, da));
+			vec3T<Tf> normalXHigh = normalize(cross(dax, (axy + daxy) - ax));
+			vec3T<Tf> normalYHigh = normalize(cross((axy + daxy) - ay, day));
+
+			//find t via binary search
+			vec2T<Tf> lowT = { 0, 0 };
+			vec2T<Tf> highT = { 1, 1 };
+			vec3T<Tf> lowConnX = pointPlaneConnection(a, normalXLow, x);
+			vec3T<Tf> highConnX = pointPlaneConnection(ax, normalXHigh, x);
+			vec3T<Tf> lowConnY = pointPlaneConnection(a, normalYLow, x);
+			vec3T<Tf> highConnY = pointPlaneConnection(ay, normalYHigh, x);
+			vec2T<Tf> lowDist = { norm(lowConnX), norm(lowConnY) };
+			vec2T<Tf> highDist = { norm(highConnX), norm(highConnY) };
+
+			if (dot(lowConnX, highConnX) > 0 || dot(lowConnY, highConnY) > 0)
+			{
+				return thrust::pair<vec3T<Tf>, bool>(vec3T<Tf>{ 0, 0, 0 }, false);
+			}
+
+			vec2T<Tf> dist = { 1e10, 1e10 };
+			vec2T<Tf> t = (highT - lowT) / 2 + lowT;
+			vec3T<Tf> planeBaseX1;
+			vec3T<Tf> planeBaseY1;
+			vec3T<Tf> planeBaseX2;
+			vec3T<Tf> planeBaseY2;
+			for (int numIter = 0; numIter < m_mappingMaxIterations &&
+				(dist.x > m_mappingDistanceThreshold || dist.y > m_mappingDistanceThreshold); numIter++)
+			{
+				t = (1 - highDist / (highDist + lowDist))*highT + (1 - lowDist / (highDist + lowDist))*lowT;
+
+				planeBaseX1 = (1 - t.x)*a + t.x*ax;
+				planeBaseX2 = (1 - t.x)*ay + t.x*axy;
+				planeBaseY1 = (1 - t.y)*a + t.y*ay;
+				planeBaseY2 = (1 - t.y)*ax + t.y*axy;
+				vec3T<Tf> dir = slerp3(slerp3(da, dax, t.x), slerp3(day, daxy, t.x), t.y);
+				vec3T<Tf> normal_x = normalize(cross(dir, planeBaseX2 - planeBaseX1));
+				vec3T<Tf> normal_y = normalize(cross(planeBaseY2 - planeBaseY1, dir));
+
+				vec3T<Tf> connX = pointPlaneConnection(planeBaseX1, normal_x, x);
+				vec3T<Tf> connY = pointPlaneConnection(planeBaseY1, normal_y, x);
+
+				dist.x = norm(connX);
+				dist.y = norm(connY);
+
+				if (dot(highConnX, connX) > M_EPS)
+				{
+					highT.x = t.x;
+					highConnX = connX;
+					highDist.x = dist.x;
+				}
+				else if (dot(lowConnX, connX) > M_EPS)
+				{
+					lowT.x = t.x;
+					lowConnX = connX;
+					lowDist.x = dist.x;
+				}
+
+				if (dot(highConnY, connY) > M_EPS)
+				{
+					highT.y = t.y;
+					highConnY = connY;
+					highDist.y = dist.y;
+				}
+				else if (dot(lowConnY, connY) > M_EPS)
+				{
+					lowT.y = t.y;
+					lowConnY = connY;
+					lowDist.y = dist.y;
+				}
+			}
+
+			vec3T<Tf> lineBase = (1 - t.y)*planeBaseX1 + t.y*planeBaseX2;
+			Tf d = norm(x - lineBase);
+
+			return thrust::pair<vec3T<Tf>, bool>(vec3T<Tf>{ t.x, t.y, d }, true);
+		}
+	};
+
+	template <typename Tf, typename Ti>
+	void
+		
+		computeParameterBB3D(
+			const Tf sampleDistance,
+			const vec2T<Ti> scanlineLayout,
+			const int scanlineIdxX,
+			const int scanlineIdxY,
+			const vec3T<Tf> s1,
+			const vec3T<Tf> e1,
+			const vec3T<Tf> s2,
+			const vec3T<Tf> e2,
+			const vec3T<Tf> s3,
+			const vec3T<Tf> e3,
+			const vec3T<Tf> s4,
+			const vec3T<Tf> e4,
+			const vec3T<Tf> scanline1Pos,
+			const vec3T<Tf> scanline1Dir,
+			const vec3T<Tf> scanline2Pos,
+			const vec3T<Tf> scanline2Dir,
+			const vec3T<Tf> scanline3Pos,
+			const vec3T<Tf> scanline3Dir,
+			const vec3T<Tf> scanline4Pos,
+			const vec3T<Tf> scanline4Dir,
+			const Tf startDepth,
+			const Tf endDepth,
+			const vec3T<Ti> imageSize,
+			const vec3T<Tf> bbMin,
+			const vec3T<Ti> tetMinVoxel,
+			const vec3T<Ti> tetMaxVoxel,
+			const Tf resolution,
+			uint8_t* __restrict__ maskBuf,
+			uint32_t* __restrict__ sampleIdxBuf,
+			float* __restrict__ weightXBuf,
+			float* __restrict__ weightYBuf,
+			float* __restrict__ weightZBuf
+		,
+			sycl::nd_item<3> item_ct1)
+	{
+		vec3T<Ti> voxel = vec3T<Ti>{ static_cast<Ti>(item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2)),
+									 static_cast<Ti>(item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1)),
+									 static_cast<Ti>(item_ct1.get_local_range().get(0) * item_ct1.get_group(0)
+													 + item_ct1.get_local_id(0)) };	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		voxel = voxel + tetMinVoxel;
+
+		if (voxel.x <= tetMaxVoxel.x && voxel.y <= tetMaxVoxel.y && voxel.z <= tetMaxVoxel.z)
+		{
+			vec3T<Tf> voxelPos = static_cast<vec3T<Tf>>(voxel) * resolution + bbMin;
+			ScanConverterInternals::computeParametersVoxel3D(
+				sampleDistance,
+				scanlineLayout,
+				scanlineIdxX, scanlineIdxY,
+				s1, e1, s2, e2, s3, e3, s4, e4,
+				scanline1Pos,
+				scanline1Dir,
+				scanline2Pos,
+				scanline2Dir,
+				scanline3Pos,
+				scanline3Dir,
+				scanline4Pos,
+				scanline4Dir,
+				startDepth, endDepth,
+				imageSize,
+				voxel,
+				voxelPos,
+				maskBuf,
+				sampleIdxBuf,
+				weightXBuf,
+				weightYBuf,
+				weightZBuf);
+		}
+	}
+
+	template <typename InputType, typename OutputType, typename WeightType, typename IndexType>
+	void scanConvert2D(
+		uint32_t numScanlines,
+		uint32_t numSamples,
+		uint32_t width,
+		uint32_t height,
+		const uint8_t* __restrict__ mask,
+		const IndexType* __restrict__ sampleIdx,
+		const WeightType* __restrict__ weightX,
+		const WeightType* __restrict__ weightY,
+		const InputType* __restrict__ scanlines,
+		OutputType* __restrict__ image,
+		sycl::nd_item<3> item_ct1)
+	{
+		vec2T<uint32_t> pixelPos{ item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2),
+								  item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1) };  //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+
+		if (pixelPos.x < width && pixelPos.y < height)
+		{
+			IndexType pixelIdx = pixelPos.x + pixelPos.y*width;
+			float val = 0;
+			if (mask[pixelIdx])
+			{
+				IndexType sIdx = sampleIdx[pixelIdx];
+				WeightType wX = weightX[pixelIdx];
+				WeightType wY = weightY[pixelIdx];
+
+				val = (1 - wY)*((1 - wX)*scanlines[sIdx] +
+					wX *scanlines[sIdx + 1]) +
+					wY *((1 - wX)*scanlines[sIdx + numScanlines] +
+						wX *scanlines[sIdx + 1 + numScanlines]);
+			}
+			image[pixelIdx] = clampCast<OutputType>(val);
+		}
+	}
+
+	template <typename InputType, typename OutputType, typename WeightType, typename IndexType>
+	void scanConvert3D(
+		uint32_t numScanlinesX,
+		uint32_t numScanlinesY,
+		uint32_t numSamples,
+		uint32_t width,
+		uint32_t height,
+		uint32_t depth,
+		const uint8_t* __restrict__ mask,
+		const IndexType* __restrict__ sampleIdx,
+		const WeightType* __restrict__ weightX,
+		const WeightType* __restrict__ weightY,
+		const WeightType* __restrict__ weightZ,
+		const InputType* __restrict__ scanlines,
+		OutputType* __restrict__ image,
+		sycl::nd_item<3> item_ct1)
+	{
+		vec3T<uint32_t> pixelPos{ item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2),
+								  item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1),
+								  item_ct1.get_local_range().get(0) * item_ct1.get_group(0) + item_ct1.get_local_id(0) };  //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+
+		if (pixelPos.x < width && pixelPos.y < height)
+		{
+			IndexType pixelIdx = pixelPos.x + pixelPos.y*width + pixelPos.z*width*height;
+			float val = 0;
+			if (mask[pixelIdx])
+			{
+				uint32_t numScanlines = numScanlinesX*numScanlinesY;
+				IndexType sIdx = sampleIdx[pixelIdx];
+				WeightType wX = weightX[pixelIdx];
+				WeightType wY = weightY[pixelIdx];
+				WeightType wZ = weightZ[pixelIdx];
+
+
+				val =
+					(1 - wY)*((1 - wZ)*((1 - wX)*scanlines[sIdx] +
+						wX *scanlines[sIdx + 1]) +
+						wZ *((1 - wX)*scanlines[sIdx + numScanlinesX] +
+							wX *scanlines[sIdx + 1 + numScanlinesX])) +
+					wY* ((1 - wZ)*((1 - wX)*scanlines[sIdx + numScanlines] +
+						wX *scanlines[sIdx + 1 + numScanlines]) +
+						wZ *((1 - wX)*scanlines[sIdx + numScanlinesX + numScanlines] +
+							wX *scanlines[sIdx + 1 + numScanlinesX + numScanlines]));
+			}
+			image[pixelIdx] = clampCast<OutputType>(val);
+		}
+	}
+
+	shared_ptr<Container<uint8_t>> ScanConverter::getMask()
+	{
+		return m_mask;
+	}
+
+	template<typename InputType, typename OutputType>
+	shared_ptr<Container<OutputType>> ScanConverter::convert(const shared_ptr<USImage>& inImage)
+	{
+		uint32_t numScanlines = (uint32_t)inImage->getImageProperties()->getNumScanlines();
+		vec2s scanlineLayout = inImage->getImageProperties()->getScanlineLayout();
+		uint32_t numSamples = (uint32_t)inImage->getImageProperties()->getNumSamples();
+
+		shared_ptr<const Container<InputType>> pScanlineData = inImage->getData<InputType>();
+		if (pScanlineData->isHost())
+		{
+			pScanlineData = make_shared<Container<InputType>>(LocationGpu, *pScanlineData);
+		}
+		auto pConv = make_shared<Container<OutputType>>(LocationGpu, pScanlineData->getStream(), m_imageSize.x*m_imageSize.y*m_imageSize.z);
+
+		if (m_is2D)
+		{
+			sycl::range<3> blockSize(1, 256, 1);
+			sycl::range<3> gridSize(static_cast<unsigned int>((m_imageSize.x + blockSize.x - 1) / blockSize.x), static_cast<unsigned int>((m_imageSize.y + blockSize.y - 1) / blockSize.y), 1);
+			pScanlineData->getStream()->submit([ & ](sycl::handler& cgh) {
+				auto dpct_global_range = gridSize * blockSize;
+
+				auto m_imageSize_x_ct2 = ( uint32_t )m_imageSize.x;
+				auto m_imageSize_y_ct3 = ( uint32_t )m_imageSize.y;
+
+				cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+												   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+								 [ = ](sycl::nd_item<3> item_ct1) {
+									 scanConvert2D(numScanlines, numSamples, m_imageSize_x_ct2, m_imageSize_y_ct3, m_mask->get(), m_sampleIdx->get(), m_weightX->get(), m_weightY->get(),
+												   pScanlineData->get(), pConv->get(), item_ct1);
+								 });
+			});
+			/*
+			DPCT1010:20: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+			*/
+			cudaSafeCall(0);
+		}
+		else
+		{
+			sycl::range<3> blockSize(1, 256, 1);
+			sycl::range<3> gridSize(static_cast<unsigned int>((m_imageSize.x + blockSize.x - 1) / blockSize.x), static_cast<unsigned int>((m_imageSize.y + blockSize.y - 1) / blockSize.y),
+									static_cast<unsigned int>((m_imageSize.z + blockSize.z - 1) / blockSize.z));
+			pScanlineData->getStream()->submit([ & ](sycl::handler& cgh) {
+				auto dpct_global_range = gridSize * blockSize;
+
+				auto m_imageSize_x_ct3 = ( uint32_t )m_imageSize.x;
+				auto m_imageSize_y_ct4 = ( uint32_t )m_imageSize.y;
+				auto m_imageSize_z_ct5 = ( uint32_t )m_imageSize.z;
+
+				cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+												   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+								 [ = ](sycl::nd_item<3> item_ct1) {
+									 scanConvert3D(( uint32_t )scanlineLayout.x, ( uint32_t )scanlineLayout.y, numSamples, m_imageSize_x_ct3, m_imageSize_y_ct4, m_imageSize_z_ct5, m_mask->get(),
+												   m_sampleIdx->get(), m_weightX->get(), m_weightY->get(), m_weightZ->get(), pScanlineData->get(), pConv->get(), item_ct1);
+								 });
+			});
+			/*
+			DPCT1010:21: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+			*/
+			cudaSafeCall(0);
+		}
+		return pConv;
+	}
+
+	template
+		std::shared_ptr<Container<uint8_t>> ScanConverter::convert<uint8_t, uint8_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<int16_t>> ScanConverter::convert<uint8_t, int16_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<float>> ScanConverter::convert<uint8_t, float>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<uint8_t>> ScanConverter::convert<int16_t, uint8_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<int16_t>> ScanConverter::convert<int16_t, int16_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<float>> ScanConverter::convert<int16_t, float>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<uint8_t>> ScanConverter::convert<float, uint8_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<int16_t>> ScanConverter::convert<float, int16_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<float>> ScanConverter::convert<float, float>(const std::shared_ptr<USImage>& inImage);
+
+	void ScanConverter::updateInternals(const std::shared_ptr<const USImageProperties>& inImageProps)
+	{
+		logging::log_log("Scanconverter: Updating scanconversion internals");
+
+		//Check the scanline configuration for validity
+		m_is2D = inImageProps->is2D();
+
+		vec2s layout = inImageProps->getScanlineLayout();
+		double startDepth = 0;
+		double endDepth = inImageProps->getDepth();
+		double resolution = inImageProps->getImageResolution();
+		auto scanlines = inImageProps->getScanlineInfo();
+		logging::log_error_if(!scanlines, "ScanConverter: No scanlines have been attached to the USImageProperties!");
+
+		bool scanlinesGood = scanlines.operator bool();
+
+		if (scanlinesGood)
+		{
+			for (size_t scanlineIdxY = 0; scanlineIdxY < layout.y; scanlineIdxY++)
+			{
+				for (size_t scanlineIdxX = 0; scanlineIdxX < layout.x; scanlineIdxX++)
+				{
+					if (scanlineIdxX > 0)
+					{
+						vec start = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec startbefore = (*scanlines)[scanlineIdxX - 1][scanlineIdxY].getPoint(startDepth);
+						vec end = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec endbefore = (*scanlines)[scanlineIdxX - 1][scanlineIdxY].getPoint(endDepth);
+
+						//scanline start points are increasing in x
+						scanlinesGood = scanlinesGood &&
+							start.x >= startbefore.x;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  1 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanline end points are increasing in x, that means scanlines do not intersect
+						scanlinesGood = scanlinesGood &&
+							end.x >= endbefore.x;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  2 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines can not be identical
+						scanlinesGood = scanlinesGood &&
+							(start.x > startbefore.x || end.x > endbefore.x);
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  3 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines are not skew
+						scanlinesGood = scanlinesGood && abs(det(start - endbefore, startbefore - endbefore, end - endbefore)) < m_skewnessTestThreshold;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  4 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+					}
+
+					if (scanlineIdxY > 0)
+					{
+						vec start = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec startbefore = (*scanlines)[scanlineIdxX][scanlineIdxY - 1].getPoint(startDepth);
+						vec end = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec endbefore = (*scanlines)[scanlineIdxX][scanlineIdxY - 1].getPoint(endDepth);
+
+						//scanline start points are increasing in z
+						scanlinesGood = scanlinesGood &&
+							start.z >= startbefore.z;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  5 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanline end points are increasing in z, that means scanlines do not intersect
+						scanlinesGood = scanlinesGood &&
+							end.z >= endbefore.z;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  6 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines can not be identical
+						scanlinesGood = scanlinesGood &&
+							(start.z > startbefore.z || end.z > endbefore.z);
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  7 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines are not skew
+						scanlinesGood = scanlinesGood && abs(det(start - endbefore, startbefore - endbefore, end - endbefore)) < m_skewnessTestThreshold;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  8 ", scanlineIdxX, ", ", scanlineIdxY, "   det = ", det(start - endbefore, startbefore - endbefore, end - endbefore));
+						}
+					}
+				}
+			}
+		}
+
+		if (scanlinesGood)
+		{
+			//find scan bounding box
+			vec bbMin{ numeric_limits<double>::max(),  numeric_limits<double>::max(),  numeric_limits<double>::max() };
+			vec bbMax{ -numeric_limits<double>::max(), -numeric_limits<double>::max(), -numeric_limits<double>::max() };
+			for (size_t scanlineIdxY = 0; scanlineIdxY < layout.y; scanlineIdxY++)
+			{
+				for (size_t scanlineIdxX = 0; scanlineIdxX < layout.x; scanlineIdxX++)
+				{
+					vec p1 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+					vec p2 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+					bbMin = { min(bbMin.x, p1.x), min(bbMin.y, p1.y), min(bbMin.z, p1.z) };
+					bbMax = { max(bbMax.x, p1.x), max(bbMax.y, p1.y), max(bbMax.z, p1.z) };
+					bbMin = { min(bbMin.x, p2.x), min(bbMin.y, p2.y), min(bbMin.z, p2.z) };
+					bbMax = { max(bbMax.x, p2.x), max(bbMax.y, p2.y), max(bbMax.z, p2.z) };
+				}
+			}
+			m_bbMin = bbMin;
+			m_bbMax = bbMax;
+
+			//compute image size
+			m_imageSize = static_cast<vec3s>(ceil((bbMax - bbMin) / resolution)) + 1;
+			m_imageSize.x = max(m_imageSize.x, ( size_t )1);
+			m_imageSize.y = max(m_imageSize.y, ( size_t )1);
+			m_imageSize.z = max(m_imageSize.z, ( size_t )1);
+
+			// create buffers
+			size_t numelBuffers = m_imageSize.x*m_imageSize.y*m_imageSize.z;
+			/*m_mask = make_shared<Container<uint8_t>>(ContainerLocation::LocationHost, numelBuffers);
+			m_sampleIdx = make_shared<Container<IndexType>>(ContainerLocation::LocationHost, numelBuffers);
+			m_weightX = make_shared<Container<WeightType>>(ContainerLocation::LocationHost, numelBuffers);
+			m_weightY = make_shared<Container<WeightType>>(ContainerLocation::LocationHost, numelBuffers);
+			m_weightZ = make_shared<Container<WeightType>>(ContainerLocation::LocationHost, numelBuffers);*/
+			m_mask = make_shared<Container<uint8_t>>(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
+			m_sampleIdx = make_shared<Container<IndexType>>(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
+			m_weightX = make_shared<Container<WeightType>>(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
+			m_weightY = make_shared<Container<WeightType>>(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
+			m_weightZ = make_shared<Container<WeightType>>(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
+
+			//create image mask
+			/*
+			DPCT1003:22: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall(((( cudaStream_t )0x2)->memset(m_mask->get(), 0, m_mask->size() * sizeof(uint8_t), cudaStreamPerThread), 0));
+
+			if (m_is2D)
+			{
+				//2D is computed on the cpu at the moment -> copy
+				m_mask = make_shared<Container<uint8_t>>(LocationHost, *m_mask);
+				m_sampleIdx = make_shared<Container<IndexType>>(LocationHost, *m_sampleIdx);
+				m_weightX = make_shared<Container<WeightType>>(LocationHost, *m_weightX);
+				m_weightY = make_shared<Container<WeightType>>(LocationHost, *m_weightY);
+				m_weightZ = make_shared<Container<WeightType>>(LocationHost, *m_weightZ);
+
+				vec2 bb2DMin{ m_bbMin.x, m_bbMin.y };
+				assert(layout.x > 1);
+				// From now on, we assume everything is in the xy-plane
+				// -----------------------------------------
+				for (size_t scanlineIdxY = 0; scanlineIdxY < layout.y; scanlineIdxY++)
+				{
+#pragma omp parallel for schedule(dynamic, 8)
+					for (int scanlineIdxX = 0; scanlineIdxX < layout.x - 1; scanlineIdxX++)
+					{
+						vec start3 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec startN3 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(startDepth);
+						vec end3 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec endN3 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(endDepth);
+						vec2 start = { start3.x, start3.y };
+						vec2 startN = { startN3.x, startN3.y };
+						vec2 end = { end3.x, end3.y };
+						vec2 endN = { endN3.x, endN3.y };
+
+						// find bounding box of the two scanlines
+						vec2 quadMinWorld = { std::min(std::min(std::min(start.x, startN.x), end.x), endN.x), std::min(std::min(std::min(start.y, startN.y), end.y), endN.y) };
+						vec2 quadMaxWorld = { std::max(std::max(std::max(start.x, startN.x), end.x), endN.x), std::max(std::max(std::max(start.y, startN.y), end.y), endN.y) };
+
+						vec2s quadMinPixel = static_cast<vec2s>(floor((quadMinWorld - bb2DMin) / resolution));
+						vec2s quadMaxPixel = static_cast<vec2s>(ceil((quadMaxWorld - bb2DMin) / resolution));
+
+						// check the pixels in the quad bounding box and mark the inside ones
+						vec2s pixel;
+						for (pixel.x = quadMinPixel.x; pixel.x <= quadMaxPixel.x; pixel.x++)
+						{
+							for (pixel.y = quadMinPixel.y; pixel.y <= quadMaxPixel.y; pixel.y++)
+							{
+								vec2 pixelPos = static_cast<vec2>(pixel) * resolution + bb2DMin;
+								if (pointInsideTriangle(endN, end, start, pixelPos) ||
+									pointInsideTriangle(start, startN, endN, pixelPos))
+								{
+									m_mask->get()[pixel.x + pixel.y*m_imageSize.x] = 1;
+
+									vec2 params = mapToParameters2D(
+										(*scanlines)[scanlineIdxX][scanlineIdxY].position,
+										(*scanlines)[scanlineIdxX + 1][scanlineIdxY].position,
+										(*scanlines)[scanlineIdxX][scanlineIdxY].direction,
+										(*scanlines)[scanlineIdxX + 1][scanlineIdxY].direction,
+										startDepth, endDepth, { pixelPos.x, pixelPos.y, 0.0 });
+									double t = params.x;
+									double d = params.y;
+
+									IndexType  sampleIdxScanline = static_cast<IndexType>(std::floor(d / inImageProps->getSampleDistance()));
+									WeightType weightY = static_cast<WeightType>(d - (sampleIdxScanline*inImageProps->getSampleDistance()));
+									WeightType weightX = static_cast<WeightType>(t);
+
+									IndexType sampleIdx = static_cast<IndexType>(sampleIdxScanline*inImageProps->getNumScanlines() +
+										scanlineIdxX + scanlineIdxY*layout.x);
+
+									m_sampleIdx->get()[pixel.x + pixel.y*m_imageSize.x] = sampleIdx;
+									m_weightX->get()[pixel.x + pixel.y*m_imageSize.x] = weightX;
+									m_weightY->get()[pixel.x + pixel.y*m_imageSize.x] = weightY;
+								}
+							}
+						}
+					}
+				}
+
+				//2D is computed on the cpu at the moment -> copy
+				m_mask = make_shared<Container<uint8_t>>(LocationGpu, *m_mask);
+				m_sampleIdx = make_shared<Container<IndexType>>(LocationGpu, *m_sampleIdx);
+				m_weightX = make_shared<Container<WeightType>>(LocationGpu, *m_weightX);
+				m_weightY = make_shared<Container<WeightType>>(LocationGpu, *m_weightY);
+				m_weightZ = make_shared<Container<WeightType>>(LocationGpu, *m_weightZ);
+			}
+			else {
+				// 3D case
+				for (int scanlineIdxY = 0; scanlineIdxY < layout.y - 1; scanlineIdxY++)
+				{
+					//#pragma omp parallel for schedule(dynamic, 1)
+					for (int scanlineIdxX = 0; scanlineIdxX < layout.x - 1; scanlineIdxX++)
+					{
+						vec s1 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec e1 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec s2 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(startDepth);
+						vec e2 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(endDepth);
+						vec s3 = (*scanlines)[scanlineIdxX][scanlineIdxY + 1].getPoint(startDepth);
+						vec e3 = (*scanlines)[scanlineIdxX][scanlineIdxY + 1].getPoint(endDepth);
+						vec s4 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY + 1].getPoint(startDepth);
+						vec e4 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY + 1].getPoint(endDepth);
+
+						// find bounding box of the four scanlines
+						vec tetMinWorld = min(min(min(s1, s2), min(s3, s4)),
+							min(min(e1, e2), min(e3, e4)));
+						vec tetMaxWorld = max(max(max(s1, s2), max(s3, s4)),
+							max(max(e1, e2), max(e3, e4)));
+
+						vec3s tetMinVoxel = static_cast<vec3s>(floor((tetMinWorld - bbMin) / resolution));
+						vec3s tetMaxVoxel = static_cast<vec3s>(ceil((tetMaxWorld - bbMin) / resolution));
+
+						vec3s numVoxels = tetMaxVoxel - tetMinVoxel + 1;
+						sycl::range<3> blockSize(16, 4, 4);
+						sycl::range<3> gridSize(static_cast<unsigned int>((numVoxels.x + blockSize.x - 1) / blockSize.x), static_cast<unsigned int>((numVoxels.y + blockSize.y - 1) / blockSize.y),
+												static_cast<unsigned int>((numVoxels.z + blockSize.z - 1) / blockSize.z));
+
+						typedef float Tf;
+						typedef int Ti;
+
+						cudaStreamPerThread->submit([ & ](sycl::handler& cgh) {
+							auto dpct_global_range = gridSize * blockSize;
+
+							cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+															   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+											 [ = ](sycl::nd_item<3> item_ct1) {
+												 computeParameterBB3D<Tf, Ti>(
+													 static_cast<Tf>(inImageProps->getSampleDistance()), static_cast<vec2T<Ti>>(layout), scanlineIdxX, scanlineIdxY, static_cast<vec3T<Tf>>(s1),
+													 static_cast<vec3T<Tf>>(e1), static_cast<vec3T<Tf>>(s2), static_cast<vec3T<Tf>>(e2), static_cast<vec3T<Tf>>(s3), static_cast<vec3T<Tf>>(e3),
+													 static_cast<vec3T<Tf>>(s4), static_cast<vec3T<Tf>>(e4), static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY ].position),
+													 static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY ].direction),
+													 static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY ].position),
+													 static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY ].direction),
+													 static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY + 1 ].position),
+													 static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY + 1 ].direction),
+													 static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY + 1 ].position),
+													 static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY + 1 ].direction), static_cast<Tf>(startDepth), static_cast<Tf>(endDepth),
+													 static_cast<vec3T<Ti>>(m_imageSize), static_cast<vec3T<Tf>>(bbMin), static_cast<vec3T<Ti>>(tetMinVoxel), static_cast<vec3T<Ti>>(tetMaxVoxel),
+													 static_cast<Tf>(resolution), m_mask->get(), m_sampleIdx->get(), m_weightX->get(), m_weightY->get(), m_weightZ->get(), item_ct1);
+											 });
+						});
+						/*
+						DPCT1010:23: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+						*/
+						cudaSafeCall(0);
+					}
+				}
+			}
+			/*
+			DPCT1003:24: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((cudaStreamPerThread->wait(), 0));
+		}
+		else
+		{
+			logging::log_error("ScanConverter: The scanlines are not in the required configuration.");
+		}
+	}
+
+	double ScanConverter::barycentricCoordinate2D(const vec2 & a, const vec2 & b, const vec2 & c)
+	{
+		return (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);
+	}
+
+	bool ScanConverter::pointInsideTriangle(const vec2 & a, const vec2 & b, const vec2 & c, const vec2 & p)
+	{
+		double w0 = barycentricCoordinate2D(b, c, p);
+		double w1 = barycentricCoordinate2D(c, a, p);
+		double w2 = barycentricCoordinate2D(a, b, p);
+
+		// Test if p is on or inside all edges
+		return (w0 >= 0 && w1 >= 0 && w2 >= 0);
+	}
+
+	vec ScanConverter::pointLineConnection(const vec & a, const vec & da, const vec & x)
+	{
+		vec conn = x - a;
+		vec r = conn - dot(da, conn) *da;
+		return r;
+	}
+
+	vec2 ScanConverter::mapToParameters2D(const vec & a, const vec & b, const vec & da, const vec & db, double startDepth, double endDepth, const vec & x)
+	{
+		//find t via binary search
+		double lowT = 0;
+		double highT = 1;
+		vec lowConn = pointLineConnection(a, da, x);
+		vec highConn = pointLineConnection(b, db, x);
+		double lowDist = norm(lowConn);
+		double highDist = norm(highConn);
+
+		if (highConn.x == 0 && highConn.y == 0 && highConn.z == 0)
+		{
+			double t = highT;
+			double d = norm(x - b);
+			return{ t, d };
+		}
+		else if (lowConn.x == 0 && lowConn.y == 0 && lowConn.z == 0)
+		{
+			double t = lowT;
+			double d = norm(x - a);
+			return{ t, d };
+		}
+
+		assert(dot(lowConn, highConn) < 0);
+
+		double dist = 1e10;
+		double t = (highT - lowT) / 2 + lowT;
+		vec lineBase;
+		for (size_t numIter = 0; numIter < m_mappingMaxIterations && dist > m_mappingDistanceThreshold; numIter++)
+		{
+			t = (1 - highDist / (highDist + lowDist))*highT + (1 - lowDist / (highDist + lowDist))*lowT;
+
+			lineBase = (1 - t)*a + t*b;
+			vec lineDir = slerp3(da, db, t);
+
+			vec conn = pointLineConnection(lineBase, lineDir, x);
+			dist = norm(conn);
+
+			if (dot(lowConn, conn) < 0)
+			{
+				highT = t;
+				highConn = conn;
+				highDist = dist;
+			}
+			else
+			{
+				lowT = t;
+				lowConn = conn;
+				lowDist = dist;
+			}
+		}
+		double d = norm(x - lineBase);
+
+		return{ t, d };
+	}
+}
diff --git a/oneapi/src/SupraLib/Beamformer/ScanConverter.h b/oneapi/src/SupraLib/Beamformer/ScanConverter.h
new file mode 100644
index 0000000..2b891d1
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/ScanConverter.h
@@ -0,0 +1,68 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __SCANCONVERTER_H__
+#define __SCANCONVERTER_H__
+
+#include "USImage.h"
+#include "Container.h"
+
+#include <memory>
+
+namespace supra
+{
+	class ScanConverter
+	{
+	public:
+		typedef uint32_t IndexType;
+		typedef float WeightType;
+
+		static constexpr int m_mappingMaxIterations = 1000;
+		static constexpr double m_mappingDistanceThreshold = 1e-5;
+
+		template<typename InputType, typename OutputType>
+		std::shared_ptr<Container<OutputType> >
+			convert(const std::shared_ptr<USImage> & inImage);
+		std::shared_ptr<Container<uint8_t> > getMask();
+		void updateInternals(const std::shared_ptr<const USImageProperties> & inImageProps);
+		vec3s getImageSize() const { return m_imageSize; }
+
+	private:
+		static constexpr double m_skewnessTestThreshold = 1e-6;
+
+		double barycentricCoordinate2D(const vec2& a, const vec2& b, const vec2& c);
+		//double barycentricCoordinate3D(const vec& a, const vec& b, const vec& c, const vec& p);
+		bool pointInsideTriangle(const vec2& a, const vec2& b, const vec2& c, const vec2& p);
+		//bool pointInsideTetrahedron(const vec& a, const vec& b, const vec& c, const vec& d, const vec& p);
+
+		vec pointLineConnection(const vec& a, const vec& da, const vec& x);
+		//vec pointPlaneConnection(const vec& a, const vec& na, const vec& x);
+		vec2 mapToParameters2D(const vec& a, const vec& b, const vec& da, const vec& db, double startDepth, double endDepth, const vec& x);
+		/*std::pair<vec, bool>  mapToParameters3D(
+			const vec& a, const vec& ax, const vec& ay, const vec& axy,
+			const vec& da, const vec& dax, const vec& day, const vec& daxy,
+			double startDepth, double endDepth, const vec& x);*/
+
+		bool m_is2D;
+
+		std::shared_ptr<Container<uint8_t> > m_mask;
+		std::shared_ptr<Container<IndexType> > m_sampleIdx;
+		std::shared_ptr<Container<WeightType> > m_weightX;
+		std::shared_ptr<Container<WeightType> > m_weightY;
+		std::shared_ptr<Container<WeightType> > m_weightZ;
+
+		vec m_bbMin = { 0,0,0 };
+		vec m_bbMax = { 0,0,0 };
+		vec3s m_imageSize = { 0,0,0 };
+	};
+}
+
+#endif //!__SCANCONVERTER_H__
diff --git a/oneapi/src/SupraLib/Beamformer/USRawData.h b/oneapi/src/SupraLib/Beamformer/USRawData.h
new file mode 100644
index 0000000..9d5a517
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/USRawData.h
@@ -0,0 +1,84 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __USRAWDATA_H__
+#define __USRAWDATA_H__
+
+#include <memory>
+#include <stddef.h>
+
+#include "Container.h"
+#include "RecordObject.h"
+#include "USImageProperties.h"
+#include "RxBeamformerParameters.h"
+
+namespace supra
+{
+	class USRawData : public RecordObject
+	{
+	public:
+		USRawData(size_t numScanlines,
+			size_t numElements,
+			vec2s elementLayout,
+			size_t numReceivedChannels,
+			size_t numSamples,
+			double samplingFrequency,
+			std::shared_ptr<const ContainerBase > pData,
+			std::shared_ptr<const RxBeamformerParameters> pRxBeamformerParameters,
+			std::shared_ptr<const USImageProperties> pImageProperties,
+			double receiveTimestamp,
+			double syncTimestamp)
+			: RecordObject(receiveTimestamp, syncTimestamp)
+			, m_numScanlines(numScanlines)
+			, m_numElements(numElements)
+			, m_elementLayout(elementLayout)
+			, m_numReceivedChannels(numReceivedChannels)
+			, m_numSamples(numSamples)
+			, m_samplingFrequency(samplingFrequency)
+			, m_pData(pData)
+			, m_pRxBeamformerParameters(pRxBeamformerParameters)
+			, m_pImageProperties(pImageProperties)
+		{};
+
+		std::shared_ptr<const USImageProperties> getImageProperties() const { return m_pImageProperties; };
+		/// Sets the \see USImageProperties that contain the associated metadata
+		void setImageProperties(std::shared_ptr<USImageProperties> & imageProperties) { m_pImageProperties = imageProperties; };
+		template <typename ElementType>
+		std::shared_ptr<const Container<ElementType> > getData() const 
+		{
+			return std::dynamic_pointer_cast<const Container<ElementType> >(m_pData); 
+		}
+		size_t getNumScanlines() const { return m_numScanlines; };
+		size_t getNumElements() const { return m_numElements; };
+		vec2s getElementLayout() const { return m_elementLayout; };
+		size_t getNumReceivedChannels() const { return m_numReceivedChannels; };
+		size_t getNumSamples() const { return m_numSamples; };
+		double getSamplingFrequency() const { return m_samplingFrequency; };
+		std::shared_ptr<const RxBeamformerParameters> getRxBeamformerParameters() const { return m_pRxBeamformerParameters; };
+
+		virtual RecordObjectType getType() const { return TypeUSRawData; }
+		DataType getDataType() const { return m_pData->getType(); }
+
+	private:
+		size_t m_numScanlines;
+		size_t m_numElements;
+		vec2s m_elementLayout;
+		size_t m_numReceivedChannels;
+		size_t m_numSamples;
+		double m_samplingFrequency; // [MHz]
+		std::shared_ptr<const ContainerBase> m_pData;
+		std::shared_ptr<const RxBeamformerParameters> m_pRxBeamformerParameters;
+
+		std::shared_ptr<const USImageProperties> m_pImageProperties;
+	};
+}
+
+#endif //!__USRAWDATA_H__
diff --git a/oneapi/src/SupraLib/Beamformer/USTransducer.h b/oneapi/src/SupraLib/Beamformer/USTransducer.h
new file mode 100644
index 0000000..61a6100
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/USTransducer.h
@@ -0,0 +1,125 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __USTRANSDUCER_H__
+#define __USTRANSDUCER_H__
+
+#include <memory>
+#include <vector>
+#include <map>
+#include "vec.h"
+
+#include <utilities/utility.h>
+
+namespace supra
+{
+	class USTransducer
+	{
+	public:
+		enum Type {
+			Linear,
+			Curved,
+			Planar,
+			Bicurved
+		};
+
+		USTransducer(
+			size_t numElements,
+			vec2s elementLayout,
+			USTransducer::Type type,
+			const std::vector<double>& pitchX,
+			const std::vector<double>& pitchY,
+			const std::vector<std::pair<double, double> >& matchingLayers = {});
+
+		/// create the transducer object from an xml description
+		//USTransducer(std::string xmlFilename);
+
+	public:
+		/////////////////////////////////////////////////////////////////////
+		// simple setters for defining properties
+		/////////////////////////////////////////////////////////////////////
+		void setType(USTransducer::Type type);		// Defines the type of transducer
+		void setNumElements(size_t numElements);		// number of transducer elements
+		void setPitch(					// pitch of the transducer elemens. Distance of the transducer element centers for linear and curved arrays
+			const std::vector<double>& pitchX,
+			const std::vector<double>& pitchY);
+
+		template <typename valueType>
+		void setSpecificParameter(std::string parameterName, valueType value);	// set one interface-specific parameter
+
+		/////////////////////////////////////////////////////////////////////
+		// simple getters
+		/////////////////////////////////////////////////////////////////////
+		USTransducer::Type getType() const;		// Defines the type of transducer
+		size_t getNumElements() const;			// number of transducer elements
+		vec2s getElementLayout() const;			// the logical arrangement of the elements. E.g. for 2D: 32x32
+		std::shared_ptr < const std::vector<vec> > getElementCenterPoints() const; // vector of points that mark the center of each transducer element
+		std::shared_ptr < const std::vector<vec> > getElementNormals() const;      // vector of unit-vectors that describe the element normals
+
+		bool  hasSpecificParameter(std::string parameterName) const;					// whether one interface-specific parameter exists
+		const std::string&  getSpecificParameter(std::string parameterName) const;	// get one interface-specific parameter
+		const std::map<std::string, std::string>&  getSpecificParameters() const;	// map to the interface-specific parameters
+
+		/////////////////////////////////////////////////////////////////////
+		// Dependent properties, i.e. they only have a getter that computes the return value
+		/////////////////////////////////////////////////////////////////////
+		bool is2D() const;
+
+		double computeTransitTime(vec2s elementIndex, vec elementToTarget, double speedOfSoundMMperS, bool correctForMatchingLayer = true) const;
+
+		std::shared_ptr < const std::vector<vec4> >  getElementCenterPointsHom() const;	// array of points in HOMOGENEOUS COORDINATES that mark the center of each transducer element. EXPENSIVE
+		std::shared_ptr < const std::vector<vec4> >  getElementNormalsHom() const;	    // array of vectors in HOMOGENEOUS COORDINATES that describe the element normals. EXPENSIVE
+
+	private:
+		/////////////////////////////////////////////////////////////////////
+		// Defining properties
+		/////////////////////////////////////////////////////////////////////
+		USTransducer::Type m_type;	// Defines the type of transducer
+		size_t m_numElements;		// number of transducer elements
+		vec2s m_elementLayout;      // the logical arrangement of the elements. E.g. for 2D: 32x32
+		std::vector<double> m_pitchX; // pitch of the transducer elemens. Distance of the transducer element centers for linear and curved arrays
+		std::vector<double> m_pitchY; // pitch of the transducer elemens. Distance of the transducer element centers for linear and curved arrays
+		std::vector<std::pair<double, double> > m_matchingLayers; // List of the matching layers, as pairs of thickness [mm] and speed of sound [m/s]
+
+		/////////////////////////////////////////////////////////////////////
+		// Properties for efficient ray-Based operations
+		/////////////////////////////////////////////////////////////////////
+		std::shared_ptr < std::vector<vec> > m_elementCenterPoints; // vector of points that mark the center of each transducer element
+		std::shared_ptr < std::vector<vec> > m_elementNormals;		// vector of unit-vectors that describe the element normals
+
+		// Map for interface specific parameters, they do not define the image itself but its meaning
+		std::map<std::string, std::string> m_specificParameters;
+
+		void computeInternals(void);
+
+		std::pair<double, std::vector<vec2> >
+			findRay(vec2 pos, double speedOfSoundMMperS) const;
+		std::pair<vec2, std::vector<vec2> >
+			computeRay(double alpha, double speedOfSoundMMperS, double posAxial) const;
+		double computeRayTime(const vec2& endPoint, const std::vector<vec2> & rayPositions, double speedofSoundMMperS) const;
+		std::pair<vec2, double>
+			matchingLayer(vec2 p, double angle1, double c1, double c2, double thickness) const;
+	};
+
+	template<typename valueType>
+	inline void USTransducer::setSpecificParameter(std::string parameterName, valueType value)
+	{
+		m_specificParameters[parameterName] = stringify(value);
+	}
+
+	template<>
+	inline void USTransducer::setSpecificParameter<std::string>(std::string parameterName, std::string value)
+	{
+		m_specificParameters[parameterName] = value;
+	}
+}
+
+#endif //!__USTRANSDUCER_H__
diff --git a/oneapi/src/SupraLib/Beamformer/WindowFunction.h b/oneapi/src/SupraLib/Beamformer/WindowFunction.h
new file mode 100644
index 0000000..61d3727
--- /dev/null
+++ b/oneapi/src/SupraLib/Beamformer/WindowFunction.h
@@ -0,0 +1,149 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __WINDOWFUNCTION_H__
+#define __WINDOWFUNCTION_H__
+
+#ifndef CL_SYCL_LANGUAGE_VERSION
+#include <algorithm>
+#endif
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <memory>
+#include <Container.h>
+#include <utilities/utility.h>
+#include <utilities/cudaUtility.h>
+
+namespace supra
+{
+#ifndef CL_SYCL_LANGUAGE_VERSION
+	using std::max;
+	using std::min;
+#else
+	using ::max;
+	using ::min;
+#endif
+
+	//forward declaration
+	class WindowFunction;
+
+	enum WindowType : uint32_t
+	{
+		WindowRectangular = 0,
+		WindowHann = 1,
+		WindowHamming = 2,
+		WindowGauss = 3,
+		WindowINVALID = 4
+	};
+
+	class WindowFunctionGpu
+	{
+	public:
+		typedef float ElementType;
+
+		WindowFunctionGpu(const WindowFunctionGpu& a)
+			: m_numEntriesPerFunction(a.m_numEntriesPerFunction)
+			, m_data(a.m_data)
+			, m_scale(a.m_scale) {};
+
+		//Returns the weight of chosen window a the relative index 
+		// relativeIndex has to be normalized to [-1, 1] (inclusive)
+		inline ElementType get(float relativeIndex) const
+		{
+			float	 relativeIndexClamped = sycl::min(sycl::max(relativeIndex, -1.0f), 1.0f);
+			uint32_t absoluteIndex = static_cast<uint32_t>(sycl::round(m_scale * (relativeIndexClamped + 1.0f)));
+			return m_data[absoluteIndex];
+		}
+
+		//Returns the weight of chosen window a the relative index
+		// relativeIndex has to be normalized to [-1, 1] (inclusive)
+		inline ElementType getShared(const ElementType * __restrict__ sharedData, float relativeIndex) const
+		{
+			float	 relativeIndexClamped = sycl::min(sycl::max(relativeIndex, -1.0f), 1.0f);
+			uint32_t absoluteIndex = static_cast<uint32_t>(sycl::round(m_scale * (relativeIndexClamped + 1.0f)));
+			return sharedData[absoluteIndex];
+		}
+
+		inline ElementType getDirect(uint32_t idx) const
+		{
+			ElementType ret = 0;
+			if (idx < m_numEntriesPerFunction)
+			{
+				ret = m_data[idx];
+			}
+			return ret;
+		}
+
+		inline uint32_t numElements() const
+		{
+			return m_numEntriesPerFunction;
+		}
+
+	private:
+		friend WindowFunction;
+		WindowFunctionGpu(size_t numEntriesPerFunction, const ElementType* data)
+			: m_numEntriesPerFunction(static_cast<uint32_t>(numEntriesPerFunction))
+			, m_data(data)
+			, m_scale(static_cast<float>(numEntriesPerFunction - 1)*0.5f) {};
+
+		float m_scale;
+		uint32_t m_numEntriesPerFunction;
+		const ElementType* m_data;
+	};
+
+	class WindowFunction
+	{
+	public:
+		typedef WindowFunctionGpu::ElementType ElementType;
+
+		WindowFunction(WindowType type, ElementType windowParameter = 0.0, size_t numEntriesPerFunction = 128);
+
+		const WindowFunctionGpu* getGpu() const;
+
+		WindowType getType() const { return m_type; };
+		ElementType getParameter() const { return m_windowParameter; };
+
+		//Returns the weight of chosen window a the relative index
+		// relativeIndex has to be normalized to [-1, 1] (inclusive)
+		ElementType get(float relativeIndex) const;
+		ElementType getDirect(uint32_t idx) const;
+
+		// relativeIndex has to be normalized to [-1, 1] (inclusive)
+		template <typename T>
+		static inline T windowFunction(const WindowType& type, const T& relativeIndex, const T& windowParameter)
+		{
+			switch (type)
+			{
+			case WindowRectangular:
+				return 1.0;
+			case WindowHann:
+				return (1 - windowParameter)*(0.5f - 0.5f*std::cos(2*static_cast<T>(M_PI)*((relativeIndex + 1) *0.5f))) + windowParameter;
+			case WindowHamming:
+				return (1 - windowParameter)*(0.54f - 0.46f*std::cos(2*static_cast<T>(M_PI)*((relativeIndex + 1) *0.5f))) + windowParameter;
+			case WindowGauss:
+				return static_cast<T>(1.0 / (windowParameter * sycl::sqrt(2.0 * M_PI)) * exp((-1.0 / 2.0) * (relativeIndex / windowParameter) * (relativeIndex / windowParameter)));
+			default:
+				return 0;
+			}
+		}
+	private:
+		size_t m_numEntriesPerFunction;
+		std::vector<ElementType> m_data;
+		std::unique_ptr<Container<ElementType> > m_dataGpu;
+		ElementType m_scale;
+		WindowType m_type;
+		ElementType m_windowParameter;
+		WindowFunctionGpu m_gpuFunction;
+	};
+}
+
+#endif //!__WINDOWFUNCTION_H__
diff --git a/oneapi/src/SupraLib/Container.h b/oneapi/src/SupraLib/Container.h
new file mode 100644
index 0000000..c405d7a
--- /dev/null
+++ b/oneapi/src/SupraLib/Container.h
@@ -0,0 +1,336 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __CONTAINER_H__
+#define __CONTAINER_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "ContainerFactory.h"
+#ifdef HAVE_CUDA
+#include "utilities/cudaUtility.h"
+#endif
+#include "utilities/DataType.h"
+
+#include <exception>
+#include <memory>
+#include <vector>
+#include <cassert>
+#include <future>
+
+namespace supra
+{
+	class ContainerBase
+	{
+	public:
+		virtual ~ContainerBase() {};
+		virtual DataType getType() const { return TypeUnknown; };
+	};
+
+	template<typename T>
+	class Container : public ContainerBase
+	{
+	public:
+		typedef ContainerFactory::ContainerStreamType ContainerStreamType;
+
+		Container(ContainerLocation location, ContainerStreamType associatedStream, size_t numel)
+		{
+#ifndef HAVE_CUDA
+			location = LocationHost;
+#endif
+#ifdef HAVE_CUDA
+			m_creationEvent = nullptr;
+#endif
+			m_numel = numel;
+			m_location = location;
+			m_associatedStream = associatedStream;
+
+			m_buffer = reinterpret_cast<T*>(ContainerFactoryContainerInterface::acquireMemory(
+				m_numel * sizeof(T), m_location));
+		};
+		Container(ContainerLocation location, ContainerStreamType associatedStream, const std::vector<T> & data, bool waitFinished = true)
+			:Container(location, associatedStream, data.size())
+		{
+#ifdef HAVE_CUDA
+			if(location == LocationGpu)
+			{
+				/*
+				DPCT1003:10: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((associatedStream->memcpy(this->get(), data.data(), this->size() * sizeof(T)), 0));
+				createAndRecordEvent();
+			}
+			else if(location == LocationBoth)
+			{
+				/*
+				DPCT1003:11: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((associatedStream->memcpy(this->get(), data.data(), this->size() * sizeof(T)), 0));
+				createAndRecordEvent();
+			}
+			else
+			{
+				std::copy(data.begin(), data.end(), this->get());
+			}
+			if (waitFinished)
+			{
+				waitCreationFinished();
+			}
+#else
+			std::copy(data.begin(), data.end(), this->get());
+#endif
+		};
+		Container(ContainerLocation location, ContainerStreamType associatedStream, const T* dataBegin, const T* dataEnd, bool waitFinished = true)
+			:Container(location, associatedStream, dataEnd - dataBegin)
+		{
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:12: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((associatedStream->memcpy(this->get(), dataBegin, this->size() * sizeof(T)), 0));
+			createAndRecordEvent();
+			if (waitFinished)
+			{
+				waitCreationFinished();
+			}
+#else
+			std::copy(dataBegin, dataEnd, this->get());
+#endif
+		};
+		Container(ContainerLocation location, const Container<T>& source, bool waitFinished = true)
+			: Container(location, source.getStream(), source.size())
+		{
+			if (source.m_location == LocationHost && location == LocationHost)
+			{
+				std::copy(source.get(), source.get() + source.size(), this->get());
+			}
+#ifdef HAVE_CUDA
+			else if (source.m_location == LocationHost && location == LocationGpu)
+			{
+				/*
+				DPCT1003:13: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T))), 0));
+				createAndRecordEvent();
+			}
+			else if (source.m_location == LocationGpu && location == LocationHost)
+			{
+				/*
+				DPCT1003:14: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T))), 0));
+				createAndRecordEvent();
+			}
+			else if (source.m_location == LocationGpu && location == LocationGpu)
+			{
+				/*
+				DPCT1003:15: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T))), 0));
+				createAndRecordEvent();
+			}
+			else
+			{
+				/*
+				DPCT1003:16: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T))), 0));
+				createAndRecordEvent();
+			}
+			if (waitFinished)
+			{
+				waitCreationFinished();
+			}
+#else
+			std::copy(source.get(), source.get() + source.size(), this->get());
+#endif
+		};
+		~Container()
+		{
+#ifdef HAVE_CUDA
+			/*
+			DPCT1027:3: The call to cudaStreamQuery was replaced with 0, because DPC++ currently does not support query operations on queues.
+			*/
+			auto ret = 0;
+			if (ret != 0 && ret != 600 && ret != 4)
+			{
+				cudaSafeCall(ret);
+			}
+			// If the driver is currently unloading, we cannot free the memory in any way. Exit will clean up.
+			else if (ret != 4)
+			{
+				if (ret == 0)
+				{
+					ContainerFactoryContainerInterface::returnMemory(reinterpret_cast<uint8_t*>(m_buffer), m_numel * sizeof(T), m_location);
+				}
+				else
+				{
+					auto buffer = m_buffer;
+					auto numel = m_numel;
+					auto location = m_location;
+					addCallbackStream([ buffer, numel, location ](sycl::queue* s, int e) -> void {
+						ContainerFactoryContainerInterface::returnMemory(reinterpret_cast<uint8_t*>(buffer), numel * sizeof(T), location);
+					});
+				}
+			}
+#else
+			ContainerFactoryContainerInterface::returnMemory(reinterpret_cast<uint8_t*>(m_buffer), m_numel * sizeof(T), m_location);
+#endif
+		};
+
+		const T* get() const { return m_buffer; };
+		T* get() { return m_buffer; };
+
+		T* getCopyHostRaw() const
+		{
+#ifdef HAVE_CUDA
+			auto ret = new T[this->size()];
+			
+			if(m_location == LocationHost)
+			{
+				std::copy(this->get(), this->get() + this->size(), ret);
+			}
+			else if(m_location == LocationGpu)
+			{
+				/*
+				DPCT1003:17: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((getStream()->memcpy(ret, this->get(), this->size() * sizeof(T))), 0));
+				cudaSafeCall(cudaStreamSynchronize(getStream()));				
+			}
+			else 
+			{
+				/*
+				DPCT1003:18: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((dpct::get_default_queue().memcpy(ret, this->get(), this->size() * sizeof(T)).wait(), 0));
+			}
+			return ret;
+#else
+			return nullptr;
+#endif
+		}
+
+		void copyTo(T* dst, size_t maxSize) const
+		{
+#ifdef HAVE_CUDA
+			assert(maxSize >= this->size());
+			/*
+			DPCT1003:19: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((dpct::get_default_queue().memcpy(dst, this->get(), this->size() * sizeof(T)).wait(), 0));
+#endif
+		}
+
+		void waitCreationFinished()
+		{
+#ifdef HAVE_CUDA
+			if (m_creationEvent)
+			{
+				/*
+				DPCT1003:4: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((m_creationEvent.wait_and_throw(), 0));
+				/*
+				DPCT1027:5: The call to cudaEventDestroy was replaced with 0, because this call is redundant in DPC++.
+				*/
+				cudaSafeCall(0);
+				m_creationEvent = nullptr;
+			}
+#endif
+		}
+
+		// returns the number of elements that can be stored in this container
+		size_t size() const { return m_numel; };
+
+		bool isHost() const { return m_location == ContainerLocation::LocationHost; };
+		bool isGPU() const { return m_location == ContainerLocation::LocationGpu; };
+		bool isBoth() const { return m_location == ContainerLocation::LocationBoth; };
+		ContainerLocation getLocation() const { return m_location; };
+		ContainerStreamType getStream() const
+		{
+			return m_associatedStream;
+		}
+		DataType getType() const { return DataTypeGet<T>(); }
+
+	private:
+		void createAndRecordEvent()
+		{
+#ifdef HAVE_CUDA
+			if (!m_creationEvent)
+			{
+				//cudaSafeCall(cudaEventCreateWithFlags(&m_creationEvent, cudaEventBlockingSync | cudaEventDisableTiming));
+				/*
+				DPCT1027:6: The call to cudaEventCreateWithFlags was replaced with 0, because this call is redundant in DPC++.
+				*/
+				cudaSafeCall(0);
+			}
+			/*
+			DPCT1012:7: Detected kernel execution time measurement pattern and generated an initial code for time measurements in SYCL. You can change the way time is measured depending on your goals.
+			*/
+			/*
+			DPCT1024:8: The original code returned the error code that was further consumed by the program logic. This original code was replaced with 0. You may need to rewrite the program logic
+			consuming the error code.
+			*/
+			/*
+			DPCT1024:26: The original code returned the error code that was further consumed by the program logic. This original code was replaced with 0. You may need to rewrite the program logic
+			consuming the error code.
+			*/
+			/*
+			DPCT1024:29: The original code returned the error code that was further consumed by the program logic. This original code was replaced with 0. You may need to rewrite the program logic
+			consuming the error code.
+			*/
+			/*
+			DPCT1024:33: The original code returned the error code that was further consumed by the program logic. This original code was replaced with 0. You may need to rewrite the program logic
+			consuming the error code.
+			*/
+			m_creationEvent_ct1 = clock();
+			cudaSafeCall(0);
+#endif
+		}
+
+#ifdef HAVE_CUDA
+		void addCallbackStream(std::function<void(sycl::queue, *int)> func)
+		{
+			auto funcPointer = new std::function<void(sycl::queue, *int)>(func);
+			/*
+			DPCT1003:9: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((std::async([ & ]() {
+							  m_associatedStream->wait();
+							  &(Container<T>::cudaDeleteCallback)(m_associatedStream, 0, funcPointer);
+						  }),
+						  0));
+		}
+#endif
+
+#ifdef HAVE_CUDA
+		static void CUDART_CB cudaDeleteCallback(sycl::queue* stream, int status, void* userData)
+		{
+			std::unique_ptr<std::function<void(sycl::queue, *int)>> func = std::unique_ptr<std::function<void(sycl::queue, *int)>>(reinterpret_cast<std::function<void(sycl::queue, *int)>*>(userData));
+			(*func)(stream, status);
+		}
+#endif
+		// The number of elements this container can store
+		size_t m_numel;
+		ContainerLocation m_location;
+
+		ContainerStreamType m_associatedStream;
+		T* m_buffer;
+
+#ifdef HAVE_CUDA
+		sycl::event m_creationEvent;
+		clock_t		m_creationEvent_ct1;
+#endif
+	};
+}
+
+#endif //!__CONTAINER_H__
diff --git a/oneapi/src/SupraLib/ContainerFactory.cpp.dp.cpp b/oneapi/src/SupraLib/ContainerFactory.cpp.dp.cpp
new file mode 100644
index 0000000..18f428d
--- /dev/null
+++ b/oneapi/src/SupraLib/ContainerFactory.cpp.dp.cpp
@@ -0,0 +1,290 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2017, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "ContainerFactory.h"
+
+#include <utilities/Logging.h>
+#include <utilities/utility.h>
+
+#include <sstream>
+#include <cassert>
+using namespace std;
+
+namespace supra
+{
+	ContainerFactory::ContainerStreamType ContainerFactory::getNextStream()
+	{
+		std::lock_guard<std::mutex> streamLock(sm_streamMutex);
+
+		if (sm_streams.size() == 0)
+		{
+			initStreams();
+		}
+
+		size_t streamIndex = sm_streamIndex;
+		sm_streamIndex = (sm_streamIndex + 1) % sm_numberStreams;
+		return sm_streams[streamIndex];
+	}
+	uint8_t* ContainerFactory::acquireMemory(size_t numBytes, ContainerLocation location)
+	{
+		assert(location < LocationINVALID);
+		
+		// Check whether the queue for this location and size has a buffer left
+		uint8_t* buffer = nullptr;
+		{
+			// by directly accessing the desired length in the map sm_bufferMaps[location],
+			// the map entry is created if it does not already exist. That means the map is
+			// modified here
+			tbb::concurrent_queue<std::pair<uint8_t*, double> >* queuePointer =
+				&(sm_bufferMaps[location][numBytes]);
+
+			std::pair<uint8_t*, double> queueEntry;
+			if (queuePointer->try_pop(queueEntry))
+			{
+				// If yes, just return this already allocated buffer
+				buffer = queueEntry.first;
+			}
+		}
+
+		// If the queue did not contain a buffer, allocate a new one
+		if (!buffer)
+		{
+			// Check whether there is enough free space for the requested buffer. 
+			size_t memoryFree;
+#ifdef HAVE_CUDA
+			size_t memoryTotal;
+			if (location == LocationGpu || location == LocationBoth)
+			{
+				cudaSafeCall(cudaMemGetInfo(&memoryFree, &memoryTotal));
+				memoryFree = static_cast<size_t>(std::max(static_cast<double>(memoryFree) - (static_cast<double>(memoryTotal) * 0.02), 0.0));
+			}
+			else
+#endif
+			{
+				// For the host memory we just rely on the 
+				memoryFree = numBytes;
+			}
+
+			// If not, relase enough unused buffers, starting with the ones that have been returned the longest time ago.
+			if (memoryFree < numBytes)
+			{
+				freeBuffers(numBytes, location);
+			}
+
+			// additionaly, release memory that has been returned over XX (e.g. 30) seconds ago
+			freeOldBuffers();
+
+			// Now that we have made the required memory available, we can allocate the buffer
+			buffer = allocateMemory(numBytes, location);
+		}
+
+		return buffer;
+	}
+
+	void ContainerFactory::returnMemory(uint8_t* pointer, size_t numBytes, ContainerLocation location)
+	{
+		assert(location < LocationINVALID);
+
+		// do not free here, just put it back to the queues with the time it was returned at
+		double returnTime = getCurrentTime();
+
+		// Put buffer back to queue
+		{
+			tbb::concurrent_queue<std::pair<uint8_t*, double> >* queuePointer =
+				&(sm_bufferMaps[location][numBytes]);
+
+			queuePointer->push(std::make_pair(pointer, returnTime));
+		}
+	}
+	void ContainerFactory::initStreams()
+	{
+		logging::log_log("ContainerFactory: Initializing ", sm_numberStreams, " streams.");
+		sm_streamIndex = 0;
+#ifdef HAVE_CUDA
+		sm_streams.resize(sm_numberStreams);
+		for (size_t k = 0; k < sm_numberStreams; k++)
+		{
+			/*
+			DPCT1003:37: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			/*
+			DPCT1025:38: The SYCL queue is created ignoring the flag/priority options.
+			*/
+			cudaSafeCall(((sm_streams[ k ]) = dpct::get_current_device().create_queue(), 0));
+		}
+#else
+		sm_streams.resize(sm_numberStreams, 0);
+#endif
+	}
+
+	uint8_t * ContainerFactory::allocateMemory(size_t numBytes, ContainerLocation location)
+	{
+		dpct::device_ext& dev_ct1 = dpct::get_current_device();
+		sycl::queue&	  q_ct1 = dev_ct1.default_queue();
+		uint8_t* buffer = nullptr;
+		switch (location)
+		{
+		case LocationGpu:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:39: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((buffer = ( uint8_t* )sycl::malloc_device(numBytes, q_ct1), 0));
+#endif
+			break;
+		case LocationBoth:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:40: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((buffer = ( uint8_t* )sycl::malloc_shared(numBytes, q_ct1), 0));
+#endif
+			break;
+		case LocationHost:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:41: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((buffer = ( uint8_t* )sycl::malloc_host(numBytes, q_ct1), 0));
+#else
+			buffer = new uint8_t[numBytes];
+#endif
+			break;
+		default:
+			throw std::runtime_error("invalid argument: Container: Unknown location given");
+		}
+		if (!buffer)
+		{
+			std::stringstream s;
+			s << "bad alloc: Container: Error allocating buffer of size " << numBytes << " in "
+				<< (location == LocationHost ? "LocationHost" : (location == LocationGpu ? "LocationGpu" : "LocationBoth"));
+			throw std::runtime_error(s.str());
+		}
+
+		return buffer;
+	}
+
+	void ContainerFactory::freeBuffers(size_t numBytesMin, ContainerLocation location)
+	{
+		size_t numBytesFreed = 0;
+		size_t numBuffersFreed;
+		do 
+		{
+			numBuffersFreed = 0;
+			// by traversing the map sm_bufferMaps[location] we never create new entries, but only modifiy those already present.
+			for (auto mapIterator = sm_bufferMaps[location].begin(); mapIterator != sm_bufferMaps[location].end(); mapIterator++)
+			{
+				size_t numBytesBuffer = mapIterator->first;
+				std::pair<uint8_t*, double> queueEntry;
+				if(mapIterator->second.try_pop(queueEntry))
+				{
+					// If there is an element in this queue, remove it and free the memory
+					freeMemory(queueEntry.first, numBytesBuffer, location);
+					numBytesFreed += numBytesBuffer;
+					numBuffersFreed++;
+				}
+			}
+		} while (numBytesFreed < numBytesMin && numBuffersFreed > 0);
+	}
+
+	void ContainerFactory::freeOldBuffers()
+	{
+		double currentTime = getCurrentTime();
+		double deleteTime = currentTime - sm_deallocationTimeout;
+		for (ContainerLocation location = LocationHost; location < LocationINVALID; location = static_cast<ContainerLocation>(location + 1))
+		{
+			for (auto mapIterator = sm_bufferMaps[location].begin(); mapIterator != sm_bufferMaps[location].end(); mapIterator++)
+			{
+				size_t numBytesBuffer = mapIterator->first;
+
+				double lastTime = 0.0;
+				while(!mapIterator->second.empty() && lastTime < deleteTime)
+				{
+					// If there is an element in this queue, remove it and free the memory
+					std::pair<uint8_t*, double> bufferPair;
+					if (mapIterator->second.try_pop(bufferPair))
+					{
+						lastTime = bufferPair.second;
+						if (lastTime < deleteTime)
+						{
+							freeMemory(bufferPair.first, numBytesBuffer, location);
+						}
+						else
+						{
+							// oops, we should not have taken that element from the queue. Let's just put it back.
+							// Yes, it will be in the wrong temporal order, but that will be solved in a while on its own
+							mapIterator->second.push(bufferPair);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	void ContainerFactory::garbageCollectionThreadFunction()
+	{
+		sm_garbageCollectionThread.detach();
+		while (true)
+		{
+			ContainerFactory::freeOldBuffers();
+			std::this_thread::sleep_for(std::chrono::duration<double>(sm_deallocationTimeout));
+		}
+	}
+
+	void ContainerFactory::freeMemory(uint8_t * pointer, size_t numBytes, ContainerLocation location)
+	{
+		dpct::device_ext& dev_ct1 = dpct::get_current_device();
+		sycl::queue&	  q_ct1 = dev_ct1.default_queue();
+		switch (location)
+		{
+		case LocationGpu:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:42: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			(sycl::free(pointer, q_ct1), 0);
+#endif
+			break;
+		case LocationBoth:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:43: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			(sycl::free(pointer, q_ct1), 0);
+#endif
+			break;
+		case LocationHost:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:44: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			(sycl::free(pointer, q_ct1), 0);
+#else
+			delete[] pointer;
+#endif
+			break;
+		default:
+			break;
+		}
+	}
+
+	std::vector<ContainerFactory::ContainerStreamType> ContainerFactory::sm_streams = {};
+	size_t ContainerFactory::sm_streamIndex = 0;
+	std::mutex ContainerFactory::sm_streamMutex;
+
+	constexpr double ContainerFactory::sm_deallocationTimeout;
+
+	std::array<tbb::concurrent_unordered_map<size_t, tbb::concurrent_queue<std::pair<uint8_t*, double> > >, LocationINVALID> ContainerFactory::sm_bufferMaps;
+
+	std::thread ContainerFactory::sm_garbageCollectionThread(&ContainerFactory::garbageCollectionThreadFunction);
+}
diff --git a/oneapi/src/SupraLib/ContainerFactory.h b/oneapi/src/SupraLib/ContainerFactory.h
new file mode 100644
index 0000000..e39c914
--- /dev/null
+++ b/oneapi/src/SupraLib/ContainerFactory.h
@@ -0,0 +1,79 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2017, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __CONTAINERFACTORY_H__
+#define __CONTAINERFACTORY_H__
+
+#ifdef HAVE_CUDA
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "utilities/cudaUtility.h"
+#endif
+
+#include <vector>
+#include <mutex>
+#include <thread>
+#include <tbb/concurrent_unordered_map.h>
+#include <tbb/concurrent_queue.h>
+
+namespace supra
+{
+	enum ContainerLocation
+	{
+		LocationHost,
+		LocationGpu,
+		LocationBoth,
+		LocationINVALID
+	};
+
+	class ContainerFactory
+	{
+	public:
+#ifdef HAVE_CUDA
+		typedef sycl::queue* ContainerStreamType;
+#else
+		typedef int ContainerStreamType;
+#endif
+		
+		static ContainerStreamType getNextStream();
+
+	protected:
+		static uint8_t* acquireMemory(size_t numBytes, ContainerLocation location);
+		static void returnMemory(uint8_t* pointer, size_t numBytes, ContainerLocation location);
+
+	private:
+		static void initStreams();
+	
+		static constexpr size_t sm_numberStreams = 8;
+
+		static std::vector<ContainerStreamType> sm_streams;
+		static size_t sm_streamIndex;
+		static std::mutex sm_streamMutex;
+
+		static constexpr double sm_deallocationTimeout = 60; // [seconds]
+
+		static uint8_t* allocateMemory(size_t numBytes, ContainerLocation location);
+		static void freeBuffers(size_t numBytesMin, ContainerLocation location);
+		static void freeOldBuffers();
+		static void garbageCollectionThreadFunction();
+		static void freeMemory(uint8_t* pointer, size_t numBytes, ContainerLocation location);
+
+		static std::array<tbb::concurrent_unordered_map<size_t, tbb::concurrent_queue<std::pair<uint8_t*, double> > >, LocationINVALID> sm_bufferMaps;
+		static std::thread sm_garbageCollectionThread;
+	};
+
+	class ContainerFactoryContainerInterface : public ContainerFactory
+	{
+		template <typename T> friend class Container;
+	};
+}
+
+#endif //!__CONTAINERFACTORY_H__
diff --git a/oneapi/src/SupraLib/RecordObject.h b/oneapi/src/SupraLib/RecordObject.h
new file mode 100644
index 0000000..7c4ad1f
--- /dev/null
+++ b/oneapi/src/SupraLib/RecordObject.h
@@ -0,0 +1,64 @@
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+// ================================================================================================
+//
+// If not explicitly stated: Copyright (C) 2011-2016, all rights reserved,
+//      Christoph Hennersperger
+//		EmaiL christoph.hennersperger@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+//	and
+//		Rüdiger Göbl
+//		Email r.goebl@tum.de
+//
+// ================================================================================================
+
+#ifndef __RECORDOBJECT_H__
+#define __RECORDOBJECT_H__
+
+namespace supra
+{
+	/// Enum for the different types of data distributed within the dataflow graph
+	enum RecordObjectType {
+		TypeSyncRecordObject,
+		TypeTrackerDataSet,
+		TypeUSImage,
+		TypeUSRawData,
+		TypeRecordUnknown
+	};
+
+	//const char* RecordObjectTypeToString(RecordObjectType t);
+
+	/// Base class for all RecordObjects
+	class RecordObject
+	{
+
+	public:
+		/// Constructor that takes the two timestamps:
+		///		receiveTimestamp is the timestamp (in seconds) at which this dataset initially was recieved
+		///		syncTimestamp is the timestamp (in seconds) after optinal temporal synchronization
+		RecordObject(double receiveTimestamp, double syncTimestamp) : m_receiveTimestamp(receiveTimestamp), m_syncTimestamp(syncTimestamp) {};
+		/// Base constructor
+		RecordObject() : m_receiveTimestamp(0.0), m_syncTimestamp(0.0) {};
+		virtual ~RecordObject() {};
+
+		/// Returns the receive timestamp (in seconds), that is the time at which this dataset initially was recieved
+		inline double getReceiveTimestamp() const { return m_receiveTimestamp; };
+		/// Returns the snyc timestamp (in seconds), that is after optinal temporal synchronization
+		inline double getSyncTimestamp() const { return m_syncTimestamp; };
+		/// Apply a temporal offset to the original timestamp to perform temporal synchronization
+		inline void setSyncOffset(double temporalOffset) { m_syncTimestamp = m_receiveTimestamp + temporalOffset; };
+
+		/// Returns the type of the dataset. Overwritten in subclasses.
+		virtual RecordObjectType getType() const { return TypeRecordUnknown; }
+
+	protected:
+		/// The receive timestamp(in seconds), that is the time at which this dataset initially was recieved
+		double m_syncTimestamp;
+		/// The snyc timestamp (in seconds), that is after optinal temporal synchronization
+		double m_receiveTimestamp;
+	};
+}
+
+#endif // !__RECORDOBJECT_H__
diff --git a/oneapi/src/SupraLib/USImage.h b/oneapi/src/SupraLib/USImage.h
new file mode 100644
index 0000000..80e2c92
--- /dev/null
+++ b/oneapi/src/SupraLib/USImage.h
@@ -0,0 +1,133 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __USIMAGE_H__
+#define __USIMAGE_H__
+
+#include <memory>
+#include <stddef.h>
+
+#include "Container.h"
+#include "RecordObject.h"
+#include "USImageProperties.h"
+#include "vec.h"
+
+namespace supra
+{
+	/// A compute graph object that represents an ultrasound image with elements of type ElementType.
+	/// Can contain 2D and 3D images and both before scansconversion (that is samples aling scanlines) and
+	/// images / volumes after scanconversion are supported
+	class USImage : public RecordObject
+	{
+	public:
+		USImage() : m_dimensions(0), m_size{}, m_pData(nullptr) {};
+		/// Constructs a 3D Image
+		USImage(size_t size1,
+			size_t size2,
+			size_t size3,
+			std::shared_ptr<ContainerBase> pData,
+			std::shared_ptr<const USImageProperties> pImageProperties,
+			double receiveTimestamp,
+			double syncTimestamp)
+			: RecordObject(receiveTimestamp, syncTimestamp)
+			, m_pImageProperties(pImageProperties)
+			, m_dimensions(3)
+			, m_size{ size1, size2, size3 }
+		, m_pData(pData) {};
+		/// Constructs a 2D Image
+		USImage(size_t size1,
+			size_t size2,
+			std::shared_ptr<ContainerBase> pData,
+			std::shared_ptr<const USImageProperties> pImageProperties,
+			double receiveTimestamp, double syncTimestamp)
+			: RecordObject(receiveTimestamp, syncTimestamp)
+			, m_pImageProperties(pImageProperties)
+			, m_dimensions(2)
+			, m_size{ size1, size2, 1 }
+		, m_pData(pData) {};
+		/// Constructs a 3D or 2D Image.
+		/// If size.z == 1, the image is 2D.
+		USImage(vec3s size,
+			std::shared_ptr<ContainerBase> pData,
+			std::shared_ptr<const USImageProperties> pImageProperties,
+			double receiveTimestamp, double syncTimestamp)
+			: RecordObject(receiveTimestamp, syncTimestamp)
+			, m_pImageProperties(pImageProperties)
+			, m_dimensions(3)
+			, m_size(size)
+			, m_pData(pData)
+		{
+			if (size.z == 1)
+			{
+				m_dimensions = 2;
+			}
+		};
+		/// Constructs a 2D Image
+		USImage(vec2s size,
+			std::shared_ptr<ContainerBase> pData,
+			std::shared_ptr<const USImageProperties> pImageProperties,
+			double receiveTimestamp,
+			double syncTimestamp)
+			: RecordObject(receiveTimestamp, syncTimestamp)
+			, m_pImageProperties(pImageProperties)
+			, m_dimensions(2)
+			, m_pData(pData)
+		{
+			m_size.x = size.x;
+			m_size.y = size.y;
+			m_size.z = 1;
+		};
+		/// Copy constructor. Copies image metadata and the pointer to the data.
+		USImage(const USImage& a)
+			: RecordObject(a)
+			, m_dimensions(a.m_dimensions)
+			, m_size(a.m_size)
+			, m_pData(a.m_pData)
+			, m_pImageProperties(a.m_pImageProperties) {};
+		/// Special copy constructor, copies image metadata from the given image,
+		/// but uses the given Container for data
+		USImage(const USImage& a, std::shared_ptr<ContainerBase> pData)
+			: RecordObject(a)
+			, m_dimensions(a.m_dimensions)
+			, m_size(a.m_size)
+			, m_pData(pData)
+			, m_pImageProperties(a.m_pImageProperties) {};
+
+		//~USImage();
+		/// Returns a pointer to the \see USImageProperties that contain the associated metadata
+		std::shared_ptr<const USImageProperties> getImageProperties() const { return m_pImageProperties; };
+		/// Sets the \see USImageProperties that contain the associated metadata
+		void setImageProperties(std::shared_ptr<USImageProperties> & imageProperties) { m_pImageProperties = imageProperties; };
+		/// Returns the size of the image. If it is 2D, `getSize().z == 1`
+		vec3s getSize() const { return m_size; };
+		/// Returns a pointer to the image data
+		template <typename ElementType>
+		std::shared_ptr<const Container<ElementType> > getData() const
+		{
+			return std::dynamic_pointer_cast<const Container<ElementType> >(m_pData);
+		}
+
+		virtual RecordObjectType getType() const { return TypeUSImage; }
+		DataType getDataType() const { return m_pData->getType(); }
+
+	private:
+		std::shared_ptr<const USImageProperties> m_pImageProperties;
+
+		std::shared_ptr<ContainerBase> m_pData;
+
+		//number of image dimensions
+		int m_dimensions;
+		//the size of the image buffer (i.e. m_pData->size() == prod(m_size))
+		vec3s m_size;
+	};
+}
+
+#endif //!__USIMAGE_H__
diff --git a/oneapi/src/SupraLib/USImageProperties.h b/oneapi/src/SupraLib/USImageProperties.h
new file mode 100644
index 0000000..26b2f87
--- /dev/null
+++ b/oneapi/src/SupraLib/USImageProperties.h
@@ -0,0 +1,210 @@
+// ================================================================================================
+// 
+// Copyright (C) 2016, Rüdiger Göbl - all rights reserved
+// Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.
+//
+//          Rüdiger Göbl
+//          Email r.goebl@tum.de
+//          Chair for Computer Aided Medical Procedures
+//          Technische Universität München
+//          Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License, version 2.1, as published by the Free Software Foundation.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this program.  If not, see
+// <http://www.gnu.org/licenses/>.
+//
+// ================================================================================================
+
+#ifndef __USIMAGEPROPERTIES_H__
+#define __USIMAGEPROPERTIES_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <memory>
+#include <vector>
+#include <map>
+#include "vec.h"
+
+#include <iostream>
+#include <iomanip>
+
+#include <utilities/utility.h>
+
+namespace supra
+{
+	// The receive parameters for one scanline
+	struct ScanlineRxParameters3D
+	{
+		ScanlineRxParameters3D()
+			: txParameters{ {{0,0}, {0,0}, 0, 0} }
+			, position{ 0.0, 0.0, 0.0 }
+			, direction{ 0.0, 0.0, 0.0 }
+			, maxElementDistance{ 0.0, 0.0 }
+		{}
+
+		struct TransmitParameters {
+			vec2T<uint16_t> firstActiveElementIndex;	// index of the first active transducer element
+			vec2T<uint16_t> lastActiveElementIndex;		// index of the last active transducer element
+			uint16_t  txScanlineIdx;		// index of the corresponsing transmit scanline
+			double initialDelay;			// the minmal delay in [s] that is to be used during rx
+
+			bool operator== (const TransmitParameters& b) const
+			{
+				return firstActiveElementIndex == b.firstActiveElementIndex &&
+					lastActiveElementIndex == b.lastActiveElementIndex &&
+					txScanlineIdx == b.txScanlineIdx &&
+					initialDelay == b.initialDelay;
+			}
+		};
+
+		vec position;	                // the position of the scanline
+		vec direction;                  // direction of the scanline
+		double txWeights[4];            // Weights for interpolation between different transmits
+		TransmitParameters txParameters[4]; // Parameters of the transmits to use
+		vec2 maxElementDistance;		// maximum distance of an element to the scanline start, used to compute rxWeights
+
+		vec getPoint(double depth) const
+		{
+			return position + depth*direction;
+		}
+
+		bool operator== (const ScanlineRxParameters3D& b) const
+		{
+			return txParameters[0] == b.txParameters[0] &&
+				txParameters[1] == b.txParameters[1] &&
+				txParameters[2] == b.txParameters[2] &&
+				txParameters[3] == b.txParameters[3] &&
+				txWeights[0] == b.txWeights[0] &&
+				txWeights[1] == b.txWeights[1] &&
+				txWeights[2] == b.txWeights[2] &&
+				txWeights[3] == b.txWeights[3] &&
+				position == b.position &&
+				direction == b.direction &&
+				maxElementDistance == b.maxElementDistance;
+		}
+
+		friend std::ostream& operator<< (std::ostream& os, const ScanlineRxParameters3D& params);
+		friend std::istream& operator>> (std::istream& is, ScanlineRxParameters3D& params);
+	};
+
+
+	class USImageProperties
+	{
+	public:
+		enum ImageType {
+			BMode,
+			Doppler,
+			Planewave
+		};
+
+		enum ImageState {
+			Raw,
+			RawDelayed,
+			RF,
+			EnvDetected,
+			PreScan,
+			Scan
+		};
+		enum TransducerType {
+			Linear,
+			Phased,
+			Curved,
+			Planar,
+			PlanarPhased,
+			Bicurved
+		};
+
+		USImageProperties();
+		USImageProperties(vec2s scanlineLayout, size_t numSamples, USImageProperties::ImageType imageType, USImageProperties::ImageState imageState, USImageProperties::TransducerType transducerType, double depth);
+		USImageProperties(const USImageProperties& a);
+		USImageProperties(const std::string & mockJsonMetadataFilename);
+
+	public:
+		/////////////////////////////////////////////////////////////////////
+		// simple setters for defining properties
+		/////////////////////////////////////////////////////////////////////
+		void setImageType(USImageProperties::ImageType imageType);	// Defines the type of information contained in the image
+		void setImageState(USImageProperties::ImageState imageState);	// Describes the state the image is currently in
+		void setTransducerType(USImageProperties::TransducerType transducerType);	// Defines the type of transducer
+		void setScanlineLayout(vec2s scanlineLayout);	// number of scanlines acquired
+		void setNumSamples(size_t numSamples);		// number of samples acquired on each scanline
+		void setDepth(double depth);					// depth covered
+		void setImageResolution(double resolution);  // the resolution of the scanConverted image
+
+
+		void setScanlineInfo(std::shared_ptr<std::vector<std::vector<ScanlineRxParameters3D> > > scanlines);
+
+		template <typename valueType>
+		void setSpecificParameter(std::string parameterName, valueType value);	// set one interface-specific parameter
+
+		void writeMetaDataForMock(std::string filename) const;
+
+		/////////////////////////////////////////////////////////////////////
+		// simple getters
+		/////////////////////////////////////////////////////////////////////
+		USImageProperties::ImageType getImageType() const;				// Defines the type of information contained in the image
+		USImageProperties::ImageState getImageState() const;			// Describes the state the image is currently in
+		USImageProperties::TransducerType getTransducerType() const;	// Defines the type of transducer
+		size_t getNumScanlines() const;			// number of scanlines acquired
+		vec2s getScanlineLayout() const;
+		size_t getNumSamples() const;				// number of samples acquired on each scanline
+		double getDepth() const;					// depth covered
+
+
+		std::shared_ptr<std::vector<std::vector<ScanlineRxParameters3D> > > getScanlineInfo() const;
+
+		bool  hasSpecificParameter(std::string parameterName) const;					// whether one interface-specific parameter exists
+		const std::string&  getSpecificParameter(std::string parameterName) const;	// get one interface-specific parameter
+		const std::map<std::string, std::string>&  getSpecificParameters() const;	// map to the interface-specific parameters
+
+		/////////////////////////////////////////////////////////////////////
+		// Dependent properties, i.e. they only have a getter that computes the return value
+		/////////////////////////////////////////////////////////////////////
+		double getSampleDistance() const;		// distance between samples of the scanlines
+		double getImageResolution() const;		// spatial resolution of image
+		bool is2D() const;
+
+	private:
+		/////////////////////////////////////////////////////////////////////
+		// Defining properties
+		/////////////////////////////////////////////////////////////////////
+		USImageProperties::ImageType m_imageType;			// Defines the type of information contained in the image
+		USImageProperties::ImageState m_imageState;			// Describes the state the image is currently in
+		USImageProperties::TransducerType m_transducerType;	// Defines the type of transducer
+		size_t m_numScanlines;				// number of scanlines acquired
+		vec2s m_scanlineLayout;
+		size_t m_numSamples;					// number of samples acquired on each scanline
+		double m_depth;						// depth covered
+		bool m_imageResolutionSet;			// whether explicit image resolution has been set
+		double m_imageResolution;			// explicit image resolution
+
+
+		// Map for interface specific parameters, they do not define the image itself but its meaning
+		std::map<std::string, std::string> m_specificParameters;
+
+		std::shared_ptr<std::vector<std::vector<ScanlineRxParameters3D> > > m_scanlines;
+	};
+
+	template<typename valueType>
+	inline void USImageProperties::setSpecificParameter(std::string parameterName, valueType value)
+	{
+		m_specificParameters[parameterName] = stringify(value);
+	}
+
+	template<>
+	inline void USImageProperties::setSpecificParameter<std::string>(std::string parameterName, std::string value)
+	{
+		m_specificParameters[parameterName] = value;
+	}
+}
+
+#endif //!__USIMAGEPROPERTIES_H__
diff --git a/oneapi/src/SupraLib/utilities/DataType.h b/oneapi/src/SupraLib/utilities/DataType.h
new file mode 100644
index 0000000..6a97bba
--- /dev/null
+++ b/oneapi/src/SupraLib/utilities/DataType.h
@@ -0,0 +1,90 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2017, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __DATATYPE_H__
+#define __DATATYPE_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <stdint.h>
+#include <string>
+#include "utilities/utility.h"
+
+#ifdef HAVE_CUDA
+#endif
+
+namespace supra
+{
+	/// Enum for the types used in containers and by the parameter system
+	enum DataType
+	{
+		TypeBool,
+		TypeInt8,
+		TypeUint8,
+		TypeInt16,
+		TypeUint16,
+		TypeInt32,
+		TypeUint32,
+		TypeInt64,
+		TypeUint64,
+#ifdef HAVE_CUDA
+		TypeHalf,
+#endif
+		TypeFloat,
+		TypeDouble,
+		TypeString,
+		TypeDataType,
+		TypeUnknown
+	};
+
+	template <typename T>
+	DataType DataTypeGet()
+	{
+		return TypeUnknown;
+	}
+
+	template <>
+	DataType DataTypeGet<bool>();
+	template <>
+	DataType DataTypeGet<int8_t>();
+	template <>
+	DataType DataTypeGet<uint8_t>();
+	template <>
+	DataType DataTypeGet<int16_t>();
+	template <>
+	DataType DataTypeGet<uint16_t>();
+	template <>
+	DataType DataTypeGet<int32_t>();
+	template <>
+	DataType DataTypeGet<uint32_t>();
+	template <>
+	DataType DataTypeGet<int64_t>();
+	template <>
+	DataType DataTypeGet<uint64_t>();
+#ifdef HAVE_CUDA
+	template <> DataType DataTypeGet<sycl::half>();
+#endif
+	template <>
+	DataType DataTypeGet<float>();
+	template <>
+	DataType DataTypeGet<double>();
+	template <>
+	DataType DataTypeGet<std::string>();
+	template <>
+	DataType DataTypeGet<DataType>();
+
+	DataType DataTypeFromString(const std::string& s, bool* sucess = nullptr);
+	std::string DataTypeToString(DataType t, bool* success = nullptr);
+	std::ostream& operator<<(std::ostream& os, DataType dataType);
+	std::istream& operator>>(std::istream& is, DataType& dataType);
+}
+
+#endif // !__DATATYPE_H__
diff --git a/oneapi/src/SupraLib/utilities/FirFilterFactory.h b/oneapi/src/SupraLib/utilities/FirFilterFactory.h
new file mode 100644
index 0000000..3ebfe74
--- /dev/null
+++ b/oneapi/src/SupraLib/utilities/FirFilterFactory.h
@@ -0,0 +1,236 @@
+// ================================================================================================
+// 
+// Copyright (C) 2016, Rüdiger Göbl - all rights reserved
+// Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.
+//
+//          Rüdiger Göbl
+//          Email r.goebl@tum.de
+//          Chair for Computer Aided Medical Procedures
+//          Technische Universität München
+//          Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License, version 2.1, as published by the Free Software Foundation.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this program.  If not, see
+// <http://www.gnu.org/licenses/>.
+//
+// ================================================================================================
+
+#ifndef __FIRFILTERFACTORY_H__
+#define __FIRFILTERFACTORY_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <memory>
+#include <functional>
+#include "Container.h"
+#include <cmath>
+
+namespace supra
+{
+	/// A factory for FIR filters
+	class FirFilterFactory {
+	public:
+		/// Enum for the different filter types
+		enum FilterType {
+			FilterTypeLowPass,
+			FilterTypeHighPass,
+			FilterTypeBandPass,
+			FilterTypeHilbertTransformer
+		};
+
+		/// Enum for the different window types used in creating filters
+		enum FilterWindow {
+			FilterWindowRectangular,
+			FilterWindowHann,
+			FilterWindowHamming,
+			FilterWindowKaiser
+		};
+
+		/// Returns a FIR filter constructed with the window-method
+		template <typename ElementType>
+		static std::shared_ptr<Container<ElementType> >
+			createFilter(const size_t &length, const FilterType &type, const FilterWindow &window, const double &samplingFrequency = 2.0, const double &frequency = 0.0, const double &bandwidth = 0.0)
+		{
+			std::shared_ptr<Container<ElementType> > filter = createFilterNoWindow<ElementType>(length, type, samplingFrequency, frequency, bandwidth);
+			applyWindowToFilter<ElementType>(filter, window);
+			if (type == FilterTypeBandPass)
+			{
+				normalizeGain<ElementType>(filter, samplingFrequency, frequency);
+			}
+
+			return filter;
+		}
+
+	private:
+		template <typename ElementType>
+		static std::shared_ptr<Container<ElementType> >
+			createFilterNoWindow(const size_t &length, const FilterType &type, const double &samplingFrequency, const double &frequency, const double &bandwidth)
+		{
+			if (type == FilterTypeHighPass || type == FilterTypeBandPass || type == FilterTypeLowPass)
+			{
+				assert(samplingFrequency != 0.0);
+				assert(frequency != 0.0);
+			}
+			if (type == FilterTypeBandPass)
+			{
+				assert(bandwidth != 0.0);
+			}
+
+			ElementType omega = static_cast<ElementType>(2 * M_PI* frequency / samplingFrequency);
+			ElementType omegaBandwidth = static_cast<ElementType>(2 * M_PI* bandwidth / samplingFrequency);
+			int halfWidth = ((int)length - 1) / 2;
+
+			auto filter = std::make_shared<Container<ElementType> >(LocationHost, cudaStreamPerThread, length);
+
+			//determine the filter function
+			std::function<ElementType(int)> filterFunction = [&halfWidth](int n) -> ElementType {
+				if (n == halfWidth)
+				{
+					return static_cast<ElementType>(1);
+				}
+				else {
+					return static_cast<ElementType>(0);
+				}
+			};
+			switch (type)
+			{
+			case FilterTypeHilbertTransformer:
+				// Following formula 2 in
+				// "Carrick, Matt, and Doug Jaeger. "Design and Application of a Hilbert Transformer in a Digital Receiver." (2011)."
+				filterFunction = [halfWidth](int n) -> ElementType {
+					auto k = (n - halfWidth);
+					if (k % 2 == 0)
+					{
+						return static_cast<ElementType>(0);
+					}
+					else
+					{
+						return static_cast<ElementType>(2.0 / (M_PI * k));
+					}
+				};
+				break;
+			case FilterTypeHighPass:
+				filterFunction = [omega, halfWidth](int n) -> ElementType {
+					if (n == halfWidth)
+					{
+						return static_cast<ElementType>(1 - omega / M_PI);
+					}
+					else {
+						return static_cast<ElementType>(-omega / M_PI * sin(omega * (n - halfWidth)) / (omega * (n - halfWidth)));
+					}
+				};
+				break;
+			case FilterTypeBandPass:
+				filterFunction = [omega, omegaBandwidth, halfWidth](int n) -> ElementType {
+					if (n == halfWidth)
+					{
+						return static_cast<ElementType>(2.0 * omegaBandwidth / M_PI);
+					}
+					else {
+						return static_cast<ElementType>(2.0 * cos(omega * n - halfWidth) * omegaBandwidth / M_PI * sin(omegaBandwidth * (n - halfWidth)) / (omegaBandwidth * (n - halfWidth)));
+					}
+				};
+				break;
+			case FilterTypeLowPass:
+			default:
+				filterFunction = [omega, halfWidth](int n) -> ElementType {
+					if (n == halfWidth)
+					{
+						return static_cast<ElementType>(omega / M_PI);
+					}
+					else {
+						return static_cast<ElementType>(omega / M_PI * sin(omega * (n - halfWidth)) / (omega * (n - halfWidth)));
+					}
+				};
+				break;
+			}
+
+			//create the filter
+			for (size_t k = 0; k < length; k++)
+			{
+				filter->get()[k] = filterFunction((int)k);
+			}
+
+			return filter;
+		}
+
+		template <typename ElementType>
+		static void applyWindowToFilter(std::shared_ptr<Container<ElementType> > filter, FilterWindow window)
+		{
+			size_t filterLength = filter->size();
+			size_t maxN = filterLength - 1;
+			ElementType beta = (ElementType)4.0;
+			std::function<ElementType(int)> windowFunction = [filterLength](int n) -> ElementType { return static_cast<ElementType>(1); };
+			switch (window)
+			{
+			case FilterWindowHann:
+				windowFunction = [maxN](int n) -> ElementType {
+					return static_cast<ElementType>(0.50 - 0.50 * cos(2 * M_PI * n / maxN)); };
+				break;
+			case FilterWindowHamming:
+				windowFunction = [maxN](int n) -> ElementType {
+					return static_cast<ElementType>(0.54 - 0.46 * cos(2 * M_PI * n / maxN)); };
+				break;
+			case FilterWindowKaiser:
+				windowFunction = [maxN, beta](int n) -> ElementType {
+					double argument = beta * sqrt(1.0 - sycl::pow(( double )(2 * (( ElementType )n - maxN / 2) / maxN), 2.0));
+					return static_cast<ElementType>(bessel0_1stKind(argument) / bessel0_1stKind(beta)); };
+				break;
+			case FilterWindowRectangular:
+			default:
+				windowFunction = [](int n) -> ElementType { return static_cast<ElementType>(1); };
+				break;
+			}
+
+			for (size_t k = 0; k < filterLength; k++)
+			{
+				filter->get()[k] *= windowFunction((int)k);
+			}
+		}
+
+		template <typename ElementType>
+		static void normalizeGain(std::shared_ptr<Container<ElementType> > filter, double samplingFrequency, double frequency)
+		{
+			ElementType omega = static_cast<ElementType>(2 * M_PI* frequency / samplingFrequency);
+			ElementType gainR = 0;
+			ElementType gainI = 0;
+
+			for (int k = 0; k < filter->size(); k++)
+			{
+				gainR += filter->get()[ k ] * cos(omega * ( ElementType )k);
+				gainI += filter->get()[ k ] * sin(omega * ( ElementType )k);
+			}
+			ElementType gain = sqrt(gainR * gainR + gainI * gainI);
+			for (int k = 0; k < filter->size(); k++)
+			{
+				filter->get()[k] /= gain;
+			}
+		}
+
+		template <typename T>
+		static T bessel0_1stKind(const T &x)
+		{
+			T sum = 0.0;
+			//implemented look up factorial. 
+			static const int factorial[9] = { 1, 2, 6, 24, 120, 720, 5040, 40320, 362880 };
+			for (int k = 1; k < 10; k++)
+			{
+				T xPower = pow(x / ( T )2.0, ( T )k);
+				// 1, 2, 6, 24, 120, 720, 5040, 40320, 362880
+				sum += pow(xPower / ( T )factorial[ k - 1 ], ( T )2.0);
+			}
+			return (T)1.0 + sum;
+		}
+	};
+}
+
+#endif // !__FIRFILTERFACTORY_H__
diff --git a/oneapi/src/SupraLib/utilities/Logging.h b/oneapi/src/SupraLib/utilities/Logging.h
new file mode 100644
index 0000000..d845ac7
--- /dev/null
+++ b/oneapi/src/SupraLib/utilities/Logging.h
@@ -0,0 +1,332 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __LOGGING_H__
+#define __LOGGING_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <mutex>
+#include <iostream>
+#include <fstream>
+#include <iomanip>
+#include <type_traits>
+#include <atomic>
+#include <array>
+#include <ctime>
+
+#ifdef WIN32 
+	#ifndef NOMINMAX
+		#define NOMINMAX
+	#endif
+	#include <windows.h>
+#endif
+
+namespace supra
+{
+	/*! \brief The main logging facility.
+	*/
+	namespace logging
+	{
+		/// Tags the severity of a message.
+		typedef int SeverityMask;
+		/// Tags the severity of a message.
+		enum Severity : SeverityMask {
+			log = 1,  ///Messages that might be of interest when understanding operation surrounding an error. Such events can happen repeatedly. E.g. call frequencies.
+			info = 2,  ///A message tagged with info descibes non-repeating events that are handled correctly. E.g. start/stop of interfaces.
+			warning = 4,  ///Warn the user of circumstances that should not arise normally. Use this level if there is a good chance of continued operation.
+			error = 8,  ///The message describes an unexpected failure. Normal operation probably cannot be kept up.
+			param = 16,  ///The message describes an parameter change.
+			profiling = 32, ///The message serves the profiling of the application
+			external = 64,  ///Message coming from an external lib
+			always = 128   ///Message has to be printed always
+		};
+
+#ifdef WIN32
+		/// Stream modifier for blue text
+		inline std::ostream& blue(std::ostream &s)
+		{
+			HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
+			SetConsoleTextAttribute(h,
+				FOREGROUND_BLUE | FOREGROUND_INTENSITY);
+			return s;
+		}
+		/// Stream modifier for red text
+		inline std::ostream& red(std::ostream &s)
+		{
+			HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
+			SetConsoleTextAttribute(h,
+				FOREGROUND_RED | FOREGROUND_INTENSITY);
+			return s;
+		}
+		/// Stream modifier for green text
+		inline std::ostream& green(std::ostream &s)
+		{
+			HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
+			SetConsoleTextAttribute(h,
+				FOREGROUND_GREEN | FOREGROUND_INTENSITY);
+			return s;
+		}
+		/// Stream modifier for yellow text
+		inline std::ostream& yellow(std::ostream &s)
+		{
+			HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
+			SetConsoleTextAttribute(h,
+				FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY);
+			return s;
+		}
+		/// Stream modifier to reset text color
+		inline std::ostream& reset(std::ostream &s)
+		{
+			HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
+			SetConsoleTextAttribute(h,
+				FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
+			return s;
+		}
+#else
+		/// Stream modifier for red text
+		const std::string red("\033[0;31m");
+		/// Stream modifier for green text
+		const std::string green("\033[1;32m");
+		/// Stream modifier for yellow text
+		const std::string yellow("\033[1;33m");
+		/// Stream modifier for cyan text
+		const std::string cyan("\033[0;36m");
+		/// Stream modifier for magenta text
+		const std::string magenta("\033[0;35m");
+		/// Stream modifier to reset text color
+		const std::string reset("\033[0m");
+#endif
+		/// Endline character to use for logging
+		const std::string endl("\n");
+
+		/// Logging base functionality
+		class Base
+		{
+		public:
+			/// Internal: Implementation of logging output
+			template <typename... outObjectTypes>
+			static void log(outObjectTypes... o)
+			{
+				//acquire mutex to make it legible
+				std::lock_guard<std::mutex> lock(sm_streamMutex);
+				logRec(o...);
+				logRecFile(o...);
+			}
+
+			/// Internal: Implementation of logging output with severity
+			template <typename... outObjectTypes>
+			static void log(Severity severity, outObjectTypes... o)
+			{
+				//acquire mutex to make it legible
+				std::lock_guard<std::mutex> lock(sm_streamMutex);
+				if ((severity & sm_logLevel) > 0)
+				{
+					logRec(o..., endl);
+				}
+				logRecFile(o..., endl);
+			}
+
+			/// Sets the output stream for the console log output
+			static void setOutStream(std::ostream* newOut)
+			{
+				std::lock_guard<std::mutex> lock(sm_streamMutex);
+				sm_pOutStream->flush();
+				sm_pOutStream = newOut;
+			}
+
+			/// Sets which log-levels are shown on the console log output.
+			/// Accepts a mask built from values of \see SeverityMask
+			/// default: Severity::warning | Severity::error | Severity::always
+			static void setLogLevel(SeverityMask severity)
+			{
+				sm_logLevel = severity | logging::Severity::always;
+			}
+		private:
+			template <typename firstObjectType>
+			static void logRec(firstObjectType first)
+			{
+				if (std::is_arithmetic<firstObjectType>::value)
+				{
+					(*sm_pOutStream) << std::setbase(10) << first;
+				}
+				else {
+					(*sm_pOutStream) << first;
+				}
+			}
+
+			template <typename firstObjectType, typename... outObjectTypes>
+			static void logRec(firstObjectType first, outObjectTypes... o)
+			{
+				logRec(first);
+				logRec(o...);
+			}
+
+			template <typename firstObjectType>
+			static void logRecFile(firstObjectType first)
+			{
+				if (!sm_logFile.is_open())
+				{
+					initLogfile();
+				}
+
+				if (std::is_arithmetic<firstObjectType>::value)
+				{
+					sm_logFile << std::setbase(10);
+					if (std::is_floating_point<firstObjectType>::value)
+					{
+						sm_logFile << std::setprecision(std::numeric_limits<firstObjectType>::digits10 + 1);
+					}
+					sm_logFile << first;
+					
+				}
+				else {
+					sm_logFile << first;
+				}
+			}
+
+			template <typename firstObjectType, typename... outObjectTypes>
+			static void logRecFile(firstObjectType first, outObjectTypes... o)
+			{
+				logRecFile(first);
+				logRecFile(o...);
+			}
+
+			static void initLogfile()
+			{
+				sm_logFile.open(m_logFileName, std::ios_base::out | std::ios_base::app);
+
+				std::array<char, 64> buffer;
+				buffer.fill(0);
+				std::time_t rawtime;
+				std::time(&rawtime);
+				const auto timeinfo = std::localtime(&rawtime);
+				std::strftime(buffer.data(), sizeof(buffer), "%Y-%m-%d %H:%M:%S", timeinfo);
+
+				sm_logFile << std::endl << std::endl <<
+					"------------------------------------------" << std::endl <<
+					"SUPRA (" << buffer.data() << ")" << std::endl;
+			}
+
+			static std::mutex sm_streamMutex;
+			static std::ostream* sm_pOutStream;
+			static SeverityMask sm_logLevel;
+			static std::ofstream sm_logFile;
+			static const std::string m_logFileName;
+		};
+
+		/// Log entry that has always to be shown.
+		template <typename... outObjectTypes>
+		void log_always(outObjectTypes... o)
+		{
+			Base::log(Severity::always, o...);
+		}
+
+		/// Log entry with the lowest severity, is only logged if cond is true
+		/// Messages that might be of interest when understanding operation surrounding an error. Such events can happen repeatedly. E.g. call frequencies.
+		template <typename... outObjectTypes>
+		void log_log_if(bool cond, outObjectTypes... o)
+		{
+			if (cond)
+			{
+				log(Severity::log, o) log(Severity::log, o, o, o);
+			}
+		}
+
+		/// Log entry that informs the user of events of normal operation, is only logged if cond is true
+		/// A message tagged with info descibes non-repeating events that are handled correctly. E.g. start/stop of interfaces.
+		template <typename... outObjectTypes>
+		void log_info_if(bool cond, outObjectTypes... o)
+		{
+			if (cond)
+			{
+				Base::log(Severity::info, o...);
+			}
+		}
+
+		/// Log entry representing a warning, is only logged if cond is true
+		/// Warn the user of circumstances that should not arise normally. Use this level if there is a good chance of continued operation.
+		template <typename... outObjectTypes>
+		void log_warn_if(bool cond, outObjectTypes... o)
+		{
+			if (cond)
+			{
+				Base::log(Severity::warning, yellow, o..., reset);
+			}
+		}
+
+		/// Log entry representing an error, is only logged if cond is true
+		/// The message describes an unexpected failure. Normal operation probably cannot be kept up.
+		template <typename... outObjectTypes>
+		void log_error_if(bool cond, outObjectTypes... o)
+		{
+			if (cond)
+			{
+				log(Severity::error, red, o, reset);
+			}
+		}
+		/// Log entry containing profiling details
+		/// Should only be used internally by the CallFrequency
+		template <typename... outObjectTypes>
+		void log_profiling_if(bool cond, outObjectTypes... o)
+		{
+			if (cond)
+			{
+				Base::log(Severity::profiling, o...);
+			}
+		}
+
+		/// Log entry with the lowest severity
+		/// Messages that might be of interest when understanding operation surrounding an error. Such events can happen repeatedly. E.g. call frequencies.
+		template <typename... outObjectTypes>
+		void log_log(outObjectTypes... o)
+		{
+			log_log_if(true, o...);
+		}
+		/// Log entry that informs the user of events of normal operation
+		/// A message tagged with info descibes non-repeating events that are handled correctly. E.g. start/stop of interfaces.
+		template <typename... outObjectTypes>
+		void log_info(outObjectTypes... o)
+		{
+			log_info_if(true, o...);
+		}
+		/// Log entry representing a warning
+		/// Warn the user of circumstances that should not arise normally. Use this level if there is a good chance of continued operation.
+		template <typename... outObjectTypes>
+		void log_warn(outObjectTypes... o)
+		{
+			log_warn_if(true, o...);
+		}
+		/// Log entry representing an error
+		/// The message describes an unexpected failure. Normal operation probably cannot be kept up.
+		template <typename... outObjectTypes>
+		void log_error(outObjectTypes... o)
+		{
+			log_error_if(true, o...);
+		}
+		/// Log entry informing about the change of a node parameter
+		/// Should only be used internally by the parameter system
+		template <typename... outObjectTypes>
+		void log_parameter(outObjectTypes... o)
+		{
+			Base::log(Severity::param, o...);
+		}
+		/// Log entry containing profiling details
+		/// Should only be used internally by the CallFrequency
+		template <typename... outObjectTypes>
+		void log_profiling(outObjectTypes... o)
+		{
+			log_profiling_if(true, o...);
+		}
+	}
+}
+
+#endif // !__LOGGING_H__
diff --git a/oneapi/src/SupraLib/utilities/cudaUtility.h b/oneapi/src/SupraLib/utilities/cudaUtility.h
new file mode 100644
index 0000000..646f649
--- /dev/null
+++ b/oneapi/src/SupraLib/utilities/cudaUtility.h
@@ -0,0 +1,180 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __CUDAUTILITY_H__
+#define __CUDAUTILITY_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <cmath>
+#ifdef HAVE_CUDA
+#ifdef HAVE_CUFFT
+#include <cufft.h>
+#endif
+#endif
+#include <cstdio>
+#include "utilities/Logging.h"
+#include <algorithm>
+#include <cmath>
+#include <cfloat>
+
+namespace supra
+{
+#ifdef CL_SYCL_LANGUAGE_VERSION
+	using ::max;
+	using ::min;
+	using ::round;
+	using ::floor;
+	using ::ceil;
+#else
+	using std::max;
+	using std::min;
+	using std::round;
+	using std::floor;
+	using std::ceil;
+#endif
+
+#ifdef HAVE_CUDA
+	//define for portable function name resolution
+	#if defined(__GNUC__)
+	//GCC
+	/// Name of the function this define is referenced. GCC version
+	#define FUNCNAME_PORTABLE __PRETTY_FUNCTION__
+	#elif defined(_MSC_VER)
+	//Visual Studio
+	/// Name of the function this define is referenced. Visual Studio version
+	#define FUNCNAME_PORTABLE __FUNCSIG__
+	#endif
+
+	/// Verifies a cuda call returned "cudaSuccess". Prints error message otherwise.
+	/// returns true if no error occured, false otherwise.
+	#define cudaSafeCall(_err_) cudaSafeCall2(_err_, __FILE__, __LINE__, FUNCNAME_PORTABLE)
+
+	/// Verifies a cuda call returned "cudaSuccess". Prints error message otherwise.
+	/// returns true if no error occured, false otherwise. Calles by cudaSafeCall
+	inline bool cudaSafeCall2(int err, const char* file, int line, const char* func) {
+
+		//#ifdef CUDA_ERROR_CHECK
+		/*
+		DPCT1000:1: Error handling if-stmt was detected but could not be rewritten.
+		*/
+		if (0 != err) {
+			char buf[1024];
+			/*
+			DPCT1001:0: The statement could not be removed.
+			*/
+			/*
+			DPCT1009:2: SYCL uses exceptions to report errors and does not use the error codes. The original code was commented out and a warning string was inserted. You need to rewrite this code.
+			*/
+			/*
+			DPCT1009:25: SYCL uses exceptions to report errors and does not use the error codes. The original code was commented out and a warning string was inserted. You need to rewrite this code.
+			*/
+			/*
+			DPCT1009:28: SYCL uses exceptions to report errors and does not use the error codes. The original code was commented out and a warning string was inserted. You need to rewrite this code.
+			*/
+			/*
+			DPCT1009:32: SYCL uses exceptions to report errors and does not use the error codes. The original code was commented out and a warning string was inserted. You need to rewrite this code.
+			*/
+			/*
+			DPCT1009:36: SYCL uses exceptions to report errors and does not use the error codes. The original code was commented out and a warning string was inserted. You need to rewrite this code.
+			*/
+			sprintf(buf, "CUDA Error (in \"%s\", Line: %d, %s): %d - %s\n", file, line, func, err, "cudaGetErrorString not supported" /*cudaGetErrorString(err)*/);
+			printf("%s", buf);
+			logging::log_error(buf);
+			return false;
+		}
+
+		//#endif
+		return true;
+	}
+
+#ifdef HAVE_CUFFT
+	/// Verifies a cuFFT call returned "CUFFT_SUCCESS". Prints error message otherwise.
+	/// returns true if no error occured, false otherwise.
+    #define cufftSafeCall(_err_) cufftSafeCall2(_err_, __FILE__, __LINE__, FUNCNAME_PORTABLE)
+
+	/// Verifies a cuFFT call returned "CUFFT_SUCCESS". Prints error message otherwise.
+	/// returns true if no error occured, false otherwise. Calles by cudaSafeCall
+	inline bool cufftSafeCall2(cufftResult err, const char* file, int line, const char* func) {
+
+		//#ifdef CUDA_ERROR_CHECK
+		if (CUFFT_SUCCESS != err) {
+			char buf[1024];
+			sprintf(buf, "CUFFT Error (in \"%s\", Line: %d, %s): %d\n", file, line, func, err);
+			printf("%s", buf);
+			logging::log_error(buf);
+			return false;
+		}
+
+		//#endif
+		return true;
+	}
+#endif
+
+	/// Returns the square of x. CUDA constexpr version
+	template <typename T>
+	constexpr inline T squ(const T& x)
+	{
+		return x*x;
+	}
+#else
+	#define __host__
+	#define __device__
+#endif
+
+	template <typename T>
+	class LimitProxy
+	{
+	public:
+		inline static T max();
+		inline static T min();
+	};
+
+	template <>
+	class LimitProxy<float>
+	{
+	public:
+		inline static float max() { return FLT_MAX; }
+		inline static float min() { return -FLT_MAX; }
+	};
+
+	template <>
+	class LimitProxy<int16_t>
+	{
+	public:
+		inline static int16_t max() { return 32767; }
+		inline static int16_t min() { return -32767; }
+	};
+
+	template <>
+	class LimitProxy<uint8_t>
+	{
+	public:
+		inline static uint8_t max() { return 255; }
+		inline static uint8_t min() { return 0; }
+	};
+
+	template <typename ResultType, typename InputType>
+	ResultType clampCast(const InputType& x)
+	{
+		return static_cast<ResultType>(sycl::min(sycl::max(x, static_cast<InputType>(LimitProxy<ResultType>::min())), static_cast<InputType>(LimitProxy<ResultType>::max())));
+	}
+
+	template <typename ResultType, typename InputType>
+	struct clampCaster {
+		ResultType operator()(const InputType& a) const
+		{
+			return clampCast<ResultType>(a);
+		}
+	};
+}
+
+#endif // !__CUDAUTILITY_H__
diff --git a/oneapi/src/SupraLib/utilities/utility.h b/oneapi/src/SupraLib/utilities/utility.h
new file mode 100644
index 0000000..729de80
--- /dev/null
+++ b/oneapi/src/SupraLib/utilities/utility.h
@@ -0,0 +1,216 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __UTILITY_H__
+#define __UTILITY_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <cctype>
+#include <algorithm>
+#include <vector>
+#include <string>
+#include <sstream>
+#include <stddef.h>
+#include <cstring>
+#include <fstream>
+#include <array>
+
+namespace std
+{
+	/// overload of std function to ease type handling
+	inline std::string to_string(std::string s)
+	{
+		return s;
+	}
+}
+
+namespace supra
+{
+	using std::to_string;
+
+#ifndef M_PI
+	/// Definition of pi for the cuda compile path, as cuda math.h does not seem to provide it.
+	constexpr auto M_PI = 3.14159265358979323846;
+#endif //!M_PI
+	/// Definition of eps following the value of matlabs "eps()"
+	constexpr double M_EPS = 2.2204e-16;
+
+	/// Writes a buffer of given length as text to a file with the given filename
+	template <typename T>
+	void writeAscii(std::string filename, const T* buffer, size_t length)
+	{
+		std::ofstream o(filename);
+		for (size_t i = 0; i < length; i++)
+		{
+			o << buffer[i] << '\n';
+		}
+		o.close();
+	}
+
+	template <typename T>
+	void readChunks(std::ifstream& f, T* destination, size_t numElements, size_t chunkSize)
+	{
+		size_t numElementsChunk = chunkSize / sizeof(T);
+		for (size_t elementsRead = 0; elementsRead < numElements; 
+				elementsRead += numElementsChunk, destination += numElementsChunk)
+		{
+			size_t numToRead = std::min(chunkSize, (numElements - elementsRead) * sizeof(T));
+			f.read(reinterpret_cast<char*>(destination), numToRead);
+		}
+	}
+
+	/// returns the square of x
+	template <typename T>
+	constexpr T sq(T x)
+	{
+		return x*x;
+	}
+
+	/// Conversion function from degree to radian
+	template <typename T>
+	constexpr T degToRad(T deg)
+	{
+		return deg*M_PI / 180.0;
+	}
+	/// Conversion function from radian to degree
+	template <typename T>
+	constexpr T radToDeg(T rad)
+	{
+		return rad * 180 / M_PI;
+	}
+
+	/// Performs a copy between the given buffers while transposing the 2D-matrix,
+	/// exchanging width and height
+	template <typename T>
+	void memcpyTransposed(T* dest, const T* src, size_t width, size_t height)
+	{
+		for (size_t x = 0; x < width; x++)
+		{
+			for (size_t y = 0; y < height; y++)
+			{
+				dest[y*width + x] = src[x*height + y];
+			}
+		}
+	}
+
+	/// Converts the argument to a string with its operator<<
+	/// As opposed to stdlibs to_string the locale can be modified conviniently
+	template <typename valueType>
+	std::string stringify(valueType v)
+	{
+		std::stringstream ss;
+		ss << v;
+		return ss.str();
+	}
+
+	/// Converts the vector argument to a string
+	template <typename valueType>
+	std::string stringify(std::vector<valueType> v)
+	{
+		std::string b;
+		if (v.size() > 0)
+		{
+			b += "[";
+			for (valueType& value : v)
+			{
+				b += to_string(value) + ", ";
+			}
+			b.erase(b.end() - 1, b.end());
+			b += "]";
+			return b;
+		}
+		else {
+			return "[]";
+		}
+	}
+
+	/// Converts the argument to a string (true|false)
+	template <>
+	std::string stringify(std::vector<bool> v);
+
+	/// Converts the array argument to a string
+	template <typename valueType, size_t N>
+	std::string stringify(std::array<valueType, N> v)
+	{
+		std::string b;
+		if (N > 0)
+		{
+			b += "[";
+			for (valueType& value : v)
+			{
+				b += to_string(value) + ", ";
+			}
+			b.erase(b.end() - 1, b.end());
+			b += "]";
+			return b;
+		}
+		else {
+			return "[]";
+		}
+	}
+
+	/// Converts the string argument to the type specified via its operator>>
+	template <typename T>
+	T from_string(const std::string& s) {
+		std::stringstream ss(s);
+		T t;
+		ss >> t;
+		return t;
+	}
+
+	/// Converts a string to a newly allocated cstr.
+	/// ATTENTION: The returned buffer has to be deleted with `delete[] <ptr>`!
+	inline char* stringToNewCstr(std::string org)
+	{
+		size_t len = org.length();
+		char* ret = new char[len + 1];
+		memcpy(ret, org.c_str(), (len + 1) * sizeof(char));
+		return ret;
+	}
+
+	/// Trims leading and trailing whitespace from the string
+	inline std::string trim(const std::string &str)
+	{
+		auto strStart = std::find_if(str.begin(), str.end(), [](int ch) {return !std::isspace(ch);} );
+		auto strEnd = std::find_if(str.rbegin(), str.rend(), [](int ch) {return !std::isspace(ch);} ).base();
+		if (strEnd <= strStart)
+		{
+			return std::string();
+		}
+		else {
+			return std::string(strStart, strEnd);
+		}
+	}
+
+	inline std::vector<std::string> split(const std::string &str, char delimiter)
+	{
+		std::vector<std::string> tokens;
+		std::stringstream s(str);
+		std::string token;
+		while (std::getline(s, token, delimiter))
+		{
+			tokens.push_back(token);
+		}
+		return tokens;
+	}
+
+	/// Returns current time in seconds. The resolution depends on the operating system.
+	double getCurrentTime();
+
+	/// Performs a busy wait for the given number of microseconds. This is just a debug-tool
+	void busyWait(size_t microseconds);
+
+	/// Returns whether the given file exists
+	bool fileExists(const std::string& path);
+}
+
+#endif // !__UTILITY_H__
diff --git a/oneapi/src/SupraLib/vec.h b/oneapi/src/SupraLib/vec.h
new file mode 100644
index 0000000..62cece3
--- /dev/null
+++ b/oneapi/src/SupraLib/vec.h
@@ -0,0 +1,439 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#ifndef __VEC_H__
+#define __VEC_H__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "utilities/utility.h"
+#include "utilities/cudaUtility.h"
+#include <cmath>
+
+namespace supra
+{
+	template <typename ElementType>
+	struct vec2T;
+	template <typename ElementType>
+	struct vec3T;
+	template <typename ElementType>
+	struct vec4T;
+
+	/// Vector of two elements of type ElementType
+	template <typename ElementType>
+	struct vec2T
+	{
+		/// The first element of the two-vector
+		ElementType x;
+		/// The second element of the two-vector
+		ElementType y;
+
+		/// Explicit numeric conversion operator. Casts both elements seperately to NewElementType
+		template <typename NewElementType>
+		explicit operator vec2T<NewElementType>() const
+		{
+			return vec2T<NewElementType>{
+				static_cast<NewElementType>(this->x),
+					static_cast<NewElementType>(this->y) };
+		}
+
+		/// Equality operator. Compares this and b elementwise for equality
+		bool operator==(const vec2T<ElementType>& b) const
+		{
+			return x == b.x && y == b.y;
+		}
+
+		/// Inequality operator. Compares this and b elementwise for inequality
+		bool operator!=(const vec2T<ElementType>& b) const
+		{
+			return x != b.x || y != b.y;
+		}
+	};
+
+	/// Vector of three elements of type ElementType
+	template <typename ElementType>
+	struct vec3T
+	{
+		/// The first element of the three-vector
+		ElementType x;
+		/// The second element of the three-vector
+		ElementType y;
+		/// The third element of the three-vector
+		ElementType z;
+
+		/// Conversion of a 3-vector representing a POINT to homogeneous coordinates
+		vec4T<ElementType> pointToHom() const { return vec4T<ElementType>({ this->x, this->y, this->z, 1 }); }
+		/// Explicit conversion of a 3-vector representing a POINT to homogeneous coordinates
+		explicit operator vec4T<ElementType>() const { return pointToHom(); };
+
+		/// Conversion of a 3-vector representing a VECTOR to homogeneous coordinates
+		vec4T<ElementType> vectorToHom() const { return vec4T<ElementType>({ this->x, this->y, this->z, 0 }); }
+
+		/// Explicit numeric conversion operator. Casts both elements seperately to NewElementType
+		template <typename NewElementType>
+		explicit operator vec3T<NewElementType>() const
+		{
+			return vec3T<NewElementType>{
+				static_cast<NewElementType>(this->x),
+					static_cast<NewElementType>(this->y),
+					static_cast<NewElementType>(this->z) };
+		}
+
+		/// Equality operator. Compares this and b elementwise for equality
+		bool operator==(const vec3T<ElementType>& b) const
+		{
+			return x == b.x && y == b.y && z == b.z;
+		}
+
+		/// Inequality operator. Compares this and b elementwise for inequality
+		bool operator!=(const vec3T<ElementType>& b) const
+		{
+			return x != b.x || y != b.y || z != b.z;
+		}
+	};
+
+	/// Vector of four elements of type ElementType
+	template <typename ElementType>
+	struct vec4T
+	{
+		/// The first element of the four-vector
+		ElementType x;
+		/// The second element of the four-vector
+		ElementType y;
+		/// The third element of the four-vector
+		ElementType z;
+		/// The fourth element of the four-vector
+		ElementType w;
+	};
+
+	/// Rectangle in 2D of type ElementType
+	template <typename ElementType>
+	struct rect2T
+	{
+		/// Inclusive begin of the rectangle in top-left
+		vec2T<ElementType> begin;
+		/// Inclusive end of the rectangle in bottom-right
+		vec2T<ElementType> end;
+	};
+
+	/// Single precision two-vector
+	typedef vec2T<float> vec2f;
+	/// Single precision three-vector
+	typedef vec3T<float> vec3f;
+	/// Single precision four-vector
+	typedef vec4T<float> vec4f;
+
+	/// Double precision two-vector
+	typedef vec2T<double> vec2d;
+	/// Double precision three-vector
+	typedef vec3T<double> vec3d;
+	/// Double precision four-vector
+	typedef vec4T<double> vec4d;
+
+	/// Integer two-vector
+	typedef vec2T<int> vec2i;
+	/// Integer three-vector
+	typedef vec3T<int> vec3i;
+	/// Integer four-vector
+	typedef vec4T<int> vec4i;
+
+	/// size_t two-vector
+	typedef vec2T<size_t> vec2s;
+	/// size_t three-vector
+	typedef vec3T<size_t> vec3s;
+	/// size_t four-vector
+	typedef vec4T<size_t> vec4s;
+
+	/// Double precision two-vector
+	typedef vec2d vec2;
+	/// Double precision three-vector
+	typedef vec3d vec3;
+	/// Double precision four-vector
+	typedef vec4d vec4;
+
+	/// Double precision three-vector
+	typedef vec3 vec;
+
+	/// Single precision rectangle
+	typedef rect2T<float> rect2f;
+	/// Double precision rectangle
+	typedef rect2T<double> rect2d;
+	/// Integer rectangle
+	typedef rect2T<int> rect2i;
+	/// size_t rectangle
+	typedef rect2T<size_t> rect2s;
+
+	/// Double precision rectangle
+	typedef rect2d rect2;
+	/// Double precision rectangle
+	typedef rect2 rect;
+
+	/// Element-wise sum of a two-vector and a scalar
+	template <typename Ta, typename Tb>
+	inline vec2T<Ta> operator+(const vec2T<Ta>& a, const Tb& b) {
+		return vec2T<Ta>({ a.x + b, a.y + b });
+	}
+	/// Negation of a two-vector
+	template <typename Ta>
+	inline vec2T<Ta> operator-(const vec2T<Ta>& a) {
+		return vec2T<Ta>({ -a.x, -a.y });
+	}
+	/// Element-wise subtraction of a two-vector and a scalar
+	template <typename Ta, typename Tb>
+	inline vec2T<Ta> operator-(const vec2T<Ta>& a, const Tb& b) {
+		return vec2T<Ta>({ a.x - b, a.y - b });
+	}
+	/// Product of a two-vector and a scalar
+	template <typename Ta, typename Tb>
+	inline vec2T<Ta> operator*(const vec2T<Ta>& a, const Tb& b) {
+		return vec2T<Ta>({ a.x * b, a.y * b });
+	}
+	/// Element-wise division of a two-vector and a scalar
+	template <typename Ta, typename Tb>
+	inline vec2T<Ta> operator/(const vec2T<Ta>& a, const Tb& b) {
+		return vec2T<Ta>({ a.x / b, a.y / b });
+	}
+	/// Element-wise sum of a scalar and a two-vector
+	template <typename Ta, typename Tb>
+	inline vec2T<Ta> operator+(const Tb& b, const vec2T<Ta>& a) {
+		return vec2T<Ta>({ a.x + b, a.y + b });
+	}
+	/// Element-wise difference of a scalar and a two-vector
+	template <typename Ta, typename Tb>
+	inline vec2T<Ta> operator-(const Tb& b, const vec2T<Ta>& a) {
+		return vec2T<Ta>({ b - a.x, b - a.y });
+	}
+	/// Product of a scalar and a two-vector
+	template <typename Ta, typename Tb>
+	inline vec2T<Ta> operator*(const Tb& b, const vec2T<Ta>& a) {
+		return vec2T<Ta>({ a.x * b, a.y * b });
+	}
+	/// Element-wise division of two-vectors
+	template <typename Ta, typename Tb>
+	inline vec2T<Ta> operator/(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+		return vec2T<Ta>({ a.x / b.x, a.y / b.y });
+	}
+	/// Sum of two-vectors
+	template <typename Ta, typename Tb>
+	inline vec2T<Ta> operator+(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+		return vec2T<Ta>({ a.x + b.x, a.y + b.y });
+	}
+	/// Difference of two-vectors
+	template <typename Ta, typename Tb>
+	inline vec2T<Ta> operator-(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+		return vec2T<Ta>({ a.x - b.x, a.y - b.y });
+	}
+	/// Element-wise product of two-vectors
+	template <typename Ta, typename Tb>
+	inline vec2T<Ta> operator*(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+		return vec2T<Ta>({ a.x * b.x, a.y * b.y });
+	}
+	/// Euclidean norm of a two-vector
+	template <typename Ta>
+	inline Ta norm(const vec2T<Ta>& a)
+	{
+		return sqrt(a.x*a.x + a.y*a.y);
+	}
+	/// Normalization of a two-vector
+	template <typename Ta>
+	inline vec2T<Ta> normalize(const vec2T<Ta>& a)
+	{
+		return a / norm(a);
+	}
+
+	/// Element-wise round of a two-vector
+	template <typename Ta>
+	inline vec2T<Ta> round(const vec2T<Ta>& a)
+	{
+		return{ round(a.x), round(a.y) };
+	}
+	/// Element-wise floor of a two-vector
+	template <typename Ta>
+	inline vec2T<Ta> floor(const vec2T<Ta>& a)
+	{
+		return { sycl::floor(( double )(a.x)), sycl::floor(( double )(a.y)) };
+	}
+	/// Element-wise ceil of a two-vector
+	template <typename Ta>
+	inline vec2T<Ta> ceil(const vec2T<Ta>& a)
+	{
+		return { sycl::ceil(( double )(a.x)), sycl::ceil(( double )(a.y)) };
+	}
+	/// Element-wise minimum of two-vectors
+	template <typename Ta>
+	inline vec2T<Ta> min(const vec2T<Ta>& a, const vec2T<Ta>& b)
+	{
+		return { min(a.x, b.x), min(a.y, b.y) };
+	}
+	/// Element-wise maximum of two-vectors
+	template <typename Ta>
+	inline vec2T<Ta> max(const vec2T<Ta>& a, const vec2T<Ta>& b)
+	{
+		return{
+			max(a.x, b.x),
+			max(a.y, b.y)
+		};
+	}
+
+	/// Element-wise sum of a three-vector and a scalar
+	template <typename Ta, typename Tb>
+	inline vec3T<Ta> operator+(const vec3T<Ta>& a, const Tb& b) {
+		return vec3T<Ta>({ a.x + b, a.y + b, a.z + b });
+	}
+	/// Negation of a three-vector
+	template <typename Ta>
+	inline vec3T<Ta> operator-(const vec3T<Ta>& a) {
+		return vec3T<Ta>({ -a.x, -a.y, -a.z });
+	}
+	/// Element-wise subtraction of a three-vector and a scalar
+	template <typename Ta, typename Tb>
+	inline vec3T<Ta> operator-(const vec3T<Ta>& a, const Tb& b) {
+		return vec3T<Ta>({ a.x - b, a.y - b, a.z - b });
+	}
+	/// Product of a three-vector and a scalar
+	template <typename Ta, typename Tb>
+	inline vec3T<Ta> operator*(const vec3T<Ta>& a, const Tb& b) {
+		return vec3T<Ta>({ a.x * b, a.y * b, a.z * b });
+	}
+	/// Element-wise division of a three-vector and a scalar
+	template <typename Ta, typename Tb>
+	inline vec3T<Ta> operator/(const vec3T<Ta>& a, const Tb& b) {
+		return vec3T<Ta>({ a.x / b, a.y / b, a.z / b });
+	}
+	/// Element-wise sum of a scalar and a three-vector
+	template <typename Ta, typename Tb>
+	inline vec3T<Ta> operator+(const Tb& b, const vec3T<Ta>& a) {
+		return vec3T<Ta>({ a.x + b, a.y + b, a.z + b });
+	}
+	/// Element-wise difference of a scalar and a three-vector
+	template <typename Ta, typename Tb>
+	inline vec3T<Ta> operator-(const Tb& b, const vec3T<Ta>& a) {
+		return vec3T<Ta>({ b - a.x, b - a.y, b - a.z });
+	}
+	/// Product of a scalar and a three-vector
+	template <typename Ta, typename Tb>
+	inline vec3T<Ta> operator*(const Tb& b, const vec3T<Ta>& a) {
+		return vec3T<Ta>({ a.x * b, a.y * b, a.z * b });
+	}
+	/// Element-wise division of three-vectors
+	template <typename Ta, typename Tb>
+	inline vec3T<Ta> operator/(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+		return vec3T<Ta>({ a.x / b.x, a.y / b.y, a.z / b.z });
+	}
+	/// Sum of three-vectors
+	template <typename Ta, typename Tb>
+	inline vec3T<Ta> operator+(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+		return vec3T<Ta>({ a.x + b.x, a.y + b.y, a.z + b.z });
+	}
+	/// Difference of three-vectors
+	template <typename Ta, typename Tb>
+	inline vec3T<Ta> operator-(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+		return vec3T<Ta>({ a.x - b.x, a.y - b.y, a.z - b.z });
+	}
+	/// Element-wise product of three-vectors
+	template <typename Ta, typename Tb>
+	inline vec3T<Ta> operator*(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+		return vec3T<Ta>({ a.x * b.x, a.y * b.y, a.z * b.z });
+	}
+
+	/// Euclidean norm of a three-vector
+	template <typename Ta>
+	inline Ta norm(const vec3T<Ta>& a)
+	{
+		return sycl::sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
+	}
+	/// Normalization of a three-vector
+	template <typename Ta>
+	inline vec3T<Ta> normalize(const vec3T<Ta>& a)
+	{
+		return a / norm(a);
+	}
+	/// Dot-product of two three-vectors
+	template <typename Ta, typename Tb>
+	inline typename std::common_type<Ta, Tb>::type dot(const vec3T<Ta>& a, const vec3T<Tb>& b)
+	{
+		return a.x*b.x + a.y*b.y + a.z*b.z;
+	}
+	/// Cross-product of two three-vectors
+	template <typename Ta, typename Tb>
+	inline vec3T<typename std::common_type<Ta, Tb>::type > cross(const vec3T<Ta>& a, const vec3T<Tb>& b)
+	{
+		return{
+			a.y*b.z - a.z*b.y,
+			a.z*b.x - a.x*b.z,
+			a.x*b.y - a.y*b.x
+		};
+	}
+	/// Determinant of matric \f$[a, b, c]\f$
+	template <typename Ta, typename Tb, typename Tc>
+	inline typename std::common_type<Ta, Tb, Tc>::type det(const vec3T<Ta>& a, const vec3T<Tb>& b, const vec3T<Tc>& c)
+	{
+		return sycl::fabs(dot(a, cross(b, c)));
+	}
+	/// Element-wise round of a three-vector
+	template <typename Ta>
+	inline vec3T<Ta> round(const vec3T<Ta>& a)
+	{
+		return{ round(a.x), round(a.y), round(a.z) };
+	}
+	/// Element-wise floor of a three-vector
+	template <typename Ta>
+	inline vec3T<Ta> floor(const vec3T<Ta>& a)
+	{
+		return { sycl::floor(( double )(a.x)), sycl::floor(( double )(a.y)), sycl::floor(( double )(a.z)) };
+	}
+	/// Element-wise ceil of a three-vector
+	template <typename Ta>
+	inline vec3T<Ta> ceil(const vec3T<Ta>& a)
+	{
+		return { sycl::ceil(( double )(a.x)), sycl::ceil(( double )(a.y)), sycl::ceil(( double )(a.z)) };
+	}
+
+	/// Element-wise minimum of three-vectors
+	template <typename Ta>
+	inline vec3T<Ta> min(const vec3T<Ta>& a, const vec3T<Ta>& b)
+	{
+		return { min(a.x, b.x), min(a.y, b.y), min(a.z, b.z) };
+	}
+
+	/// Element-wise maximum of three-vectors
+	template <typename Ta>
+	inline vec3T<Ta> max(const vec3T<Ta>& a, const vec3T<Ta>& b)
+	{
+		return { max(a.x, b.x), max(a.y, b.y), max(a.z, b.z) };
+	}
+
+	/// Spherical Linear Interpolation (SLERP) of two three-vectors
+	template <typename T>
+	vec3T<T> inline slerp3(const vec3T<T>& a, const vec3T<T>& b, const T& t)
+	{
+		T omega = sycl::acos(( double )(dot(a, b)));
+		if (omega < M_EPS)
+		{
+			return a;
+		}
+		vec3T<T> ret;
+		if (t < M_EPS)
+		{
+			ret = a;
+		}
+		else if ((T)1.0 - t < M_EPS)
+		{
+			ret = b;
+		}
+		else {
+			ret = (sycl::sin((( T )1.0 - t) * omega) / sycl::sin(omega)) * a + (sycl::sin(t * omega) / sycl::sin(omega)) * b;
+		}
+		return ret;
+	}
+}
+
+#endif //!__VEC_H__
diff --git a/src/SupraLib/Beamformer/HilbertFirEnvelope.cu b/src/SupraLib/Beamformer/HilbertFirEnvelope.cu
index 35c32b6..05e4e0a 100644
--- a/src/SupraLib/Beamformer/HilbertFirEnvelope.cu
+++ b/src/SupraLib/Beamformer/HilbertFirEnvelope.cu
@@ -77,15 +77,15 @@ namespace supra
 			m_filterLength,
 			FirFilterFactory::FilterTypeHilbertTransformer,
 			FirFilterFactory::FilterWindowHamming);
-		m_hilbertFilter = make_shared<Container<float> >(LocationGpu, *m_hilbertFilter);
+		m_hilbertFilter = make_shared<Container<float>>(LocationGpu, *m_hilbertFilter);
 	}
 
 	template<typename InputType, typename OutputType>
-	shared_ptr<Container<OutputType> > HilbertFirEnvelope::demodulate(
+	shared_ptr<Container<OutputType>> HilbertFirEnvelope::demodulate(
 		const shared_ptr<const Container<InputType>>& inImageData,
 		int numScanlines, int numSamples)
 	{
-		auto pEnv = make_shared<Container<OutputType> >(LocationGpu, inImageData->getStream(), numScanlines*numSamples);
+		auto pEnv = make_shared<Container<OutputType>>(LocationGpu, inImageData->getStream(), numScanlines*numSamples);
 		dim3 blockSizeFilter(16, 8);
 		dim3 gridSizeFilter(
 			static_cast<unsigned int>((numScanlines + blockSizeFilter.x - 1) / blockSizeFilter.x),
@@ -104,19 +104,19 @@ namespace supra
 	}
 
 	template 
-	shared_ptr<Container<int16_t> > HilbertFirEnvelope::demodulate<int16_t, int16_t>(
-		const shared_ptr<const Container<int16_t> >& inImageData,
+	shared_ptr<Container<int16_t>> HilbertFirEnvelope::demodulate<int16_t, int16_t>(
+		const shared_ptr<const Container<int16_t>>& inImageData,
 		int numScanlines, int numSamples);
 	template
-		shared_ptr<Container<int16_t> > HilbertFirEnvelope::demodulate<float, int16_t>(
-			const shared_ptr<const Container<float> >& inImageData,
+		shared_ptr<Container<int16_t>> HilbertFirEnvelope::demodulate<float, int16_t>(
+			const shared_ptr<const Container<float>>& inImageData,
 			int numScanlines, int numSamples);
 	template
-		shared_ptr<Container<float> > HilbertFirEnvelope::demodulate<int16_t, float>(
-			const shared_ptr<const Container<int16_t> >& inImageData,
+		shared_ptr<Container<float>> HilbertFirEnvelope::demodulate<int16_t, float>(
+			const shared_ptr<const Container<int16_t>>& inImageData,
 			int numScanlines, int numSamples);
 	template
-		shared_ptr<Container<float> > HilbertFirEnvelope::demodulate<float, float>(
-			const shared_ptr<const Container<float> >& inImageData,
+		shared_ptr<Container<float>> HilbertFirEnvelope::demodulate<float, float>(
+			const shared_ptr<const Container<float>>& inImageData,
 			int numScanlines, int numSamples);
 }
\ No newline at end of file
diff --git a/src/SupraLib/Beamformer/LogCompressor.cu b/src/SupraLib/Beamformer/LogCompressor.cu
index 8f72b06..12ab063 100644
--- a/src/SupraLib/Beamformer/LogCompressor.cu
+++ b/src/SupraLib/Beamformer/LogCompressor.cu
@@ -40,13 +40,13 @@ namespace supra
 	};
 
 	template <typename InputType, typename OutputType>
-	shared_ptr<Container<OutputType> > LogCompressor::compress(const shared_ptr<const Container<InputType>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax)
+	shared_ptr<Container<OutputType>> LogCompressor::compress(const shared_ptr<const Container<InputType>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax)
 	{
 		size_t width = size.x;
 		size_t height = size.y;
 		size_t depth = size.z;
 
-		auto pComprGpu = make_shared<Container<OutputType> >(LocationGpu, inImageData->getStream(), width*height*depth);
+		auto pComprGpu = make_shared<Container<OutputType>>(LocationGpu, inImageData->getStream(), width*height*depth);
 
 		OutputType outMax;
 		if (std::is_integral<OutputType>::value)
@@ -67,15 +67,15 @@ namespace supra
 	}
 
 	template
-	shared_ptr<Container<uint8_t> > LogCompressor::compress<int16_t, uint8_t>(const shared_ptr<const Container<int16_t> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	shared_ptr<Container<uint8_t>> LogCompressor::compress<int16_t, uint8_t>(const shared_ptr<const Container<int16_t>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
 	template
-	shared_ptr<Container<uint8_t> > LogCompressor::compress<float, uint8_t>(const shared_ptr<const Container<float> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	shared_ptr<Container<uint8_t>> LogCompressor::compress<float, uint8_t>(const shared_ptr<const Container<float>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
 	template
-	shared_ptr<Container<uint8_t> > LogCompressor::compress<uint8_t, uint8_t>(const shared_ptr<const Container<uint8_t> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	shared_ptr<Container<uint8_t>> LogCompressor::compress<uint8_t, uint8_t>(const shared_ptr<const Container<uint8_t>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
 	template
-	shared_ptr<Container<float> > LogCompressor::compress<int16_t, float>(const shared_ptr<const Container<int16_t> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	shared_ptr<Container<float>> LogCompressor::compress<int16_t, float>(const shared_ptr<const Container<int16_t>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
 	template
-	shared_ptr<Container<float> > LogCompressor::compress<float, float>(const shared_ptr<const Container<float> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	shared_ptr<Container<float>> LogCompressor::compress<float, float>(const shared_ptr<const Container<float>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
 	template
-	shared_ptr<Container<float> > LogCompressor::compress<uint8_t, float>(const shared_ptr<const Container<uint8_t> >& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	shared_ptr<Container<float>> LogCompressor::compress<uint8_t, float>(const shared_ptr<const Container<uint8_t>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
 }
\ No newline at end of file
diff --git a/src/SupraLib/Beamformer/RxBeamformerCuda.cu b/src/SupraLib/Beamformer/RxBeamformerCuda.cu
index cdc13ea..eaf3438 100644
--- a/src/SupraLib/Beamformer/RxBeamformerCuda.cu
+++ b/src/SupraLib/Beamformer/RxBeamformerCuda.cu
@@ -32,15 +32,15 @@ namespace supra
 		m_rxNumDepths = parameters.getRxNumDepths();
 
 		// create and fill new buffers
-		m_pRxDepths = std::unique_ptr<Container<LocationType> >(
+		m_pRxDepths = std::unique_ptr<Container<LocationType>>(
 			new Container<LocationType>(LocationGpu, cudaStreamDefault, parameters.getRxDepths()));
 
-		m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D> >(
+		m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D>>(
 			new Container<ScanlineRxParameters3D>(LocationGpu, cudaStreamDefault, parameters.getRxScanlines()));
 
-		m_pRxElementXs = std::unique_ptr<Container<LocationType> >(
+		m_pRxElementXs = std::unique_ptr<Container<LocationType>>(
 			new Container<LocationType>(LocationGpu, cudaStreamDefault, parameters.getRxElementXs()));
-		m_pRxElementYs = std::unique_ptr<Container<LocationType> >(
+		m_pRxElementYs = std::unique_ptr<Container<LocationType>>(
 			new Container<LocationType>(LocationGpu, cudaStreamDefault, parameters.getRxElementYs()));
 	}
 
@@ -63,7 +63,7 @@ namespace supra
 			double factor = 1 / oldFactor / (speedOfSoundMMperS * dt);
 			double factorTime = 1 / oldFactorTime / dt;
 
-			m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D> >(new Container<ScanlineRxParameters3D>(LocationHost, *m_pRxScanlines));
+			m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D>>(new Container<ScanlineRxParameters3D>(LocationHost, *m_pRxScanlines));
 			for (size_t i = 0; i < m_numRxScanlines; i++)
 			{
 				ScanlineRxParameters3D p = m_pRxScanlines->get()[i];
@@ -75,24 +75,24 @@ namespace supra
 				p.maxElementDistance = p.maxElementDistance*factor;
 				m_pRxScanlines->get()[i] = p;
 			}
-			m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D> >(new Container<ScanlineRxParameters3D>(LocationGpu, *m_pRxScanlines));
+			m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D>>(new Container<ScanlineRxParameters3D>(LocationGpu, *m_pRxScanlines));
 
-			m_pRxDepths = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationHost, *m_pRxDepths));
+			m_pRxDepths = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationHost, *m_pRxDepths));
 			for (size_t i = 0; i < m_rxNumDepths; i++)
 			{
 				m_pRxDepths->get()[i] = static_cast<LocationType>(m_pRxDepths->get()[i] * factor);
 			}
-			m_pRxDepths = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationGpu, *m_pRxDepths));
+			m_pRxDepths = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationGpu, *m_pRxDepths));
 
-			m_pRxElementXs = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationHost, *m_pRxElementXs));
-			m_pRxElementYs = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationHost, *m_pRxElementYs));
+			m_pRxElementXs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationHost, *m_pRxElementXs));
+			m_pRxElementYs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationHost, *m_pRxElementYs));
 			for (size_t i = 0; i < numTransducerElements; i++)
 			{
 				m_pRxElementXs->get()[i] = static_cast<LocationType>(m_pRxElementXs->get()[i] * factor);
 				m_pRxElementYs->get()[i] = static_cast<LocationType>(m_pRxElementYs->get()[i] * factor);
 			}
-			m_pRxElementXs = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationGpu, *m_pRxElementXs));
-			m_pRxElementYs = std::unique_ptr<Container<LocationType> >(new Container<LocationType>(LocationGpu, *m_pRxElementYs));
+			m_pRxElementXs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationGpu, *m_pRxElementXs));
+			m_pRxElementYs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationGpu, *m_pRxElementYs));
 
 			m_lastSeenDt = dt;
 			m_speedOfSoundMMperS = speedOfSoundMMperS;
@@ -332,14 +332,14 @@ namespace supra
 		{
 			if (interpolateBetweenTransmits)
 			{
-				rxBeamformingDTSPACE3DKernel<SampleBeamformer, true, true, 1024, maxWindowFunctionNumel> << <gridSize, blockSize, 0, stream>> > (
+				rxBeamformingDTSPACE3DKernel<SampleBeamformer, true, true, 1024, maxWindowFunctionNumel> <<<gridSize, blockSize, 0, stream>>> (
 					(uint32_t)numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout),
 					(uint32_t)numReceivedChannels, (uint32_t)numTimesteps, RF,
 					(uint32_t)numTxScanlines, (uint32_t)numRxScanlines, scanlines,
 					(uint32_t)numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s);
 			}
 			else {
-				rxBeamformingDTSPACE3DKernel<SampleBeamformer, true, false, 1024, maxWindowFunctionNumel> << <gridSize, blockSize, 0, stream>> > (
+				rxBeamformingDTSPACE3DKernel<SampleBeamformer, true, false, 1024, maxWindowFunctionNumel> <<<gridSize, blockSize, 0, stream>>> (
 					(uint32_t)numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout),
 					(uint32_t)numReceivedChannels, (uint32_t)numTimesteps, RF,
 					(uint32_t)numTxScanlines, (uint32_t)numRxScanlines, scanlines,
@@ -349,14 +349,14 @@ namespace supra
 		else {
 			if (interpolateBetweenTransmits)
 			{
-				rxBeamformingDTSPACE3DKernel<SampleBeamformer, false, true, 1024, maxWindowFunctionNumel> << <gridSize, blockSize, 0, stream>> > (
+				rxBeamformingDTSPACE3DKernel<SampleBeamformer, false, true, 1024, maxWindowFunctionNumel> <<<gridSize, blockSize, 0, stream>>> (
 					(uint32_t)numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout),
 					(uint32_t)numReceivedChannels, (uint32_t)numTimesteps, RF,
 					(uint32_t)numTxScanlines, (uint32_t)numRxScanlines, scanlines,
 					(uint32_t)numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s);
 			}
 			else {
-				rxBeamformingDTSPACE3DKernel<SampleBeamformer, false, false, 1024, maxWindowFunctionNumel> << <gridSize, blockSize, 0, stream>> > (
+				rxBeamformingDTSPACE3DKernel<SampleBeamformer, false, false, 1024, maxWindowFunctionNumel> <<<gridSize, blockSize, 0, stream>>> (
 					(uint32_t)numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout),
 					(uint32_t)numReceivedChannels, (uint32_t)numTimesteps, RF,
 					(uint32_t)numTxScanlines, (uint32_t)numRxScanlines, scanlines,
@@ -396,13 +396,13 @@ namespace supra
 		{
 			if (interpolateBetweenTransmits)
 			{
-				rxBeamformingDTSPACEKernel<SampleBeamformer, true, true> << <gridSize, blockSize, 0, stream>> > (
+				rxBeamformingDTSPACEKernel<SampleBeamformer, true, true> <<<gridSize, blockSize, 0, stream>>> (
 					numTransducerElements, numReceivedChannels, numTimesteps, RF,
 					numTxScanlines, numRxScanlines, scanlines,
 					numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s);
 			}
 			else {
-				rxBeamformingDTSPACEKernel<SampleBeamformer, true, false> << <gridSize, blockSize, 0, stream>> > (
+				rxBeamformingDTSPACEKernel<SampleBeamformer, true, false> <<<gridSize, blockSize, 0, stream>>> (
 					numTransducerElements, numReceivedChannels, numTimesteps, RF,
 					numTxScanlines, numRxScanlines, scanlines,
 					numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s);
@@ -411,13 +411,13 @@ namespace supra
 		else {
 			if (interpolateBetweenTransmits)
 			{
-				rxBeamformingDTSPACEKernel<SampleBeamformer, false, true> << <gridSize, blockSize, 0, stream>> > (
+				rxBeamformingDTSPACEKernel<SampleBeamformer, false, true> <<<gridSize, blockSize, 0, stream>>> (
 					numTransducerElements, numReceivedChannels, numTimesteps, RF,
 					numTxScanlines, numRxScanlines, scanlines,
 					numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s);
 			}
 			else {
-				rxBeamformingDTSPACEKernel<SampleBeamformer, false, false> << <gridSize, blockSize, 0, stream>> > (
+				rxBeamformingDTSPACEKernel<SampleBeamformer, false, false> <<<gridSize, blockSize, 0, stream>>> (
 					numTransducerElements, numReceivedChannels, numTimesteps, RF,
 					numTxScanlines, numRxScanlines, scanlines,
 					numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s);
@@ -441,11 +441,11 @@ namespace supra
 		auto gRawData = rawData->getData<ChannelDataType>();
 		if (!gRawData->isGPU() && !gRawData->isBoth())
 		{
-			gRawData = std::make_shared<Container<ChannelDataType> >(LocationGpu, *gRawData);
+			gRawData = std::make_shared<Container<ChannelDataType>>(LocationGpu, *gRawData);
 		}
 
 		size_t numelOut = m_numRxScanlines*m_rxNumDepths;
-		shared_ptr<Container<ImageDataType> > pData = std::make_shared<Container<ImageDataType> >(ContainerLocation::LocationGpu, gRawData->getStream(), numelOut);
+		shared_ptr<Container<ImageDataType>> pData = std::make_shared<Container<ImageDataType>>(ContainerLocation::LocationGpu, gRawData->getStream(), numelOut);
 
 		double dt = 1.0 / rawData->getSamplingFrequency();
 
diff --git a/src/SupraLib/Beamformer/ScanConverter.cu b/src/SupraLib/Beamformer/ScanConverter.cu
index 2102dcb..b1c9f97 100644
--- a/src/SupraLib/Beamformer/ScanConverter.cu
+++ b/src/SupraLib/Beamformer/ScanConverter.cu
@@ -425,24 +425,24 @@ namespace supra
 		}
 	}
 
-	shared_ptr<Container<uint8_t> > ScanConverter::getMask()
+	shared_ptr<Container<uint8_t>> ScanConverter::getMask()
 	{
 		return m_mask;
 	}
 
 	template<typename InputType, typename OutputType>
-	shared_ptr<Container<OutputType> > ScanConverter::convert(const shared_ptr<USImage>& inImage)
+	shared_ptr<Container<OutputType>> ScanConverter::convert(const shared_ptr<USImage>& inImage)
 	{
 		uint32_t numScanlines = (uint32_t)inImage->getImageProperties()->getNumScanlines();
 		vec2s scanlineLayout = inImage->getImageProperties()->getScanlineLayout();
 		uint32_t numSamples = (uint32_t)inImage->getImageProperties()->getNumSamples();
 
-		shared_ptr<const Container<InputType> > pScanlineData = inImage->getData<InputType>();
+		shared_ptr<const Container<InputType>> pScanlineData = inImage->getData<InputType>();
 		if (pScanlineData->isHost())
 		{
-			pScanlineData = make_shared<Container<InputType> >(LocationGpu, *pScanlineData);
+			pScanlineData = make_shared<Container<InputType>>(LocationGpu, *pScanlineData);
 		}
-		auto pConv = make_shared<Container<OutputType> >(LocationGpu, pScanlineData->getStream(), m_imageSize.x*m_imageSize.y*m_imageSize.z);
+		auto pConv = make_shared<Container<OutputType>>(LocationGpu, pScanlineData->getStream(), m_imageSize.x*m_imageSize.y*m_imageSize.z);
 
 		if (m_is2D)
 		{
@@ -450,7 +450,7 @@ namespace supra
 			dim3 gridSize(
 				static_cast<unsigned int>((m_imageSize.x + blockSize.x - 1) / blockSize.x),
 				static_cast<unsigned int>((m_imageSize.y + blockSize.y - 1) / blockSize.y));
-			scanConvert2D << <gridSize, blockSize, 0, pScanlineData->getStream()>> > (
+			scanConvert2D <<<gridSize, blockSize, 0, pScanlineData->getStream()>>> (
 				numScanlines,
 				numSamples,
 				(uint32_t)m_imageSize.x,
@@ -470,7 +470,7 @@ namespace supra
 				static_cast<unsigned int>((m_imageSize.x + blockSize.x - 1) / blockSize.x),
 				static_cast<unsigned int>((m_imageSize.y + blockSize.y - 1) / blockSize.y),
 				static_cast<unsigned int>((m_imageSize.z + blockSize.z - 1) / blockSize.z));
-			scanConvert3D << <gridSize, blockSize, 0, pScanlineData->getStream()>> > (
+			scanConvert3D <<<gridSize, blockSize, 0, pScanlineData->getStream()>>> (
 				(uint32_t)scanlineLayout.x,
 				(uint32_t)scanlineLayout.y,
 				numSamples,
@@ -490,23 +490,23 @@ namespace supra
 	}
 
 	template
-		std::shared_ptr<Container<uint8_t> > ScanConverter::convert<uint8_t, uint8_t>(const std::shared_ptr<USImage>& inImage);
+		std::shared_ptr<Container<uint8_t>> ScanConverter::convert<uint8_t, uint8_t>(const std::shared_ptr<USImage>& inImage);
 	template
-		std::shared_ptr<Container<int16_t> > ScanConverter::convert<uint8_t, int16_t>(const std::shared_ptr<USImage>& inImage);
+		std::shared_ptr<Container<int16_t>> ScanConverter::convert<uint8_t, int16_t>(const std::shared_ptr<USImage>& inImage);
 	template
-		std::shared_ptr<Container<float> > ScanConverter::convert<uint8_t, float>(const std::shared_ptr<USImage>& inImage);
+		std::shared_ptr<Container<float>> ScanConverter::convert<uint8_t, float>(const std::shared_ptr<USImage>& inImage);
 	template
-		std::shared_ptr<Container<uint8_t> > ScanConverter::convert<int16_t, uint8_t>(const std::shared_ptr<USImage>& inImage);
+		std::shared_ptr<Container<uint8_t>> ScanConverter::convert<int16_t, uint8_t>(const std::shared_ptr<USImage>& inImage);
 	template
-		std::shared_ptr<Container<int16_t> > ScanConverter::convert<int16_t, int16_t>(const std::shared_ptr<USImage>& inImage);
+		std::shared_ptr<Container<int16_t>> ScanConverter::convert<int16_t, int16_t>(const std::shared_ptr<USImage>& inImage);
 	template
-		std::shared_ptr<Container<float> > ScanConverter::convert<int16_t, float>(const std::shared_ptr<USImage>& inImage);
+		std::shared_ptr<Container<float>> ScanConverter::convert<int16_t, float>(const std::shared_ptr<USImage>& inImage);
 	template
-		std::shared_ptr<Container<uint8_t> > ScanConverter::convert<float, uint8_t>(const std::shared_ptr<USImage>& inImage);
+		std::shared_ptr<Container<uint8_t>> ScanConverter::convert<float, uint8_t>(const std::shared_ptr<USImage>& inImage);
 	template
-		std::shared_ptr<Container<int16_t> > ScanConverter::convert<float, int16_t>(const std::shared_ptr<USImage>& inImage);
+		std::shared_ptr<Container<int16_t>> ScanConverter::convert<float, int16_t>(const std::shared_ptr<USImage>& inImage);
 	template
-		std::shared_ptr<Container<float> > ScanConverter::convert<float, float>(const std::shared_ptr<USImage>& inImage);
+		std::shared_ptr<Container<float>> ScanConverter::convert<float, float>(const std::shared_ptr<USImage>& inImage);
 
 	void ScanConverter::updateInternals(const std::shared_ptr<const USImageProperties>& inImageProps)
 	{
@@ -643,16 +643,16 @@ namespace supra
 
 			// create buffers
 			size_t numelBuffers = m_imageSize.x*m_imageSize.y*m_imageSize.z;
-			/*m_mask = make_shared<Container<uint8_t> >(ContainerLocation::LocationHost, numelBuffers);
-			m_sampleIdx = make_shared<Container<IndexType> >(ContainerLocation::LocationHost, numelBuffers);
-			m_weightX = make_shared<Container<WeightType> >(ContainerLocation::LocationHost, numelBuffers);
-			m_weightY = make_shared<Container<WeightType> >(ContainerLocation::LocationHost, numelBuffers);
-			m_weightZ = make_shared<Container<WeightType> >(ContainerLocation::LocationHost, numelBuffers);*/
-			m_mask = make_shared<Container<uint8_t> >(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
-			m_sampleIdx = make_shared<Container<IndexType> >(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
-			m_weightX = make_shared<Container<WeightType> >(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
-			m_weightY = make_shared<Container<WeightType> >(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
-			m_weightZ = make_shared<Container<WeightType> >(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
+			/*m_mask = make_shared<Container<uint8_t>>(ContainerLocation::LocationHost, numelBuffers);
+			m_sampleIdx = make_shared<Container<IndexType>>(ContainerLocation::LocationHost, numelBuffers);
+			m_weightX = make_shared<Container<WeightType>>(ContainerLocation::LocationHost, numelBuffers);
+			m_weightY = make_shared<Container<WeightType>>(ContainerLocation::LocationHost, numelBuffers);
+			m_weightZ = make_shared<Container<WeightType>>(ContainerLocation::LocationHost, numelBuffers);*/
+			m_mask = make_shared<Container<uint8_t>>(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
+			m_sampleIdx = make_shared<Container<IndexType>>(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
+			m_weightX = make_shared<Container<WeightType>>(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
+			m_weightY = make_shared<Container<WeightType>>(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
+			m_weightZ = make_shared<Container<WeightType>>(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
 
 			//create image mask
 			cudaSafeCall(cudaMemsetAsync(m_mask->get(), 0, m_mask->size() * sizeof(uint8_t), cudaStreamPerThread));
@@ -660,11 +660,11 @@ namespace supra
 			if (m_is2D)
 			{
 				//2D is computed on the cpu at the moment -> copy
-				m_mask = make_shared<Container<uint8_t> >(LocationHost, *m_mask);
-				m_sampleIdx = make_shared<Container<IndexType> >(LocationHost, *m_sampleIdx);
-				m_weightX = make_shared<Container<WeightType> >(LocationHost, *m_weightX);
-				m_weightY = make_shared<Container<WeightType> >(LocationHost, *m_weightY);
-				m_weightZ = make_shared<Container<WeightType> >(LocationHost, *m_weightZ);
+				m_mask = make_shared<Container<uint8_t>>(LocationHost, *m_mask);
+				m_sampleIdx = make_shared<Container<IndexType>>(LocationHost, *m_sampleIdx);
+				m_weightX = make_shared<Container<WeightType>>(LocationHost, *m_weightX);
+				m_weightY = make_shared<Container<WeightType>>(LocationHost, *m_weightY);
+				m_weightZ = make_shared<Container<WeightType>>(LocationHost, *m_weightZ);
 
 				vec2 bb2DMin{ m_bbMin.x, m_bbMin.y };
 				assert(layout.x > 1);
@@ -733,11 +733,11 @@ namespace supra
 				}
 
 				//2D is computed on the cpu at the moment -> copy
-				m_mask = make_shared<Container<uint8_t> >(LocationGpu, *m_mask);
-				m_sampleIdx = make_shared<Container<IndexType> >(LocationGpu, *m_sampleIdx);
-				m_weightX = make_shared<Container<WeightType> >(LocationGpu, *m_weightX);
-				m_weightY = make_shared<Container<WeightType> >(LocationGpu, *m_weightY);
-				m_weightZ = make_shared<Container<WeightType> >(LocationGpu, *m_weightZ);
+				m_mask = make_shared<Container<uint8_t>>(LocationGpu, *m_mask);
+				m_sampleIdx = make_shared<Container<IndexType>>(LocationGpu, *m_sampleIdx);
+				m_weightX = make_shared<Container<WeightType>>(LocationGpu, *m_weightX);
+				m_weightY = make_shared<Container<WeightType>>(LocationGpu, *m_weightY);
+				m_weightZ = make_shared<Container<WeightType>>(LocationGpu, *m_weightZ);
 			}
 			else {
 				// 3D case
-- 
2.17.1

