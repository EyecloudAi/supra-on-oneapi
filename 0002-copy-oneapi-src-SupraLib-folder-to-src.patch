From c4d5a3ad0c0646a52440af6b372215e31b09a20d Mon Sep 17 00:00:00 2001
From: wangyon1 <yong4.wang@intel.com>
Date: Mon, 3 Aug 2020 15:14:20 +0800
Subject: [PATCH 2/4] copy oneapi/src/SupraLib folder to src/

---
 .../Beamformer/HilbertFirEnvelope.dp.cpp      | 130 +++
 src/SupraLib/Beamformer/LogCompressor.dp.cpp  |  89 ++
 src/SupraLib/Beamformer/RxBeamformerCommon.h  |  29 +-
 .../Beamformer/RxBeamformerCuda.dp.cpp        | 633 ++++++++++++
 .../RxSampleBeamformerDelayAndStdDev.h        |  23 +-
 .../RxSampleBeamformerDelayAndSum.h           |  19 +-
 .../Beamformer/RxSampleBeamformerTestSignal.h |   6 +-
 src/SupraLib/Beamformer/ScanConverter.dp.cpp  | 901 ++++++++++++++++++
 src/SupraLib/Beamformer/WindowFunction.h      |  31 +-
 src/SupraLib/Container.h                      | 125 ++-
 src/SupraLib/ContainerFactory.cpp.dp.cpp      | 290 ++++++
 src/SupraLib/ContainerFactory.h               |   4 +-
 src/SupraLib/RecordObject.h                   |   6 +-
 src/SupraLib/USImageProperties.h              |   2 +
 src/SupraLib/utilities/DataType.h             |   6 +-
 src/SupraLib/utilities/FirFilterFactory.h     |  27 +-
 src/SupraLib/utilities/Logging.h              |   6 +-
 src/SupraLib/utilities/cudaUtility.h          |  56 +-
 src/SupraLib/utilities/utility.h              |   2 +
 src/SupraLib/vec.h                            | 139 ++-
 20 files changed, 2329 insertions(+), 195 deletions(-)
 create mode 100644 src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp
 create mode 100644 src/SupraLib/Beamformer/LogCompressor.dp.cpp
 create mode 100644 src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp
 create mode 100644 src/SupraLib/Beamformer/ScanConverter.dp.cpp
 create mode 100644 src/SupraLib/ContainerFactory.cpp.dp.cpp

diff --git a/src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp b/src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp
new file mode 100644
index 0000000..c321fe1
--- /dev/null
+++ b/src/SupraLib/Beamformer/HilbertFirEnvelope.dp.cpp
@@ -0,0 +1,130 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2019, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "HilbertFirEnvelope.h"
+#include <utilities/utility.h>
+#include <utilities/FirFilterFactory.h>
+
+#include <dpct/dpstd_utils.hpp>
+#include <dpstd/execution>
+#include <dpstd/algorithm>
+
+#include <algorithm>
+
+using namespace std;
+using namespace thrust::placeholders;
+
+namespace supra
+{
+	template <typename InputType, typename OutputType>
+	void kernelFilterDemodulation(
+		const InputType* __restrict__ signal,
+		const HilbertFirEnvelope::WorkType * __restrict__ filter,
+		OutputType * __restrict__ out,
+		const int numSamples,
+		const int numScanlines,
+		const int filterLength,
+		sycl::nd_item<3> item_ct1) {
+		int scanlineIdx = item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2);
+		int sampleIdx = item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1);
+
+		if (scanlineIdx < numScanlines && sampleIdx < numSamples)
+		{
+			HilbertFirEnvelope::WorkType accumulator = 0;
+			
+			int startPoint = sampleIdx - filterLength / 2;
+			int endPoint = sampleIdx + filterLength / 2;
+			int currentFilterElement = 0;
+			for (int currentSample = startPoint;
+				currentSample <= endPoint;
+				currentSample++, currentFilterElement++)
+			{
+				if (currentSample >= 0 && currentSample < numSamples)
+				{
+					HilbertFirEnvelope::WorkType sample = static_cast<HilbertFirEnvelope::WorkType>(signal[scanlineIdx + currentSample*numScanlines]);
+					HilbertFirEnvelope::WorkType filterElement = filter[currentFilterElement];
+					accumulator += sample*filterElement;
+				}
+			}
+
+			HilbertFirEnvelope::WorkType signalValue = static_cast<HilbertFirEnvelope::WorkType>(signal[scanlineIdx + sampleIdx*numScanlines]);
+			out[ scanlineIdx + sampleIdx * numScanlines ] = sycl::sqrt(squ(signalValue) + squ(accumulator));
+		}
+
+	}
+
+	HilbertFirEnvelope::HilbertFirEnvelope(size_t filterLength)
+		: m_filterLength(filterLength)
+		, m_hilbertFilter(nullptr)
+	{
+		prepareFilter();
+	}
+
+	HilbertFirEnvelope::~HilbertFirEnvelope()
+	{
+	}
+
+	void HilbertFirEnvelope::prepareFilter()
+	{
+		m_hilbertFilter = FirFilterFactory::createFilter<float>(
+			m_filterLength,
+			FirFilterFactory::FilterTypeHilbertTransformer,
+			FirFilterFactory::FilterWindowHamming);
+		m_hilbertFilter = make_shared<Container<float>>(LocationGpu, *m_hilbertFilter);
+	}
+
+	template<typename InputType, typename OutputType>
+	shared_ptr<Container<OutputType>> HilbertFirEnvelope::demodulate(
+		const shared_ptr<const Container<InputType>>& inImageData,
+		int numScanlines, int numSamples)
+	{
+		auto pEnv = make_shared<Container<OutputType>>(LocationGpu, inImageData->getStream(), numScanlines*numSamples);
+		sycl::range<3> blockSizeFilter(16, 8, 1);
+		sycl::range<3> gridSizeFilter(static_cast<unsigned int>((numScanlines + blockSizeFilter.x - 1) / blockSizeFilter.x),
+									  static_cast<unsigned int>((numSamples + blockSizeFilter.y - 1) / blockSizeFilter.y), 1);
+
+		inImageData->getStream()->submit([ & ](sycl::handler& cgh) {
+			auto dpct_global_range = gridSizeFilter * blockSizeFilter;
+
+			auto m_filterLength_ct5 = ( int )m_filterLength;
+
+			cgh.parallel_for(
+				sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+								  sycl::range<3>(blockSizeFilter.get(2), blockSizeFilter.get(1), blockSizeFilter.get(0))),
+				[ = ](sycl::nd_item<3> item_ct1) { kernelFilterDemodulation(inImageData->get(), m_hilbertFilter->get(), pEnv->get(), numSamples, numScanlines, m_filterLength_ct5, item_ct1); });
+		});
+		/*
+		DPCT1010:27: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+
+		return pEnv;
+	}
+
+	template 
+	shared_ptr<Container<int16_t>> HilbertFirEnvelope::demodulate<int16_t, int16_t>(
+		const shared_ptr<const Container<int16_t>>& inImageData,
+		int numScanlines, int numSamples);
+	template
+		shared_ptr<Container<int16_t>> HilbertFirEnvelope::demodulate<float, int16_t>(
+			const shared_ptr<const Container<float>>& inImageData,
+			int numScanlines, int numSamples);
+	template
+		shared_ptr<Container<float>> HilbertFirEnvelope::demodulate<int16_t, float>(
+			const shared_ptr<const Container<int16_t>>& inImageData,
+			int numScanlines, int numSamples);
+	template
+		shared_ptr<Container<float>> HilbertFirEnvelope::demodulate<float, float>(
+			const shared_ptr<const Container<float>>& inImageData,
+			int numScanlines, int numSamples);
+}
\ No newline at end of file
diff --git a/src/SupraLib/Beamformer/LogCompressor.dp.cpp b/src/SupraLib/Beamformer/LogCompressor.dp.cpp
new file mode 100644
index 0000000..216b76e
--- /dev/null
+++ b/src/SupraLib/Beamformer/LogCompressor.dp.cpp
@@ -0,0 +1,89 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "LogCompressor.h"
+
+#include <dpct/dpstd_utils.hpp>
+#include <dpstd/execution>
+#include <dpstd/algorithm>
+#include <cmath>
+
+using namespace std;
+
+namespace supra
+{
+	template <typename In, typename Out, typename WorkType>
+	struct thrustLogcompress : public thrust::unary_function<In, Out>
+	{
+		WorkType _inScale;
+		WorkType _scaleOverDenominator;
+
+		// Thrust functor that computes
+		// signal = log10(1 + a*signal)./log10(1 + a) 
+		// of the downscaled (_inMax) input signal
+		thrustLogcompress(double dynamicRange, In inMax, Out outMax, double scale)
+			: _inScale(static_cast<WorkType>(dynamicRange / inMax)), _scaleOverDenominator(static_cast<WorkType>(scale * outMax / log10(dynamicRange + 1))){};
+
+		Out operator()(const In& a) const
+		{
+			WorkType val = log10(abs(static_cast<WorkType>(a))*_inScale + (WorkType)1) * _scaleOverDenominator;
+			return clampCast<Out>(val);
+		}
+	};
+
+	template <typename InputType, typename OutputType>
+	shared_ptr<Container<OutputType>> LogCompressor::compress(const shared_ptr<const Container<InputType>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax)
+	{
+		size_t width = size.x;
+		size_t height = size.y;
+		size_t depth = size.z;
+
+		auto pComprGpu = make_shared<Container<OutputType>>(LocationGpu, inImageData->getStream(), width*height*depth);
+
+		OutputType outMax;
+		if (std::is_integral<OutputType>::value)
+		{
+			outMax = std::numeric_limits<OutputType>::max();
+		}
+		else if (std::is_floating_point<OutputType>::value)
+		{
+			outMax = static_cast<OutputType>(255.0);
+		}
+
+		thrustLogcompress<InputType, OutputType, WorkType> c(sycl::pow(( double )(10), (dynamicRange / 20)), static_cast<InputType>(inMax), outMax, scale);
+		/*
+		DPCT1007:30: Migration of this CUDA API is not supported by the Intel(R) DPC++ Compatibility Tool.
+		*/
+		std::transform(dpstd::execution::make_sycl_policy<class Policy_7d1962>(dpct::get_default_queue()), thrust::cuda::par.on(inImageData->getStream()), inImageData->get(),
+					   inImageData->get() + (width * height * depth), pComprGpu->get(), c);
+		/*
+		DPCT1010:31: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+
+		return pComprGpu;
+	}
+
+	template
+	shared_ptr<Container<uint8_t>> LogCompressor::compress<int16_t, uint8_t>(const shared_ptr<const Container<int16_t>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<uint8_t>> LogCompressor::compress<float, uint8_t>(const shared_ptr<const Container<float>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<uint8_t>> LogCompressor::compress<uint8_t, uint8_t>(const shared_ptr<const Container<uint8_t>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<float>> LogCompressor::compress<int16_t, float>(const shared_ptr<const Container<int16_t>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<float>> LogCompressor::compress<float, float>(const shared_ptr<const Container<float>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+	template
+	shared_ptr<Container<float>> LogCompressor::compress<uint8_t, float>(const shared_ptr<const Container<uint8_t>>& inImageData, vec3s size, double dynamicRange, double scale, double inMax);
+}
\ No newline at end of file
diff --git a/src/SupraLib/Beamformer/RxBeamformerCommon.h b/src/SupraLib/Beamformer/RxBeamformerCommon.h
index 1e9f442..cb0eaa3 100644
--- a/src/SupraLib/Beamformer/RxBeamformerCommon.h
+++ b/src/SupraLib/Beamformer/RxBeamformerCommon.h
@@ -12,6 +12,8 @@
 #ifndef __RXBEAMFORMERCOMMON_H__
 #define __RXBEAMFORMERCOMMON_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include "WindowFunction.h"
 
 //TODO ALL ELEMENT/SCANLINE Y positons are actually Z! Change all variable names accordingly
@@ -19,45 +21,36 @@ namespace supra
 {
 
 	template <typename T>
-	__device__ inline T computeAperture_D(T F, T z)
+	inline T computeAperture_D(T F, T z)
 	{
 		return z / (2 * F);
 	}
 
 	template <typename T>
-	__device__ inline T computeDelayDTSPACE_D(T dirX, T dirY, T dirZ, T x_element, T x, T z)
+	inline T computeDelayDTSPACE_D(T dirX, T dirY, T dirZ, T x_element, T x, T z)
 	{
-		return sqrt((x_element - (x + dirX*z))*
-			(x_element - (x + dirX*z)) +
-			(dirY*z)*(dirY*z)) + z;
+		return sycl::sqrt((x_element - (x + dirX * z)) * (x_element - (x + dirX * z)) + (dirY * z) * (dirY * z)) + z;
 	}
 
 	template <typename T>
-	__device__ inline T computeDelayDTSPACE3D_D(T dirX, T dirY, T dirZ, T x_element, T z_element, T x, T z, T d)
+	inline T computeDelayDTSPACE3D_D(T dirX, T dirY, T dirZ, T x_element, T z_element, T x, T z, T d)
 	{
-		return sqrt(
-			squ(x_element - (x + dirX*d)) +
-			squ(z_element - (z + dirZ*d)) +
-			squ(dirY*d)) + d;
+		return sycl::sqrt(squ(x_element - (x + dirX * d)) + squ(z_element - (z + dirZ * d)) + squ(dirY * d)) + d;
 	}
 
 	// distance has to be normalized to [-1, 1] (inclusive)
-	__device__ inline WindowFunctionGpu::ElementType
+	inline WindowFunctionGpu::ElementType
 		computeWindow3D(const WindowFunctionGpu& windowFunction, const vec2f& distance)
 	{
-		return
-			sqrt(windowFunction.get(distance.x)*
-				windowFunction.get(distance.y));
+		return sycl::sqrt(windowFunction.get(distance.x) * windowFunction.get(distance.y));
 	}
 
 
 	// distance has to be normalized to [-1, 1] (inclusive)
-	__device__ inline WindowFunctionGpu::ElementType
+	inline WindowFunctionGpu::ElementType
 		computeWindow3DShared(const WindowFunctionGpu& windowFunction, const WindowFunctionGpu::ElementType * __restrict__ sharedData, const vec2f& distance)
 	{
-		return
-			sqrt(windowFunction.getShared(sharedData, distance.x)*
-				windowFunction.getShared(sharedData, distance.y));
+		return sycl::sqrt(windowFunction.getShared(sharedData, distance.x) * windowFunction.getShared(sharedData, distance.y));
 	}
 }
 
diff --git a/src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp b/src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp
new file mode 100644
index 0000000..6fbf368
--- /dev/null
+++ b/src/SupraLib/Beamformer/RxBeamformerCuda.dp.cpp
@@ -0,0 +1,633 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2016, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "RxBeamformerCuda.h"
+#include "USImage.h"
+#include "USRawData.h"
+#include "RxSampleBeamformerDelayAndSum.h"
+#include "RxSampleBeamformerDelayAndStdDev.h"
+#include "RxSampleBeamformerTestSignal.h"
+#include "RxBeamformerCommon.h"
+#include "utilities/cudaUtility.h"
+
+//TODO ALL ELEMENT/SCANLINE Y positons are actually Z! Change all variable names accordingly
+namespace supra
+{
+	RxBeamformerCuda::RxBeamformerCuda(const RxBeamformerParameters & parameters)
+		: m_windowFunction(nullptr)
+	{
+		m_lastSeenDt = 0;
+		m_numRxScanlines = parameters.getNumRxScanlines();
+		m_rxScanlineLayout = parameters.getRxScanlineLayout();
+
+		m_is3D = (m_rxScanlineLayout.x > 1 && m_rxScanlineLayout.y > 1);
+		m_speedOfSoundMMperS = parameters.getSpeedOfSoundMMperS();
+		m_rxNumDepths = parameters.getRxNumDepths();
+
+		// create and fill new buffers
+		m_pRxDepths = std::unique_ptr<Container<LocationType>>(
+			new Container<LocationType>(LocationGpu, cudaStreamDefault, parameters.getRxDepths()));
+
+		m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D>>(
+			new Container<ScanlineRxParameters3D>(LocationGpu, cudaStreamDefault, parameters.getRxScanlines()));
+
+		m_pRxElementXs = std::unique_ptr<Container<LocationType>>(
+			new Container<LocationType>(LocationGpu, cudaStreamDefault, parameters.getRxElementXs()));
+		m_pRxElementYs = std::unique_ptr<Container<LocationType>>(
+			new Container<LocationType>(LocationGpu, cudaStreamDefault, parameters.getRxElementYs()));
+	}
+
+	RxBeamformerCuda::~RxBeamformerCuda()
+	{
+	}
+
+	void RxBeamformerCuda::convertToDtSpace(double dt, double speedOfSoundMMperS, size_t numTransducerElements) const
+	{
+		if (m_lastSeenDt != dt || m_speedOfSoundMMperS != speedOfSoundMMperS)
+		{
+			double oldFactor = 1;
+			double oldFactorTime = 1;
+			if (m_lastSeenDt != 0 && m_speedOfSoundMMperS != 0)
+			{
+				oldFactor = 1 / (m_speedOfSoundMMperS * m_lastSeenDt);
+				oldFactorTime = 1 / m_lastSeenDt;
+			}
+
+			double factor = 1 / oldFactor / (speedOfSoundMMperS * dt);
+			double factorTime = 1 / oldFactorTime / dt;
+
+			m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D>>(new Container<ScanlineRxParameters3D>(LocationHost, *m_pRxScanlines));
+			for (size_t i = 0; i < m_numRxScanlines; i++)
+			{
+				ScanlineRxParameters3D p = m_pRxScanlines->get()[i];
+				p.position = p.position*factor;
+				for (size_t k = 0; k < std::extent<decltype(p.txWeights)>::value; k++)
+				{
+					p.txParameters[k].initialDelay *= factorTime;
+				}
+				p.maxElementDistance = p.maxElementDistance*factor;
+				m_pRxScanlines->get()[i] = p;
+			}
+			m_pRxScanlines = std::unique_ptr<Container<ScanlineRxParameters3D>>(new Container<ScanlineRxParameters3D>(LocationGpu, *m_pRxScanlines));
+
+			m_pRxDepths = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationHost, *m_pRxDepths));
+			for (size_t i = 0; i < m_rxNumDepths; i++)
+			{
+				m_pRxDepths->get()[i] = static_cast<LocationType>(m_pRxDepths->get()[i] * factor);
+			}
+			m_pRxDepths = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationGpu, *m_pRxDepths));
+
+			m_pRxElementXs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationHost, *m_pRxElementXs));
+			m_pRxElementYs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationHost, *m_pRxElementYs));
+			for (size_t i = 0; i < numTransducerElements; i++)
+			{
+				m_pRxElementXs->get()[i] = static_cast<LocationType>(m_pRxElementXs->get()[i] * factor);
+				m_pRxElementYs->get()[i] = static_cast<LocationType>(m_pRxElementYs->get()[i] * factor);
+			}
+			m_pRxElementXs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationGpu, *m_pRxElementXs));
+			m_pRxElementYs = std::unique_ptr<Container<LocationType>>(new Container<LocationType>(LocationGpu, *m_pRxElementYs));
+
+			m_lastSeenDt = dt;
+			m_speedOfSoundMMperS = speedOfSoundMMperS;
+		}
+	}
+
+	template <class SampleBeamformer, bool interpolateRFlines, bool interpolateBetweenTransmits, unsigned int maxNumElements, unsigned int maxNumFunctionElements, typename RFType, typename ResultType, typename LocationType>
+	
+		void rxBeamformingDTSPACE3DKernel(
+			uint32_t numTransducerElements,
+			vec2T<uint32_t> elementLayout,
+			uint32_t numReceivedChannels,
+			uint32_t numTimesteps,
+			const RFType* __restrict__ RF,
+			uint32_t numTxScanlines,
+			uint32_t numRxScanlines,
+			const ScanlineRxParameters3D* __restrict__ scanlinesDT,
+			uint32_t numDs,
+			const LocationType* __restrict__ dsDT,
+			const LocationType* __restrict__ x_elemsDT,
+			const LocationType* __restrict__ z_elemsDT,
+			LocationType speedOfSound,
+			LocationType dt,
+			uint32_t additionalOffset,
+			LocationType F,
+			const WindowFunctionGpu windowFunction,
+			ResultType* __restrict__ s,
+			sycl::nd_item<3> item_ct1,
+			LocationType *x_elemsDTsh,
+			LocationType *z_elemsDTsh,
+			supra::WindowFunction::ElementType *functionShared)
+	{
+
+		//fetch element positions to shared memory
+		for (int threadId = (item_ct1.get_local_id(1) * item_ct1.get_local_range().get(2)) + item_ct1.get_local_id(2);	//@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+			 threadId < maxNumElements && threadId < numTransducerElements;
+			 threadId += item_ct1.get_local_range().get(2) * item_ct1.get_local_range().get(1))	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		{
+			x_elemsDTsh[threadId] = x_elemsDT[threadId];
+			z_elemsDTsh[threadId] = z_elemsDT[threadId];
+		}
+		for (int threadId = (item_ct1.get_local_id(1) * item_ct1.get_local_range().get(2)) + item_ct1.get_local_id(2);	//@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+			 threadId < maxNumFunctionElements && threadId < windowFunction.numElements();
+			 threadId += item_ct1.get_local_range().get(2) * item_ct1.get_local_range().get(1))	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		{
+			functionShared[threadId] = windowFunction.getDirect(threadId);
+		}
+		item_ct1.barrier();	 //@suppress("Function cannot be resolved")
+
+		int r = item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1);			 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		int scanlineIdx = item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2);	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+
+		if (r < numDs && scanlineIdx < numRxScanlines)
+		{
+			LocationType d = dsDT[r];
+			//TODO should this also depend on the angle?
+			LocationType aDT = squ(computeAperture_D(F, d*dt*speedOfSound) / speedOfSound / dt);
+			ScanlineRxParameters3D scanline = scanlinesDT[scanlineIdx];
+
+			LocationType scanline_x = scanline.position.x;
+			LocationType scanline_z = scanline.position.z;
+			LocationType dirX = scanline.direction.x;
+			LocationType dirY = scanline.direction.y;
+			LocationType dirZ = scanline.direction.z;
+			vec2f maxElementDistance = static_cast<vec2f>(scanline.maxElementDistance);
+			vec2f		 invMaxElementDistance = vec2f{ 1.0f, 1.0f } / min(vec2f{ sycl::sqrt(aDT), sycl::sqrt(aDT) }, maxElementDistance);
+
+			float sInterp = 0.0f;
+
+			int highestWeightIndex;
+			if (!interpolateBetweenTransmits)
+			{
+				highestWeightIndex = 0;
+				float highestWeight = scanline.txWeights[0];
+				for (int k = 1; k < std::extent<decltype(scanline.txWeights)>::value; k++)
+				{
+					if (scanline.txWeights[k] > highestWeight)
+					{
+						highestWeight = scanline.txWeights[k];
+						highestWeightIndex = k;
+					}
+				}
+			}
+
+			// now iterate over all four txScanlines to interpolate beamformed scanlines from those transmits
+			for (int k = (interpolateBetweenTransmits ? 0 : highestWeightIndex);
+				(interpolateBetweenTransmits && k < std::extent<decltype(scanline.txWeights)>::value) ||
+				(!interpolateBetweenTransmits && k == highestWeightIndex);
+				k++)
+			{
+				if (scanline.txWeights[k] > 0.0)
+				{
+					ScanlineRxParameters3D::TransmitParameters txParams = scanline.txParameters[k];
+					uint32_t txScanlineIdx = txParams.txScanlineIdx;
+					if (txScanlineIdx >= numTxScanlines)
+					{
+						//ERROR!
+						return;
+					}
+					float sLocal = 0.0f;
+					
+					sLocal = SampleBeamformer::template sampleBeamform3D<interpolateRFlines, RFType, float, LocationType>(
+						txParams, RF, elementLayout, numReceivedChannels, numTimesteps,
+						x_elemsDTsh, z_elemsDTsh, scanline_x, scanline_z, dirX, dirY, dirZ,
+						aDT, d, invMaxElementDistance, speedOfSound, dt, additionalOffset, &windowFunction, functionShared);
+
+					if (interpolateBetweenTransmits)
+					{
+						sInterp += static_cast<float>(scanline.txWeights[k])* sLocal;
+					}
+					else
+					{
+						sInterp += sLocal;
+					}
+				}
+			}
+			s[scanlineIdx + r * numRxScanlines] = clampCast<ResultType>(sInterp);
+		}
+	}
+
+	template <class SampleBeamformer, bool interpolateRFlines, bool interpolateBetweenTransmits, typename RFType, typename ResultType, typename LocationType>
+	
+		void rxBeamformingDTSPACEKernel(
+			size_t numTransducerElements,
+			size_t numReceivedChannels,
+			size_t numTimesteps,
+			const RFType* __restrict__ RF,
+			size_t numTxScanlines,
+			size_t numRxScanlines,
+			const ScanlineRxParameters3D* __restrict__ scanlinesDT,
+			size_t numDs,
+			const LocationType* __restrict__ dsDT,
+			const LocationType* __restrict__ x_elemsDT,
+			LocationType speedOfSound,
+			LocationType dt,
+			uint32_t additionalOffset,
+			LocationType F,
+			const WindowFunctionGpu windowFunction,
+			ResultType* __restrict__ s,
+			sycl::nd_item<3> item_ct1)
+	{
+		int r = item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1);			 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		int scanlineIdx = item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2);	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		if (r < numDs && scanlineIdx < numRxScanlines)
+		{
+			LocationType d = dsDT[r];
+			//TODO should this also depend on the angle?
+			LocationType aDT = computeAperture_D(F, d*dt*speedOfSound) / speedOfSound / dt;
+			ScanlineRxParameters3D scanline = scanlinesDT[scanlineIdx];
+			LocationType scanline_x = scanline.position.x;
+			LocationType dirX = scanline.direction.x;
+			LocationType dirY = scanline.direction.y;
+			LocationType dirZ = scanline.direction.z;
+			LocationType maxElementDistance = static_cast<LocationType>(scanline.maxElementDistance.x);
+			LocationType		   invMaxElementDistance = 1 / sycl::min(aDT, maxElementDistance);
+
+			float sInterp = 0.0f;
+
+			int highestWeightIndex;
+			if (!interpolateBetweenTransmits)
+			{
+				highestWeightIndex = 0;
+				float highestWeight = scanline.txWeights[0];
+				for (int k = 1; k < std::extent<decltype(scanline.txWeights)>::value; k++)
+				{
+					if (scanline.txWeights[k] > highestWeight)
+					{
+						highestWeight = scanline.txWeights[k];
+						highestWeightIndex = k;
+					}
+				}
+			}
+
+			// now iterate over all four txScanlines to interpolate beamformed scanlines from those transmits
+			for (int k = (interpolateBetweenTransmits ? 0 : highestWeightIndex);
+				(interpolateBetweenTransmits && k < std::extent<decltype(scanline.txWeights)>::value) ||
+				(!interpolateBetweenTransmits && k == highestWeightIndex);
+				k++)
+			{
+				if (scanline.txWeights[k] > 0.0)
+				{
+					ScanlineRxParameters3D::TransmitParameters txParams = scanline.txParameters[k];
+					uint32_t txScanlineIdx = txParams.txScanlineIdx;
+					if (txScanlineIdx >= numTxScanlines)
+					{
+						//ERROR!
+						return;
+					}
+
+					float sLocal = 0.0f;
+					sLocal = SampleBeamformer::template sampleBeamform2D<interpolateRFlines, RFType, float, LocationType>(
+						txParams, RF, numTransducerElements, numReceivedChannels, numTimesteps,
+						x_elemsDT, scanline_x, dirX, dirY, dirZ,
+						aDT, d, invMaxElementDistance, speedOfSound, dt, additionalOffset, &windowFunction);
+
+					if (interpolateBetweenTransmits)
+					{
+						sInterp += static_cast<float>(scanline.txWeights[k])* sLocal;
+					}
+					else
+					{
+						sInterp += sLocal;
+					}
+				}
+			}
+			s[scanlineIdx + r * numRxScanlines] = clampCast<ResultType>(sInterp);
+		}
+	}
+
+	template <class SampleBeamformer, unsigned int maxWindowFunctionNumel, typename RFType, typename ResultType, typename LocationType>
+	void rxBeamformingDTspaceCuda3D(bool interpolateRFlines, bool interpolateBetweenTransmits, size_t numTransducerElements, vec2s elementLayout, size_t numReceivedChannels, size_t numTimesteps,
+									const RFType* RF, size_t numTxScanlines, size_t numRxScanlines, const ScanlineRxParameters3D* scanlines, size_t numZs, const LocationType* zs,
+									const LocationType* x_elems, const LocationType* y_elems, LocationType speedOfSound, LocationType dt, uint32_t additionalOffset, LocationType F,
+									const WindowFunctionGpu windowFunction, sycl::queue* stream, ResultType* s)
+	{
+		sycl::range<3> blockSize(1, 256, 1);
+		sycl::range<3> gridSize(static_cast<unsigned int>((numRxScanlines + blockSize.x - 1) / blockSize.x), static_cast<unsigned int>((numZs + blockSize.y - 1) / blockSize.y), 1);
+
+		if (interpolateRFlines)
+		{
+			if (interpolateBetweenTransmits)
+			{
+				stream->submit([ & ](sycl::handler& cgh) {
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   x_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   z_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<supra::WindowFunction::ElementType, 1, sycl::access::mode::read_write, sycl::access::target::local> functionShared_acc_ct1(sycl::range<1>(maxWindowFunctionNumel),
+																																							  cgh);
+
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACE3DKernel<SampleBeamformer, true, true, 1024, maxWindowFunctionNumel>(
+											 ( uint32_t )numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout), ( uint32_t )numReceivedChannels, ( uint32_t )numTimesteps, RF,
+											 ( uint32_t )numTxScanlines, ( uint32_t )numRxScanlines, scanlines, ( uint32_t )numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F,
+											 windowFunction, s, item_ct1, x_elemsDTsh_acc_ct1.get_pointer(), z_elemsDTsh_acc_ct1.get_pointer(), functionShared_acc_ct1.get_pointer());
+									 });
+				});
+			}
+			else {
+				stream->submit([ & ](sycl::handler& cgh) {
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   x_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   z_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<supra::WindowFunction::ElementType, 1, sycl::access::mode::read_write, sycl::access::target::local> functionShared_acc_ct1(sycl::range<1>(maxWindowFunctionNumel),
+																																							  cgh);
+
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACE3DKernel<SampleBeamformer, true, false, 1024, maxWindowFunctionNumel>(
+											 ( uint32_t )numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout), ( uint32_t )numReceivedChannels, ( uint32_t )numTimesteps, RF,
+											 ( uint32_t )numTxScanlines, ( uint32_t )numRxScanlines, scanlines, ( uint32_t )numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F,
+											 windowFunction, s, item_ct1, x_elemsDTsh_acc_ct1.get_pointer(), z_elemsDTsh_acc_ct1.get_pointer(), functionShared_acc_ct1.get_pointer());
+									 });
+				});
+			}
+		}
+		else {
+			if (interpolateBetweenTransmits)
+			{
+				stream->submit([ & ](sycl::handler& cgh) {
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   x_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   z_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<supra::WindowFunction::ElementType, 1, sycl::access::mode::read_write, sycl::access::target::local> functionShared_acc_ct1(sycl::range<1>(maxWindowFunctionNumel),
+																																							  cgh);
+
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACE3DKernel<SampleBeamformer, false, true, 1024, maxWindowFunctionNumel>(
+											 ( uint32_t )numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout), ( uint32_t )numReceivedChannels, ( uint32_t )numTimesteps, RF,
+											 ( uint32_t )numTxScanlines, ( uint32_t )numRxScanlines, scanlines, ( uint32_t )numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F,
+											 windowFunction, s, item_ct1, x_elemsDTsh_acc_ct1.get_pointer(), z_elemsDTsh_acc_ct1.get_pointer(), functionShared_acc_ct1.get_pointer());
+									 });
+				});
+			}
+			else {
+				stream->submit([ & ](sycl::handler& cgh) {
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   x_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<LocationType, 1, sycl::access::mode::read_write, sycl::access::target::local>					   z_elemsDTsh_acc_ct1(sycl::range<1>(1024), cgh);
+					sycl::accessor<supra::WindowFunction::ElementType, 1, sycl::access::mode::read_write, sycl::access::target::local> functionShared_acc_ct1(sycl::range<1>(maxWindowFunctionNumel),
+																																							  cgh);
+
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACE3DKernel<SampleBeamformer, false, false, 1024, maxWindowFunctionNumel>(
+											 ( uint32_t )numTransducerElements, static_cast<vec2T<uint32_t>>(elementLayout), ( uint32_t )numReceivedChannels, ( uint32_t )numTimesteps, RF,
+											 ( uint32_t )numTxScanlines, ( uint32_t )numRxScanlines, scanlines, ( uint32_t )numZs, zs, x_elems, y_elems, speedOfSound, dt, additionalOffset, F,
+											 windowFunction, s, item_ct1, x_elemsDTsh_acc_ct1.get_pointer(), z_elemsDTsh_acc_ct1.get_pointer(), functionShared_acc_ct1.get_pointer());
+									 });
+				});
+			}
+		}
+		/*
+		DPCT1010:34: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+	}
+
+	template <class SampleBeamformer, typename RFType, typename ResultType, typename LocationType>
+	void rxBeamformingDTspaceCuda(bool interpolateRFlines, bool interpolateBetweenTransmits, size_t numTransducerElements, size_t numReceivedChannels, size_t numTimesteps, const RFType* RF,
+								  size_t numTxScanlines, size_t numRxScanlines, const ScanlineRxParameters3D* scanlines, size_t numZs, const LocationType* zs, const LocationType* x_elems,
+								  LocationType speedOfSound, LocationType dt, uint32_t additionalOffset, LocationType F, const WindowFunctionGpu windowFunction, sycl::queue* stream, ResultType* s)
+	{
+		sycl::range<3> blockSize(1, 256, 1);
+		sycl::range<3> gridSize(static_cast<unsigned int>((numRxScanlines + blockSize.x - 1) / blockSize.x), static_cast<unsigned int>((numZs + blockSize.y - 1) / blockSize.y), 1);
+		if (interpolateRFlines)
+		{
+			if (interpolateBetweenTransmits)
+			{
+				stream->submit([ & ](sycl::handler& cgh) {
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACEKernel<SampleBeamformer, true, true>(numTransducerElements, numReceivedChannels, numTimesteps, RF, numTxScanlines, numRxScanlines,
+																								  scanlines, numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s, item_ct1);
+									 });
+				});
+			}
+			else {
+				stream->submit([ & ](sycl::handler& cgh) {
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACEKernel<SampleBeamformer, true, false>(numTransducerElements, numReceivedChannels, numTimesteps, RF, numTxScanlines, numRxScanlines,
+																								   scanlines, numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s, item_ct1);
+									 });
+				});
+			}
+		}
+		else {
+			if (interpolateBetweenTransmits)
+			{
+				stream->submit([ & ](sycl::handler& cgh) {
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACEKernel<SampleBeamformer, false, true>(numTransducerElements, numReceivedChannels, numTimesteps, RF, numTxScanlines, numRxScanlines,
+																								   scanlines, numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s, item_ct1);
+									 });
+				});
+			}
+			else {
+				stream->submit([ & ](sycl::handler& cgh) {
+					auto dpct_global_range = gridSize * blockSize;
+
+					cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+													   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+									 [ = ](sycl::nd_item<3> item_ct1) {
+										 rxBeamformingDTSPACEKernel<SampleBeamformer, false, false>(numTransducerElements, numReceivedChannels, numTimesteps, RF, numTxScanlines, numRxScanlines,
+																									scanlines, numZs, zs, x_elems, speedOfSound, dt, additionalOffset, F, windowFunction, s, item_ct1);
+									 });
+				});
+			}
+		}
+		/*
+		DPCT1010:35: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+		*/
+		cudaSafeCall(0);
+	}
+
+	template <typename ChannelDataType, typename ImageDataType>
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const
+	{
+		//Ensure the raw-data are on the gpu
+		auto gRawData = rawData->getData<ChannelDataType>();
+		if (!gRawData->isGPU() && !gRawData->isBoth())
+		{
+			gRawData = std::make_shared<Container<ChannelDataType>>(LocationGpu, *gRawData);
+		}
+
+		size_t numelOut = m_numRxScanlines*m_rxNumDepths;
+		shared_ptr<Container<ImageDataType>> pData = std::make_shared<Container<ImageDataType>>(ContainerLocation::LocationGpu, gRawData->getStream(), numelOut);
+
+		double dt = 1.0 / rawData->getSamplingFrequency();
+
+		if (!m_windowFunction || m_windowFunction->getType() != windowType || m_windowFunction->getParameter() != windowParameter)
+		{
+			m_windowFunction = std::unique_ptr<WindowFunction>(new WindowFunction(windowType, windowParameter, m_windowFunctionNumEntries));
+		}
+
+		auto beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndSum, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+		auto beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndSum, ChannelDataType, ImageDataType, LocationType>;
+		switch (sampleBeamformer)
+		{
+		case DelayAndSum:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndSum, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndSum, ChannelDataType, ImageDataType, LocationType>;
+			break;
+		case DelayAndStdDev:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndStdDev, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndStdDev, ChannelDataType, ImageDataType, LocationType>;
+			break;
+		case TestSignal:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerTestSignal, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerTestSignal, ChannelDataType, ImageDataType, LocationType>;
+			break;
+		case INVALID:
+		default:
+			beamformingFunction3D = &rxBeamformingDTspaceCuda3D<RxSampleBeamformerDelayAndSum, m_windowFunctionNumEntries, ChannelDataType, ImageDataType, LocationType>;
+			beamformingFunction2D = &rxBeamformingDTspaceCuda<RxSampleBeamformerDelayAndSum, ChannelDataType, ImageDataType, LocationType>;
+		}
+
+
+		convertToDtSpace(dt, speedOfSoundMMperS, rawData->getNumElements());
+		if (m_is3D)
+		{
+			beamformingFunction3D(
+				true,
+				interpolateBetweenTransmits,
+				rawData->getNumElements(),
+				rawData->getElementLayout(),
+				rawData->getNumReceivedChannels(),
+				rawData->getNumSamples(),
+				gRawData->get(),
+				rawData->getNumScanlines(), // numTxScanlines
+				m_numRxScanlines,			// numRxScanlines
+				m_pRxScanlines->get(),
+				m_rxNumDepths, m_pRxDepths->get(),
+				m_pRxElementXs->get(),
+				m_pRxElementYs->get(),
+				static_cast<LocationType>(m_speedOfSoundMMperS),
+				static_cast<LocationType>(dt),
+				additionalOffset,
+				static_cast<LocationType>(fNumber),
+				*(m_windowFunction->getGpu()),
+				gRawData->getStream(),
+				pData->get()
+				);
+		}
+		else {
+			beamformingFunction2D(
+				true,
+				interpolateBetweenTransmits,
+				rawData->getNumElements(),
+				rawData->getNumReceivedChannels(),
+				rawData->getNumSamples(),
+				gRawData->get(),
+				rawData->getNumScanlines(), // numTxScanlines
+				m_numRxScanlines,			// numRxScanlines
+				m_pRxScanlines->get(),
+				m_rxNumDepths, m_pRxDepths->get(),
+				m_pRxElementXs->get(),
+				static_cast<LocationType>(m_speedOfSoundMMperS),
+				static_cast<LocationType>(dt),
+				additionalOffset,
+				static_cast<LocationType>(fNumber),
+				*(m_windowFunction->getGpu()),
+				gRawData->getStream(),
+				pData->get()
+				);
+		}
+
+		if (rawData->getImageProperties() != m_lastSeenImageProperties)
+		{
+			m_lastSeenImageProperties = rawData->getImageProperties();
+			shared_ptr<USImageProperties> newProps = std::make_shared<USImageProperties>(*m_lastSeenImageProperties);
+			newProps->setScanlineLayout(m_rxScanlineLayout);
+			newProps->setNumSamples(m_rxNumDepths);
+			newProps->setImageState(USImageProperties::RF);
+			m_editedImageProperties = std::const_pointer_cast<const USImageProperties>(newProps);
+		}
+
+		auto retImage = std::make_shared<USImage>(
+			vec2s{ m_numRxScanlines, m_rxNumDepths },
+			pData,
+			m_editedImageProperties,
+			rawData->getReceiveTimestamp(),
+			rawData->getSyncTimestamp());
+
+		return retImage;
+	}
+
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<int16_t, int16_t>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<int16_t, float>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<float, int16_t>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+	template
+	shared_ptr<USImage> RxBeamformerCuda::performRxBeamforming<float, float>(
+		RxBeamformerCuda::RxSampleBeamformer sampleBeamformer,
+		shared_ptr<const USRawData> rawData,
+		double fNumber,
+		double speedOfSoundMMperS,
+		WindowType windowType,
+		WindowFunction::ElementType windowParameter,
+		bool interpolateBetweenTransmits,
+		int32_t additionalOffset) const;
+}
\ No newline at end of file
diff --git a/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h b/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h
index e6e0e61..36f1226 100644
--- a/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h
+++ b/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndStdDev.h
@@ -12,6 +12,8 @@
 #ifndef __RXSAMPLEBEAMFORMERDELAYANDSTDDEV_H__
 #define __RXSAMPLEBEAMFORMERDELAYANDSTDDEV_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include "USImageProperties.h"
 #include "WindowFunction.h"
 #include "RxBeamformerCommon.h"
@@ -34,7 +36,7 @@ namespace supra
 	{
 	public:
 		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
-		static __device__ ResultType sampleBeamform3D(
+		static ResultType sampleBeamform3D(
 			ScanlineRxParameters3D::TransmitParameters txParams,
 			const RFType* RF,
 			vec2T<uint32_t> elementLayout,
@@ -105,7 +107,7 @@ namespace supra
 						{
 							LocationType delayf = initialDelay +
 								computeDelayDTSPACE3D_D(dirX, dirY, dirZ, x_elem, z_elem, scanline_x, scanline_z, depth) + additionalOffset;
-							uint32_t delay = static_cast<uint32_t>(::floor(delayf));
+							uint32_t delay = static_cast<uint32_t>(sycl::floor(delayf));
 							delayf -= delay;
 							if (delay < (numTimesteps - 1))
 							{
@@ -120,8 +122,8 @@ namespace supra
 						}
 						else
 						{
-							uint32_t delay = static_cast<uint32_t>(::round(
-								initialDelay + computeDelayDTSPACE3D_D(dirX, dirY, dirZ, x_elem, z_elem, scanline_x, scanline_z, depth)) + additionalOffset);
+							uint32_t delay =
+								static_cast<uint32_t>(sycl::round(initialDelay + computeDelayDTSPACE3D_D(dirX, dirY, dirZ, x_elem, z_elem, scanline_x, scanline_z, depth)) + additionalOffset);
 							if (delay < numTimesteps)
 							{
 								value = weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
@@ -134,7 +136,7 @@ namespace supra
 			}
 			if (numAdds > 0)
 			{
-				return sqrt(sd) / weightAcum * numAdds;
+				return sycl::sqrt(sd) / weightAcum * numAdds;
 			}
 			else
 			{
@@ -143,7 +145,7 @@ namespace supra
 		}
 
 		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
-		static __device__ ResultType sampleBeamform2D(
+		static ResultType sampleBeamform2D(
 			ScanlineRxParameters3D::TransmitParameters txParams,
 			const RFType* RF,
 			uint32_t numTransducerElements,
@@ -193,7 +195,7 @@ namespace supra
 			{
 				int32_t  channelIdx = elemIdxX % numReceivedChannels;
 				LocationType x_elem = x_elemsDT[elemIdxX];
-				if (abs(x_elem - scanline_x) <= aDT)
+				if (sycl::fabs(x_elem - scanline_x) <= aDT)
 				{
 					float weight = windowFunction->get((x_elem - scanline_x) * invMaxElementDistance);
 					weightAcum += weight;
@@ -202,7 +204,7 @@ namespace supra
 					{
 						LocationType delayf = initialDelay +
 							computeDelayDTSPACE_D(dirX, dirY, dirZ, x_elem, scanline_x, depth) + additionalOffset;
-						int32_t delay = static_cast<int32_t>(floor(delayf));
+						int32_t delay = static_cast<int32_t>(sycl::floor(delayf));
 						delayf -= delay;
 						if (delay < (numTimesteps - 1))
 						{
@@ -217,8 +219,7 @@ namespace supra
 					}
 					else
 					{
-						int32_t delay = static_cast<int32_t>(round(
-							initialDelay + computeDelayDTSPACE_D(dirX, dirY, dirZ, x_elem, scanline_x, depth)) + additionalOffset);
+						int32_t delay = static_cast<int32_t>(sycl::round(initialDelay + computeDelayDTSPACE_D(dirX, dirY, dirZ, x_elem, scanline_x, depth)) + additionalOffset);
 						if (delay < numTimesteps)
 						{
 							value = weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
@@ -230,7 +231,7 @@ namespace supra
 			}
 			if (numAdds > 0)
 			{
-				return sqrt(sd) / weightAcum * numAdds;
+				return sycl::sqrt(sd) / weightAcum * numAdds;
 			}
 			else
 			{
diff --git a/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h b/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h
index 6547d6d..26c8b00 100644
--- a/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h
+++ b/src/SupraLib/Beamformer/RxSampleBeamformerDelayAndSum.h
@@ -12,6 +12,8 @@
 #ifndef __RXSAMPLEBEAMFORMERDELAYANDSUM_H__
 #define __RXSAMPLEBEAMFORMERDELAYANDSUM_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include "USImageProperties.h"
 #include "WindowFunction.h"
 #include "RxBeamformerCommon.h"
@@ -23,7 +25,7 @@ namespace supra
 	{
 	public:
 		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
-		static __device__ ResultType sampleBeamform3D(
+		static ResultType sampleBeamform3D(
 			ScanlineRxParameters3D::TransmitParameters txParams,
 			const RFType* RF,
 			vec2T<uint32_t> elementLayout,
@@ -70,7 +72,7 @@ namespace supra
 						{
 							LocationType delayf = initialDelay +
 								computeDelayDTSPACE3D_D(dirX, dirY, dirZ, x_elem, z_elem, scanline_x, scanline_z, depth) + additionalOffset;
-							uint32_t delay = static_cast<uint32_t>(::floor(delayf));
+							uint32_t delay = static_cast<uint32_t>(sycl::floor(delayf));
 							delayf -= delay;
 							if (delay < (numTimesteps - 1))
 							{
@@ -85,8 +87,8 @@ namespace supra
 						}
 						else
 						{
-							uint32_t delay = static_cast<uint32_t>(::round(
-								initialDelay + computeDelayDTSPACE3D_D(dirX, dirY, dirZ, x_elem, z_elem, scanline_x, scanline_z, depth)) + additionalOffset);
+							uint32_t delay =
+								static_cast<uint32_t>(sycl::round(initialDelay + computeDelayDTSPACE3D_D(dirX, dirY, dirZ, x_elem, z_elem, scanline_x, scanline_z, depth)) + additionalOffset);
 							if (delay < numTimesteps)
 							{
 								sample += weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
@@ -106,7 +108,7 @@ namespace supra
 		}
 
 		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
-		static __device__ ResultType sampleBeamform2D(
+		static ResultType sampleBeamform2D(
 			ScanlineRxParameters3D::TransmitParameters txParams,
 			const RFType* RF,
 			uint32_t numTransducerElements,
@@ -136,7 +138,7 @@ namespace supra
 			{
 				int32_t  channelIdx = elemIdxX % numReceivedChannels;
 				LocationType x_elem = x_elemsDT[elemIdxX];
-				if (abs(x_elem - scanline_x) <= aDT)
+				if (sycl::fabs(x_elem - scanline_x) <= aDT)
 				{
 					float weight = windowFunction->get((x_elem - scanline_x) * invMaxElementDistance);
 					weightAcum += weight;
@@ -145,7 +147,7 @@ namespace supra
 					{
 						LocationType delayf = initialDelay +
 							computeDelayDTSPACE_D(dirX, dirY, dirZ, x_elem, scanline_x, depth) + additionalOffset;
-						int32_t delay = static_cast<int32_t>(floor(delayf));
+						int32_t delay = static_cast<int32_t>(sycl::floor(delayf));
 						delayf -= delay;
 						if (delay < (numTimesteps - 1))
 						{
@@ -160,8 +162,7 @@ namespace supra
 					}
 					else
 					{
-						int32_t delay = static_cast<int32_t>(round(
-							initialDelay + computeDelayDTSPACE_D(dirX, dirY, dirZ, x_elem, scanline_x, depth)) + additionalOffset);
+						int32_t delay = static_cast<int32_t>(sycl::round(initialDelay + computeDelayDTSPACE_D(dirX, dirY, dirZ, x_elem, scanline_x, depth)) + additionalOffset);
 						if (delay < numTimesteps)
 						{
 							sample += weight * RF[delay + channelIdx*numTimesteps + txScanlineIdx*numReceivedChannels*numTimesteps];
diff --git a/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h b/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h
index 9d131a9..9b44dc3 100644
--- a/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h
+++ b/src/SupraLib/Beamformer/RxSampleBeamformerTestSignal.h
@@ -12,6 +12,8 @@
 #ifndef __RXSAMPLEBEAMFORMERTESTSIGNAL_H__
 #define __RXSAMPLEBEAMFORMERTESTSIGNAL_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include "USImageProperties.h"
 #include "WindowFunction.h"
 #include "RxBeamformerCommon.h"
@@ -23,7 +25,7 @@ namespace supra
 	{
 	public:
 		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
-		static __device__ ResultType sampleBeamform3D(
+		static ResultType sampleBeamform3D(
 			ScanlineRxParameters3D::TransmitParameters txParams,
 			const RFType* RF,
 			vec2T<uint32_t> elementLayout,
@@ -85,7 +87,7 @@ namespace supra
 		}
 
 		template <bool interpolateRFlines, typename RFType, typename ResultType, typename LocationType>
-		static __device__ ResultType sampleBeamform2D(
+		static ResultType sampleBeamform2D(
 			ScanlineRxParameters3D::TransmitParameters txParams,
 			const RFType* RF,
 			uint32_t numTransducerElements,
diff --git a/src/SupraLib/Beamformer/ScanConverter.dp.cpp b/src/SupraLib/Beamformer/ScanConverter.dp.cpp
new file mode 100644
index 0000000..050784c
--- /dev/null
+++ b/src/SupraLib/Beamformer/ScanConverter.dp.cpp
@@ -0,0 +1,901 @@
+// ================================================================================================
+// 
+// Copyright (C) 2016, Rüdiger Göbl - all rights reserved
+// Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.
+//
+//          Rüdiger Göbl
+//          Email r.goebl@tum.de
+//          Chair for Computer Aided Medical Procedures
+//          Technische Universität München
+//          Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License, version 2.1, as published by the Free Software Foundation.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this program.  If not, see
+// <http://www.gnu.org/licenses/>.
+//
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "ScanConverter.h"
+#include <cassert>
+#include <utilities/cudaUtility.h>
+#include <utilities/Logging.h>
+
+#include <dpct/dpstd_utils.hpp>
+#include <dpstd/execution>
+#include <dpstd/algorithm>
+#include <cmath>
+
+using namespace std;
+
+namespace supra
+{
+	class ScanConverterInternals {
+	public:
+		typedef ScanConverter::IndexType IndexType;
+		typedef ScanConverter::WeightType WeightType;
+
+		static constexpr double m_tetrahedronTestDistanceThreshold = 1e-9;
+		static constexpr int m_mappingMaxIterations = ScanConverter::m_mappingMaxIterations;
+		static constexpr double m_mappingDistanceThreshold = ScanConverter::m_mappingDistanceThreshold;
+
+		template <typename Tf, typename Ti>
+		static void computeParametersVoxel3D(
+			const Tf &sampleDistance,
+			const vec2T<Ti> &scanlineLayout,
+			const int &scanlineIdxX,
+			const int &scanlineIdxY,
+			const vec3T<Tf> &s1,
+			const vec3T<Tf> &e1,
+			const vec3T<Tf> &s2,
+			const vec3T<Tf> &e2,
+			const vec3T<Tf> &s3,
+			const vec3T<Tf> &e3,
+			const vec3T<Tf> &s4,
+			const vec3T<Tf> &e4,
+			const vec3T<Tf> &scanline1Pos,
+			const vec3T<Tf> &scanline1Dir,
+			const vec3T<Tf> &scanline2Pos,
+			const vec3T<Tf> &scanline2Dir,
+			const vec3T<Tf> &scanline3Pos,
+			const vec3T<Tf> &scanline3Dir,
+			const vec3T<Tf> &scanline4Pos,
+			const vec3T<Tf> &scanline4Dir,
+			const Tf &startDepth,
+			const Tf &endDepth,
+			const vec3T<Ti> &imageSize,
+			const vec3T<Ti> &voxel,
+			const vec3T<Tf> &voxelPos,
+			uint8_t* __restrict__ maskBuf,
+			uint32_t* __restrict__ sampleIdxBuf,
+			float* __restrict__ weightXBuf,
+			float* __restrict__ weightYBuf,
+			float* __restrict__ weightZBuf
+		)
+		{
+			if (pointInsideTetrahedron(s1, s2, s3, e1, voxelPos) ||
+				pointInsideTetrahedron(s2, s4, s3, e4, voxelPos) ||
+				pointInsideTetrahedron(s2, e1, e2, e4, voxelPos) ||
+				pointInsideTetrahedron(s3, e3, e1, e4, voxelPos) ||
+				pointInsideTetrahedron(s2, s3, e1, e4, voxelPos))
+			{
+
+				thrust::pair<vec3T<Tf>, bool> params = mapToParameters3D<Tf, Ti>(
+					scanline1Pos,
+					scanline2Pos,
+					scanline3Pos,
+					scanline4Pos,
+					scanline1Dir,
+					scanline2Dir,
+					scanline3Dir,
+					scanline4Dir,
+					startDepth, endDepth, voxelPos);
+
+				if (params.second)
+				{
+					size_t voxelIndex = voxel.x + voxel.y*imageSize.x + voxel.z*imageSize.x*imageSize.y;
+					maskBuf[voxelIndex] = 1;
+
+					Tf t1 = params.first.x;
+					Tf t2 = params.first.y;
+					Tf d = params.first.z + 0;
+
+					IndexType  sampleIdxScanline = static_cast<IndexType>(sycl::floor(d / sampleDistance));
+					WeightType weightY = static_cast<WeightType>(d / sampleDistance - sampleIdxScanline);
+					WeightType weightX = static_cast<WeightType>(t1);
+					WeightType weightZ = static_cast<WeightType>(t2);
+
+					IndexType sampleIdx = static_cast<IndexType>(sampleIdxScanline*scanlineLayout.x*scanlineLayout.y +
+						scanlineIdxX + scanlineIdxY*scanlineLayout.x);
+
+					sampleIdxBuf[voxelIndex] = sampleIdx;
+					weightXBuf[voxelIndex] = weightX;
+					weightYBuf[voxelIndex] = weightY;
+					weightZBuf[voxelIndex] = weightZ;
+				}
+			}
+		}
+
+		/**
+		 * Tests whether point p lies within the tetrahedron defined by a, b, c, d.
+		 *
+		 * For the test, the barycentric coordinates of p are computed and checked for equal sign.
+		 */
+		template <typename Tf>
+		static bool pointInsideTetrahedron(const vec3T<Tf> & a, const vec3T<Tf> & b, const vec3T<Tf> & c, const vec3T<Tf> & d, const vec3T<Tf> & p)
+		{
+			Tf w0 = barycentricCoordinate3D(a, b, c, d);
+
+			Tf w1 = barycentricCoordinate3D(p, b, c, d);
+			Tf w2 = barycentricCoordinate3D(a, p, c, d);
+			Tf w3 = barycentricCoordinate3D(a, b, p, d);
+			Tf w4 = barycentricCoordinate3D(a, b, c, p);
+
+			return w0 > 0 &&
+				w1 >= -m_tetrahedronTestDistanceThreshold &&
+				w2 >= -m_tetrahedronTestDistanceThreshold &&
+				w3 >= -m_tetrahedronTestDistanceThreshold &&
+				w4 >= -m_tetrahedronTestDistanceThreshold;
+		}
+
+		template <typename Tf>
+		static Tf barycentricCoordinate3D(const vec3T<Tf> & a, const vec3T<Tf> & b, const vec3T<Tf> & c, const vec3T<Tf> & p)
+		{
+			//computes the determinant of 
+			//[a_x, a_y, a_z, 1]
+			//[b_x, b_y, b_z, 1]
+			//[c_x, c_y, c_z, 1]
+			//[p_x, p_y, p_z, 1]
+
+			// reducing 12 multiplications per compute
+			const Tf axby = a.x*b.y;
+			const Tf cypz = c.y*p.z;
+			const Tf axbz = a.x*b.z;
+			const Tf czpy = c.z*p.y;
+			const Tf aybx = a.y*b.x;
+			const Tf cxpz = c.x*p.z;
+			const Tf aybz = a.y*b.z;
+			const Tf czpx = c.z*p.x;
+			const Tf azbx = a.z*b.x;
+			const Tf cxpy = c.x*p.y;
+			const Tf azby = a.z*b.y;
+			const Tf cypx = c.y*p.x;
+
+			return 
+				(axby-aybx)*(c.z-p.z) + (aybz-azby)*(c.x-p.x) +
+				(azbx-axbz)*(c.y-p.y) + (cypz-czpy)*(a.x-b.x) -
+				(cxpz-czpx)*(a.y-b.y) + (cxpy-cypx)*(a.z-b.z);
+			// reducing 18 multiplications with the updated return statement per compute 			
+		}
+
+		template <typename Tf>
+		static vec3T<Tf> pointPlaneConnection(const vec3T<Tf> & a, const vec3T<Tf> & na, const vec3T<Tf> & x)
+		{
+			return dot(na, (x - a))*na;
+		}
+
+		template <typename Tf, typename Ti>
+		static thrust::pair<vec3T<Tf>, bool> mapToParameters3D(
+			const vec3T<Tf> & a,
+			const vec3T<Tf> & ax,
+			const vec3T<Tf> & ay,
+			const vec3T<Tf> & axy,
+			const vec3T<Tf> & da,
+			const vec3T<Tf> & dax,
+			const vec3T<Tf> & day,
+			const vec3T<Tf> & daxy,
+			Tf startDepth,
+			Tf endDepth,
+			const vec3T<Tf> & x)
+		{
+			vec3T<Tf> normalXLow = normalize(cross(da, (ay + day) - a));
+			vec3T<Tf> normalYLow = normalize(cross((ax + dax) - a, da));
+			vec3T<Tf> normalXHigh = normalize(cross(dax, (axy + daxy) - ax));
+			vec3T<Tf> normalYHigh = normalize(cross((axy + daxy) - ay, day));
+
+			//find t via binary search
+			vec2T<Tf> lowT = { 0, 0 };
+			vec2T<Tf> highT = { 1, 1 };
+			vec3T<Tf> lowConnX = pointPlaneConnection(a, normalXLow, x);
+			vec3T<Tf> highConnX = pointPlaneConnection(ax, normalXHigh, x);
+			vec3T<Tf> lowConnY = pointPlaneConnection(a, normalYLow, x);
+			vec3T<Tf> highConnY = pointPlaneConnection(ay, normalYHigh, x);
+			vec2T<Tf> lowDist = { norm(lowConnX), norm(lowConnY) };
+			vec2T<Tf> highDist = { norm(highConnX), norm(highConnY) };
+
+			if (dot(lowConnX, highConnX) > 0 || dot(lowConnY, highConnY) > 0)
+			{
+				return thrust::pair<vec3T<Tf>, bool>(vec3T<Tf>{ 0, 0, 0 }, false);
+			}
+
+			vec2T<Tf> dist = { 1e10, 1e10 };
+			vec2T<Tf> t = (highT - lowT) / 2 + lowT;
+			vec3T<Tf> planeBaseX1;
+			vec3T<Tf> planeBaseY1;
+			vec3T<Tf> planeBaseX2;
+			vec3T<Tf> planeBaseY2;
+			for (int numIter = 0; numIter < m_mappingMaxIterations &&
+				(dist.x > m_mappingDistanceThreshold || dist.y > m_mappingDistanceThreshold); numIter++)
+			{
+				t = (1 - highDist / (highDist + lowDist))*highT + (1 - lowDist / (highDist + lowDist))*lowT;
+
+				planeBaseX1 = (1 - t.x)*a + t.x*ax;
+				planeBaseX2 = (1 - t.x)*ay + t.x*axy;
+				planeBaseY1 = (1 - t.y)*a + t.y*ay;
+				planeBaseY2 = (1 - t.y)*ax + t.y*axy;
+				vec3T<Tf> dir = slerp3(slerp3(da, dax, t.x), slerp3(day, daxy, t.x), t.y);
+				vec3T<Tf> normal_x = normalize(cross(dir, planeBaseX2 - planeBaseX1));
+				vec3T<Tf> normal_y = normalize(cross(planeBaseY2 - planeBaseY1, dir));
+
+				vec3T<Tf> connX = pointPlaneConnection(planeBaseX1, normal_x, x);
+				vec3T<Tf> connY = pointPlaneConnection(planeBaseY1, normal_y, x);
+
+				dist.x = norm(connX);
+				dist.y = norm(connY);
+
+				if (dot(highConnX, connX) > M_EPS)
+				{
+					highT.x = t.x;
+					highConnX = connX;
+					highDist.x = dist.x;
+				}
+				else if (dot(lowConnX, connX) > M_EPS)
+				{
+					lowT.x = t.x;
+					lowConnX = connX;
+					lowDist.x = dist.x;
+				}
+
+				if (dot(highConnY, connY) > M_EPS)
+				{
+					highT.y = t.y;
+					highConnY = connY;
+					highDist.y = dist.y;
+				}
+				else if (dot(lowConnY, connY) > M_EPS)
+				{
+					lowT.y = t.y;
+					lowConnY = connY;
+					lowDist.y = dist.y;
+				}
+			}
+
+			vec3T<Tf> lineBase = (1 - t.y)*planeBaseX1 + t.y*planeBaseX2;
+			Tf d = norm(x - lineBase);
+
+			return thrust::pair<vec3T<Tf>, bool>(vec3T<Tf>{ t.x, t.y, d }, true);
+		}
+	};
+
+	template <typename Tf, typename Ti>
+	void
+		
+		computeParameterBB3D(
+			const Tf sampleDistance,
+			const vec2T<Ti> scanlineLayout,
+			const int scanlineIdxX,
+			const int scanlineIdxY,
+			const vec3T<Tf> s1,
+			const vec3T<Tf> e1,
+			const vec3T<Tf> s2,
+			const vec3T<Tf> e2,
+			const vec3T<Tf> s3,
+			const vec3T<Tf> e3,
+			const vec3T<Tf> s4,
+			const vec3T<Tf> e4,
+			const vec3T<Tf> scanline1Pos,
+			const vec3T<Tf> scanline1Dir,
+			const vec3T<Tf> scanline2Pos,
+			const vec3T<Tf> scanline2Dir,
+			const vec3T<Tf> scanline3Pos,
+			const vec3T<Tf> scanline3Dir,
+			const vec3T<Tf> scanline4Pos,
+			const vec3T<Tf> scanline4Dir,
+			const Tf startDepth,
+			const Tf endDepth,
+			const vec3T<Ti> imageSize,
+			const vec3T<Tf> bbMin,
+			const vec3T<Ti> tetMinVoxel,
+			const vec3T<Ti> tetMaxVoxel,
+			const Tf resolution,
+			uint8_t* __restrict__ maskBuf,
+			uint32_t* __restrict__ sampleIdxBuf,
+			float* __restrict__ weightXBuf,
+			float* __restrict__ weightYBuf,
+			float* __restrict__ weightZBuf
+		,
+			sycl::nd_item<3> item_ct1)
+	{
+		vec3T<Ti> voxel = vec3T<Ti>{ static_cast<Ti>(item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2)),
+									 static_cast<Ti>(item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1)),
+									 static_cast<Ti>(item_ct1.get_local_range().get(0) * item_ct1.get_group(0)
+													 + item_ct1.get_local_id(0)) };	 //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+		voxel = voxel + tetMinVoxel;
+
+		if (voxel.x <= tetMaxVoxel.x && voxel.y <= tetMaxVoxel.y && voxel.z <= tetMaxVoxel.z)
+		{
+			vec3T<Tf> voxelPos = static_cast<vec3T<Tf>>(voxel) * resolution + bbMin;
+			ScanConverterInternals::computeParametersVoxel3D(
+				sampleDistance,
+				scanlineLayout,
+				scanlineIdxX, scanlineIdxY,
+				s1, e1, s2, e2, s3, e3, s4, e4,
+				scanline1Pos,
+				scanline1Dir,
+				scanline2Pos,
+				scanline2Dir,
+				scanline3Pos,
+				scanline3Dir,
+				scanline4Pos,
+				scanline4Dir,
+				startDepth, endDepth,
+				imageSize,
+				voxel,
+				voxelPos,
+				maskBuf,
+				sampleIdxBuf,
+				weightXBuf,
+				weightYBuf,
+				weightZBuf);
+		}
+	}
+
+	template <typename InputType, typename OutputType, typename WeightType, typename IndexType>
+	void scanConvert2D(
+		uint32_t numScanlines,
+		uint32_t numSamples,
+		uint32_t width,
+		uint32_t height,
+		const uint8_t* __restrict__ mask,
+		const IndexType* __restrict__ sampleIdx,
+		const WeightType* __restrict__ weightX,
+		const WeightType* __restrict__ weightY,
+		const InputType* __restrict__ scanlines,
+		OutputType* __restrict__ image,
+		sycl::nd_item<3> item_ct1)
+	{
+		vec2T<uint32_t> pixelPos{ item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2),
+								  item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1) };  //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+
+		if (pixelPos.x < width && pixelPos.y < height)
+		{
+			IndexType pixelIdx = pixelPos.x + pixelPos.y*width;
+			float val = 0;
+			if (mask[pixelIdx])
+			{
+				IndexType sIdx = sampleIdx[pixelIdx];
+				WeightType wX = weightX[pixelIdx];
+				WeightType wY = weightY[pixelIdx];
+
+				val = (1 - wY)*((1 - wX)*scanlines[sIdx] +
+					wX *scanlines[sIdx + 1]) +
+					wY *((1 - wX)*scanlines[sIdx + numScanlines] +
+						wX *scanlines[sIdx + 1 + numScanlines]);
+			}
+			image[pixelIdx] = clampCast<OutputType>(val);
+		}
+	}
+
+	template <typename InputType, typename OutputType, typename WeightType, typename IndexType>
+	void scanConvert3D(
+		uint32_t numScanlinesX,
+		uint32_t numScanlinesY,
+		uint32_t numSamples,
+		uint32_t width,
+		uint32_t height,
+		uint32_t depth,
+		const uint8_t* __restrict__ mask,
+		const IndexType* __restrict__ sampleIdx,
+		const WeightType* __restrict__ weightX,
+		const WeightType* __restrict__ weightY,
+		const WeightType* __restrict__ weightZ,
+		const InputType* __restrict__ scanlines,
+		OutputType* __restrict__ image,
+		sycl::nd_item<3> item_ct1)
+	{
+		vec3T<uint32_t> pixelPos{ item_ct1.get_local_range().get(2) * item_ct1.get_group(2) + item_ct1.get_local_id(2),
+								  item_ct1.get_local_range().get(1) * item_ct1.get_group(1) + item_ct1.get_local_id(1),
+								  item_ct1.get_local_range().get(0) * item_ct1.get_group(0) + item_ct1.get_local_id(0) };  //@suppress("Symbol is not resolved") @suppress("Field cannot be resolved")
+
+		if (pixelPos.x < width && pixelPos.y < height)
+		{
+			IndexType pixelIdx = pixelPos.x + pixelPos.y*width + pixelPos.z*width*height;
+			float val = 0;
+			if (mask[pixelIdx])
+			{
+				uint32_t numScanlines = numScanlinesX*numScanlinesY;
+				IndexType sIdx = sampleIdx[pixelIdx];
+				WeightType wX = weightX[pixelIdx];
+				WeightType wY = weightY[pixelIdx];
+				WeightType wZ = weightZ[pixelIdx];
+
+
+				val =
+					(1 - wY)*((1 - wZ)*((1 - wX)*scanlines[sIdx] +
+						wX *scanlines[sIdx + 1]) +
+						wZ *((1 - wX)*scanlines[sIdx + numScanlinesX] +
+							wX *scanlines[sIdx + 1 + numScanlinesX])) +
+					wY* ((1 - wZ)*((1 - wX)*scanlines[sIdx + numScanlines] +
+						wX *scanlines[sIdx + 1 + numScanlines]) +
+						wZ *((1 - wX)*scanlines[sIdx + numScanlinesX + numScanlines] +
+							wX *scanlines[sIdx + 1 + numScanlinesX + numScanlines]));
+			}
+			image[pixelIdx] = clampCast<OutputType>(val);
+		}
+	}
+
+	shared_ptr<Container<uint8_t>> ScanConverter::getMask()
+	{
+		return m_mask;
+	}
+
+	template<typename InputType, typename OutputType>
+	shared_ptr<Container<OutputType>> ScanConverter::convert(const shared_ptr<USImage>& inImage)
+	{
+		uint32_t numScanlines = (uint32_t)inImage->getImageProperties()->getNumScanlines();
+		vec2s scanlineLayout = inImage->getImageProperties()->getScanlineLayout();
+		uint32_t numSamples = (uint32_t)inImage->getImageProperties()->getNumSamples();
+
+		shared_ptr<const Container<InputType>> pScanlineData = inImage->getData<InputType>();
+		if (pScanlineData->isHost())
+		{
+			pScanlineData = make_shared<Container<InputType>>(LocationGpu, *pScanlineData);
+		}
+		auto pConv = make_shared<Container<OutputType>>(LocationGpu, pScanlineData->getStream(), m_imageSize.x*m_imageSize.y*m_imageSize.z);
+
+		if (m_is2D)
+		{
+			sycl::range<3> blockSize(1, 256, 1);
+			sycl::range<3> gridSize(static_cast<unsigned int>((m_imageSize.x + blockSize.x - 1) / blockSize.x), static_cast<unsigned int>((m_imageSize.y + blockSize.y - 1) / blockSize.y), 1);
+			pScanlineData->getStream()->submit([ & ](sycl::handler& cgh) {
+				auto dpct_global_range = gridSize * blockSize;
+
+				auto m_imageSize_x_ct2 = ( uint32_t )m_imageSize.x;
+				auto m_imageSize_y_ct3 = ( uint32_t )m_imageSize.y;
+
+				cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+												   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+								 [ = ](sycl::nd_item<3> item_ct1) {
+									 scanConvert2D(numScanlines, numSamples, m_imageSize_x_ct2, m_imageSize_y_ct3, m_mask->get(), m_sampleIdx->get(), m_weightX->get(), m_weightY->get(),
+												   pScanlineData->get(), pConv->get(), item_ct1);
+								 });
+			});
+			/*
+			DPCT1010:20: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+			*/
+			cudaSafeCall(0);
+		}
+		else
+		{
+			sycl::range<3> blockSize(1, 256, 1);
+			sycl::range<3> gridSize(static_cast<unsigned int>((m_imageSize.x + blockSize.x - 1) / blockSize.x), static_cast<unsigned int>((m_imageSize.y + blockSize.y - 1) / blockSize.y),
+									static_cast<unsigned int>((m_imageSize.z + blockSize.z - 1) / blockSize.z));
+			pScanlineData->getStream()->submit([ & ](sycl::handler& cgh) {
+				auto dpct_global_range = gridSize * blockSize;
+
+				auto m_imageSize_x_ct3 = ( uint32_t )m_imageSize.x;
+				auto m_imageSize_y_ct4 = ( uint32_t )m_imageSize.y;
+				auto m_imageSize_z_ct5 = ( uint32_t )m_imageSize.z;
+
+				cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+												   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+								 [ = ](sycl::nd_item<3> item_ct1) {
+									 scanConvert3D(( uint32_t )scanlineLayout.x, ( uint32_t )scanlineLayout.y, numSamples, m_imageSize_x_ct3, m_imageSize_y_ct4, m_imageSize_z_ct5, m_mask->get(),
+												   m_sampleIdx->get(), m_weightX->get(), m_weightY->get(), m_weightZ->get(), pScanlineData->get(), pConv->get(), item_ct1);
+								 });
+			});
+			/*
+			DPCT1010:21: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+			*/
+			cudaSafeCall(0);
+		}
+		return pConv;
+	}
+
+	template
+		std::shared_ptr<Container<uint8_t>> ScanConverter::convert<uint8_t, uint8_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<int16_t>> ScanConverter::convert<uint8_t, int16_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<float>> ScanConverter::convert<uint8_t, float>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<uint8_t>> ScanConverter::convert<int16_t, uint8_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<int16_t>> ScanConverter::convert<int16_t, int16_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<float>> ScanConverter::convert<int16_t, float>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<uint8_t>> ScanConverter::convert<float, uint8_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<int16_t>> ScanConverter::convert<float, int16_t>(const std::shared_ptr<USImage>& inImage);
+	template
+		std::shared_ptr<Container<float>> ScanConverter::convert<float, float>(const std::shared_ptr<USImage>& inImage);
+
+	void ScanConverter::updateInternals(const std::shared_ptr<const USImageProperties>& inImageProps)
+	{
+		logging::log_log("Scanconverter: Updating scanconversion internals");
+
+		//Check the scanline configuration for validity
+		m_is2D = inImageProps->is2D();
+
+		vec2s layout = inImageProps->getScanlineLayout();
+		double startDepth = 0;
+		double endDepth = inImageProps->getDepth();
+		double resolution = inImageProps->getImageResolution();
+		auto scanlines = inImageProps->getScanlineInfo();
+		logging::log_error_if(!scanlines, "ScanConverter: No scanlines have been attached to the USImageProperties!");
+
+		bool scanlinesGood = scanlines.operator bool();
+
+		if (scanlinesGood)
+		{
+			for (size_t scanlineIdxY = 0; scanlineIdxY < layout.y; scanlineIdxY++)
+			{
+				for (size_t scanlineIdxX = 0; scanlineIdxX < layout.x; scanlineIdxX++)
+				{
+					if (scanlineIdxX > 0)
+					{
+						vec start = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec startbefore = (*scanlines)[scanlineIdxX - 1][scanlineIdxY].getPoint(startDepth);
+						vec end = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec endbefore = (*scanlines)[scanlineIdxX - 1][scanlineIdxY].getPoint(endDepth);
+
+						//scanline start points are increasing in x
+						scanlinesGood = scanlinesGood &&
+							start.x >= startbefore.x;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  1 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanline end points are increasing in x, that means scanlines do not intersect
+						scanlinesGood = scanlinesGood &&
+							end.x >= endbefore.x;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  2 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines can not be identical
+						scanlinesGood = scanlinesGood &&
+							(start.x > startbefore.x || end.x > endbefore.x);
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  3 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines are not skew
+						scanlinesGood = scanlinesGood && abs(det(start - endbefore, startbefore - endbefore, end - endbefore)) < m_skewnessTestThreshold;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  4 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+					}
+
+					if (scanlineIdxY > 0)
+					{
+						vec start = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec startbefore = (*scanlines)[scanlineIdxX][scanlineIdxY - 1].getPoint(startDepth);
+						vec end = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec endbefore = (*scanlines)[scanlineIdxX][scanlineIdxY - 1].getPoint(endDepth);
+
+						//scanline start points are increasing in z
+						scanlinesGood = scanlinesGood &&
+							start.z >= startbefore.z;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  5 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanline end points are increasing in z, that means scanlines do not intersect
+						scanlinesGood = scanlinesGood &&
+							end.z >= endbefore.z;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  6 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines can not be identical
+						scanlinesGood = scanlinesGood &&
+							(start.z > startbefore.z || end.z > endbefore.z);
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  7 ", scanlineIdxX, ", ", scanlineIdxY);
+						}
+						//scanlines are not skew
+						scanlinesGood = scanlinesGood && abs(det(start - endbefore, startbefore - endbefore, end - endbefore)) < m_skewnessTestThreshold;
+						if (!scanlinesGood)
+						{
+							scanlinesGood = true;
+							logging::log_error(":(  8 ", scanlineIdxX, ", ", scanlineIdxY, "   det = ", det(start - endbefore, startbefore - endbefore, end - endbefore));
+						}
+					}
+				}
+			}
+		}
+
+		if (scanlinesGood)
+		{
+			//find scan bounding box
+			vec bbMin{ numeric_limits<double>::max(),  numeric_limits<double>::max(),  numeric_limits<double>::max() };
+			vec bbMax{ -numeric_limits<double>::max(), -numeric_limits<double>::max(), -numeric_limits<double>::max() };
+			for (size_t scanlineIdxY = 0; scanlineIdxY < layout.y; scanlineIdxY++)
+			{
+				for (size_t scanlineIdxX = 0; scanlineIdxX < layout.x; scanlineIdxX++)
+				{
+					vec p1 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+					vec p2 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+					bbMin = { min(bbMin.x, p1.x), min(bbMin.y, p1.y), min(bbMin.z, p1.z) };
+					bbMax = { max(bbMax.x, p1.x), max(bbMax.y, p1.y), max(bbMax.z, p1.z) };
+					bbMin = { min(bbMin.x, p2.x), min(bbMin.y, p2.y), min(bbMin.z, p2.z) };
+					bbMax = { max(bbMax.x, p2.x), max(bbMax.y, p2.y), max(bbMax.z, p2.z) };
+				}
+			}
+			m_bbMin = bbMin;
+			m_bbMax = bbMax;
+
+			//compute image size
+			m_imageSize = static_cast<vec3s>(ceil((bbMax - bbMin) / resolution)) + 1;
+			m_imageSize.x = max(m_imageSize.x, ( size_t )1);
+			m_imageSize.y = max(m_imageSize.y, ( size_t )1);
+			m_imageSize.z = max(m_imageSize.z, ( size_t )1);
+
+			// create buffers
+			size_t numelBuffers = m_imageSize.x*m_imageSize.y*m_imageSize.z;
+			/*m_mask = make_shared<Container<uint8_t>>(ContainerLocation::LocationHost, numelBuffers);
+			m_sampleIdx = make_shared<Container<IndexType>>(ContainerLocation::LocationHost, numelBuffers);
+			m_weightX = make_shared<Container<WeightType>>(ContainerLocation::LocationHost, numelBuffers);
+			m_weightY = make_shared<Container<WeightType>>(ContainerLocation::LocationHost, numelBuffers);
+			m_weightZ = make_shared<Container<WeightType>>(ContainerLocation::LocationHost, numelBuffers);*/
+			m_mask = make_shared<Container<uint8_t>>(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
+			m_sampleIdx = make_shared<Container<IndexType>>(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
+			m_weightX = make_shared<Container<WeightType>>(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
+			m_weightY = make_shared<Container<WeightType>>(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
+			m_weightZ = make_shared<Container<WeightType>>(ContainerLocation::LocationGpu, cudaStreamPerThread, numelBuffers);
+
+			//create image mask
+			/*
+			DPCT1003:22: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall(((( cudaStream_t )0x2)->memset(m_mask->get(), 0, m_mask->size() * sizeof(uint8_t), cudaStreamPerThread), 0));
+
+			if (m_is2D)
+			{
+				//2D is computed on the cpu at the moment -> copy
+				m_mask = make_shared<Container<uint8_t>>(LocationHost, *m_mask);
+				m_sampleIdx = make_shared<Container<IndexType>>(LocationHost, *m_sampleIdx);
+				m_weightX = make_shared<Container<WeightType>>(LocationHost, *m_weightX);
+				m_weightY = make_shared<Container<WeightType>>(LocationHost, *m_weightY);
+				m_weightZ = make_shared<Container<WeightType>>(LocationHost, *m_weightZ);
+
+				vec2 bb2DMin{ m_bbMin.x, m_bbMin.y };
+				assert(layout.x > 1);
+				// From now on, we assume everything is in the xy-plane
+				// -----------------------------------------
+				for (size_t scanlineIdxY = 0; scanlineIdxY < layout.y; scanlineIdxY++)
+				{
+#pragma omp parallel for schedule(dynamic, 8)
+					for (int scanlineIdxX = 0; scanlineIdxX < layout.x - 1; scanlineIdxX++)
+					{
+						vec start3 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec startN3 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(startDepth);
+						vec end3 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec endN3 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(endDepth);
+						vec2 start = { start3.x, start3.y };
+						vec2 startN = { startN3.x, startN3.y };
+						vec2 end = { end3.x, end3.y };
+						vec2 endN = { endN3.x, endN3.y };
+
+						// find bounding box of the two scanlines
+						vec2 quadMinWorld = { std::min(std::min(std::min(start.x, startN.x), end.x), endN.x), std::min(std::min(std::min(start.y, startN.y), end.y), endN.y) };
+						vec2 quadMaxWorld = { std::max(std::max(std::max(start.x, startN.x), end.x), endN.x), std::max(std::max(std::max(start.y, startN.y), end.y), endN.y) };
+
+						vec2s quadMinPixel = static_cast<vec2s>(floor((quadMinWorld - bb2DMin) / resolution));
+						vec2s quadMaxPixel = static_cast<vec2s>(ceil((quadMaxWorld - bb2DMin) / resolution));
+
+						// check the pixels in the quad bounding box and mark the inside ones
+						vec2s pixel;
+						for (pixel.x = quadMinPixel.x; pixel.x <= quadMaxPixel.x; pixel.x++)
+						{
+							for (pixel.y = quadMinPixel.y; pixel.y <= quadMaxPixel.y; pixel.y++)
+							{
+								vec2 pixelPos = static_cast<vec2>(pixel) * resolution + bb2DMin;
+								if (pointInsideTriangle(endN, end, start, pixelPos) ||
+									pointInsideTriangle(start, startN, endN, pixelPos))
+								{
+									m_mask->get()[pixel.x + pixel.y*m_imageSize.x] = 1;
+
+									vec2 params = mapToParameters2D(
+										(*scanlines)[scanlineIdxX][scanlineIdxY].position,
+										(*scanlines)[scanlineIdxX + 1][scanlineIdxY].position,
+										(*scanlines)[scanlineIdxX][scanlineIdxY].direction,
+										(*scanlines)[scanlineIdxX + 1][scanlineIdxY].direction,
+										startDepth, endDepth, { pixelPos.x, pixelPos.y, 0.0 });
+									double t = params.x;
+									double d = params.y;
+
+									IndexType  sampleIdxScanline = static_cast<IndexType>(std::floor(d / inImageProps->getSampleDistance()));
+									WeightType weightY = static_cast<WeightType>(d - (sampleIdxScanline*inImageProps->getSampleDistance()));
+									WeightType weightX = static_cast<WeightType>(t);
+
+									IndexType sampleIdx = static_cast<IndexType>(sampleIdxScanline*inImageProps->getNumScanlines() +
+										scanlineIdxX + scanlineIdxY*layout.x);
+
+									m_sampleIdx->get()[pixel.x + pixel.y*m_imageSize.x] = sampleIdx;
+									m_weightX->get()[pixel.x + pixel.y*m_imageSize.x] = weightX;
+									m_weightY->get()[pixel.x + pixel.y*m_imageSize.x] = weightY;
+								}
+							}
+						}
+					}
+				}
+
+				//2D is computed on the cpu at the moment -> copy
+				m_mask = make_shared<Container<uint8_t>>(LocationGpu, *m_mask);
+				m_sampleIdx = make_shared<Container<IndexType>>(LocationGpu, *m_sampleIdx);
+				m_weightX = make_shared<Container<WeightType>>(LocationGpu, *m_weightX);
+				m_weightY = make_shared<Container<WeightType>>(LocationGpu, *m_weightY);
+				m_weightZ = make_shared<Container<WeightType>>(LocationGpu, *m_weightZ);
+			}
+			else {
+				// 3D case
+				for (int scanlineIdxY = 0; scanlineIdxY < layout.y - 1; scanlineIdxY++)
+				{
+					//#pragma omp parallel for schedule(dynamic, 1)
+					for (int scanlineIdxX = 0; scanlineIdxX < layout.x - 1; scanlineIdxX++)
+					{
+						vec s1 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(startDepth);
+						vec e1 = (*scanlines)[scanlineIdxX][scanlineIdxY].getPoint(endDepth);
+						vec s2 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(startDepth);
+						vec e2 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY].getPoint(endDepth);
+						vec s3 = (*scanlines)[scanlineIdxX][scanlineIdxY + 1].getPoint(startDepth);
+						vec e3 = (*scanlines)[scanlineIdxX][scanlineIdxY + 1].getPoint(endDepth);
+						vec s4 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY + 1].getPoint(startDepth);
+						vec e4 = (*scanlines)[scanlineIdxX + 1][scanlineIdxY + 1].getPoint(endDepth);
+
+						// find bounding box of the four scanlines
+						vec tetMinWorld = min(min(min(s1, s2), min(s3, s4)),
+							min(min(e1, e2), min(e3, e4)));
+						vec tetMaxWorld = max(max(max(s1, s2), max(s3, s4)),
+							max(max(e1, e2), max(e3, e4)));
+
+						vec3s tetMinVoxel = static_cast<vec3s>(floor((tetMinWorld - bbMin) / resolution));
+						vec3s tetMaxVoxel = static_cast<vec3s>(ceil((tetMaxWorld - bbMin) / resolution));
+
+						vec3s numVoxels = tetMaxVoxel - tetMinVoxel + 1;
+						sycl::range<3> blockSize(16, 4, 4);
+						sycl::range<3> gridSize(static_cast<unsigned int>((numVoxels.x + blockSize.x - 1) / blockSize.x), static_cast<unsigned int>((numVoxels.y + blockSize.y - 1) / blockSize.y),
+												static_cast<unsigned int>((numVoxels.z + blockSize.z - 1) / blockSize.z));
+
+						typedef float Tf;
+						typedef int Ti;
+
+						cudaStreamPerThread->submit([ & ](sycl::handler& cgh) {
+							auto dpct_global_range = gridSize * blockSize;
+
+							cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(dpct_global_range.get(2), dpct_global_range.get(1), dpct_global_range.get(0)),
+															   sycl::range<3>(blockSize.get(2), blockSize.get(1), blockSize.get(0))),
+											 [ = ](sycl::nd_item<3> item_ct1) {
+												 computeParameterBB3D<Tf, Ti>(
+													 static_cast<Tf>(inImageProps->getSampleDistance()), static_cast<vec2T<Ti>>(layout), scanlineIdxX, scanlineIdxY, static_cast<vec3T<Tf>>(s1),
+													 static_cast<vec3T<Tf>>(e1), static_cast<vec3T<Tf>>(s2), static_cast<vec3T<Tf>>(e2), static_cast<vec3T<Tf>>(s3), static_cast<vec3T<Tf>>(e3),
+													 static_cast<vec3T<Tf>>(s4), static_cast<vec3T<Tf>>(e4), static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY ].position),
+													 static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY ].direction),
+													 static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY ].position),
+													 static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY ].direction),
+													 static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY + 1 ].position),
+													 static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX ][ scanlineIdxY + 1 ].direction),
+													 static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY + 1 ].position),
+													 static_cast<vec3T<Tf>>((*scanlines)[ scanlineIdxX + 1 ][ scanlineIdxY + 1 ].direction), static_cast<Tf>(startDepth), static_cast<Tf>(endDepth),
+													 static_cast<vec3T<Ti>>(m_imageSize), static_cast<vec3T<Tf>>(bbMin), static_cast<vec3T<Ti>>(tetMinVoxel), static_cast<vec3T<Ti>>(tetMaxVoxel),
+													 static_cast<Tf>(resolution), m_mask->get(), m_sampleIdx->get(), m_weightX->get(), m_weightY->get(), m_weightZ->get(), item_ct1);
+											 });
+						});
+						/*
+						DPCT1010:23: SYCL uses exceptions to report errors and does not use the error codes. The call was replaced with 0. You need to rewrite this code.
+						*/
+						cudaSafeCall(0);
+					}
+				}
+			}
+			/*
+			DPCT1003:24: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((cudaStreamPerThread->wait(), 0));
+		}
+		else
+		{
+			logging::log_error("ScanConverter: The scanlines are not in the required configuration.");
+		}
+	}
+
+	double ScanConverter::barycentricCoordinate2D(const vec2 & a, const vec2 & b, const vec2 & c)
+	{
+		return (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);
+	}
+
+	bool ScanConverter::pointInsideTriangle(const vec2 & a, const vec2 & b, const vec2 & c, const vec2 & p)
+	{
+		double w0 = barycentricCoordinate2D(b, c, p);
+		double w1 = barycentricCoordinate2D(c, a, p);
+		double w2 = barycentricCoordinate2D(a, b, p);
+
+		// Test if p is on or inside all edges
+		return (w0 >= 0 && w1 >= 0 && w2 >= 0);
+	}
+
+	vec ScanConverter::pointLineConnection(const vec & a, const vec & da, const vec & x)
+	{
+		vec conn = x - a;
+		vec r = conn - dot(da, conn) *da;
+		return r;
+	}
+
+	vec2 ScanConverter::mapToParameters2D(const vec & a, const vec & b, const vec & da, const vec & db, double startDepth, double endDepth, const vec & x)
+	{
+		//find t via binary search
+		double lowT = 0;
+		double highT = 1;
+		vec lowConn = pointLineConnection(a, da, x);
+		vec highConn = pointLineConnection(b, db, x);
+		double lowDist = norm(lowConn);
+		double highDist = norm(highConn);
+
+		if (highConn.x == 0 && highConn.y == 0 && highConn.z == 0)
+		{
+			double t = highT;
+			double d = norm(x - b);
+			return{ t, d };
+		}
+		else if (lowConn.x == 0 && lowConn.y == 0 && lowConn.z == 0)
+		{
+			double t = lowT;
+			double d = norm(x - a);
+			return{ t, d };
+		}
+
+		assert(dot(lowConn, highConn) < 0);
+
+		double dist = 1e10;
+		double t = (highT - lowT) / 2 + lowT;
+		vec lineBase;
+		for (size_t numIter = 0; numIter < m_mappingMaxIterations && dist > m_mappingDistanceThreshold; numIter++)
+		{
+			t = (1 - highDist / (highDist + lowDist))*highT + (1 - lowDist / (highDist + lowDist))*lowT;
+
+			lineBase = (1 - t)*a + t*b;
+			vec lineDir = slerp3(da, db, t);
+
+			vec conn = pointLineConnection(lineBase, lineDir, x);
+			dist = norm(conn);
+
+			if (dot(lowConn, conn) < 0)
+			{
+				highT = t;
+				highConn = conn;
+				highDist = dist;
+			}
+			else
+			{
+				lowT = t;
+				lowConn = conn;
+				lowDist = dist;
+			}
+		}
+		double d = norm(x - lineBase);
+
+		return{ t, d };
+	}
+}
diff --git a/src/SupraLib/Beamformer/WindowFunction.h b/src/SupraLib/Beamformer/WindowFunction.h
index 21c559b..61d3727 100644
--- a/src/SupraLib/Beamformer/WindowFunction.h
+++ b/src/SupraLib/Beamformer/WindowFunction.h
@@ -12,10 +12,12 @@
 #ifndef __WINDOWFUNCTION_H__
 #define __WINDOWFUNCTION_H__
 
-#ifndef __CUDACC__
+#ifndef CL_SYCL_LANGUAGE_VERSION
 #include <algorithm>
 #endif
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include <memory>
 #include <Container.h>
 #include <utilities/utility.h>
@@ -23,7 +25,7 @@
 
 namespace supra
 {
-#ifndef __CUDACC__
+#ifndef CL_SYCL_LANGUAGE_VERSION
 	using std::max;
 	using std::min;
 #else
@@ -55,25 +57,23 @@ namespace supra
 
 		//Returns the weight of chosen window a the relative index 
 		// relativeIndex has to be normalized to [-1, 1] (inclusive)
-		__device__ inline ElementType get(float relativeIndex) const
+		inline ElementType get(float relativeIndex) const
 		{
-			float relativeIndexClamped = min(max(relativeIndex, -1.0f), 1.0f);
-			uint32_t absoluteIndex =
-				static_cast<uint32_t>(roundf(m_scale*(relativeIndexClamped + 1.0f)));
+			float	 relativeIndexClamped = sycl::min(sycl::max(relativeIndex, -1.0f), 1.0f);
+			uint32_t absoluteIndex = static_cast<uint32_t>(sycl::round(m_scale * (relativeIndexClamped + 1.0f)));
 			return m_data[absoluteIndex];
 		}
 
 		//Returns the weight of chosen window a the relative index
 		// relativeIndex has to be normalized to [-1, 1] (inclusive)
-		__device__ inline ElementType getShared(const ElementType * __restrict__ sharedData, float relativeIndex) const
+		inline ElementType getShared(const ElementType * __restrict__ sharedData, float relativeIndex) const
 		{
-			float relativeIndexClamped = min(max(relativeIndex, -1.0f), 1.0f);
-			uint32_t absoluteIndex =
-				static_cast<uint32_t>(roundf(m_scale*(relativeIndexClamped + 1.0f)));
+			float	 relativeIndexClamped = sycl::min(sycl::max(relativeIndex, -1.0f), 1.0f);
+			uint32_t absoluteIndex = static_cast<uint32_t>(sycl::round(m_scale * (relativeIndexClamped + 1.0f)));
 			return sharedData[absoluteIndex];
 		}
 
-		__device__ inline ElementType getDirect(uint32_t idx) const
+		inline ElementType getDirect(uint32_t idx) const
 		{
 			ElementType ret = 0;
 			if (idx < m_numEntriesPerFunction)
@@ -83,14 +83,14 @@ namespace supra
 			return ret;
 		}
 
-		__device__ inline uint32_t numElements() const
+		inline uint32_t numElements() const
 		{
 			return m_numEntriesPerFunction;
 		}
 
 	private:
 		friend WindowFunction;
-		__host__ WindowFunctionGpu(size_t numEntriesPerFunction, const ElementType* data)
+		WindowFunctionGpu(size_t numEntriesPerFunction, const ElementType* data)
 			: m_numEntriesPerFunction(static_cast<uint32_t>(numEntriesPerFunction))
 			, m_data(data)
 			, m_scale(static_cast<float>(numEntriesPerFunction - 1)*0.5f) {};
@@ -119,7 +119,7 @@ namespace supra
 
 		// relativeIndex has to be normalized to [-1, 1] (inclusive)
 		template <typename T>
-		static __device__ __host__ inline T windowFunction(const WindowType& type, const T& relativeIndex, const T& windowParameter)
+		static inline T windowFunction(const WindowType& type, const T& relativeIndex, const T& windowParameter)
 		{
 			switch (type)
 			{
@@ -130,8 +130,7 @@ namespace supra
 			case WindowHamming:
 				return (1 - windowParameter)*(0.54f - 0.46f*std::cos(2*static_cast<T>(M_PI)*((relativeIndex + 1) *0.5f))) + windowParameter;
 			case WindowGauss:
-				return static_cast<T>(
-					1.0 / (windowParameter * sqrt(2.0 * M_PI)) * exp((-1.0 / 2.0) * (relativeIndex / windowParameter)*(relativeIndex / windowParameter)));
+				return static_cast<T>(1.0 / (windowParameter * sycl::sqrt(2.0 * M_PI)) * exp((-1.0 / 2.0) * (relativeIndex / windowParameter) * (relativeIndex / windowParameter)));
 			default:
 				return 0;
 			}
diff --git a/src/SupraLib/Container.h b/src/SupraLib/Container.h
index c6bb6bd..c405d7a 100644
--- a/src/SupraLib/Container.h
+++ b/src/SupraLib/Container.h
@@ -12,6 +12,8 @@
 #ifndef __CONTAINER_H__
 #define __CONTAINER_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include "ContainerFactory.h"
 #ifdef HAVE_CUDA
 #include "utilities/cudaUtility.h"
@@ -22,6 +24,7 @@
 #include <memory>
 #include <vector>
 #include <cassert>
+#include <future>
 
 namespace supra
 {
@@ -59,12 +62,18 @@ namespace supra
 #ifdef HAVE_CUDA
 			if(location == LocationGpu)
 			{
-				cudaSafeCall(cudaMemcpyAsync(this->get(), data.data(), this->size() * sizeof(T), cudaMemcpyDefault, associatedStream));
+				/*
+				DPCT1003:10: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((associatedStream->memcpy(this->get(), data.data(), this->size() * sizeof(T)), 0));
 				createAndRecordEvent();
 			}
 			else if(location == LocationBoth)
 			{
-				cudaSafeCall(cudaMemcpyAsync(this->get(), data.data(), this->size() * sizeof(T), cudaMemcpyDefault, associatedStream));
+				/*
+				DPCT1003:11: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((associatedStream->memcpy(this->get(), data.data(), this->size() * sizeof(T)), 0));
 				createAndRecordEvent();
 			}
 			else
@@ -83,7 +92,10 @@ namespace supra
 			:Container(location, associatedStream, dataEnd - dataBegin)
 		{
 #ifdef HAVE_CUDA
-			cudaSafeCall(cudaMemcpyAsync(this->get(), dataBegin, this->size() * sizeof(T), cudaMemcpyDefault, associatedStream));
+			/*
+			DPCT1003:12: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((associatedStream->memcpy(this->get(), dataBegin, this->size() * sizeof(T)), 0));
 			createAndRecordEvent();
 			if (waitFinished)
 			{
@@ -103,22 +115,34 @@ namespace supra
 #ifdef HAVE_CUDA
 			else if (source.m_location == LocationHost && location == LocationGpu)
 			{
-				cudaSafeCall(cudaMemcpyAsync(this->get(), source.get(), source.size() * sizeof(T), cudaMemcpyDefault, source.getStream()));
+				/*
+				DPCT1003:13: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T))), 0));
 				createAndRecordEvent();
 			}
 			else if (source.m_location == LocationGpu && location == LocationHost)
 			{
-				cudaSafeCall(cudaMemcpyAsync(this->get(), source.get(), source.size() * sizeof(T), cudaMemcpyDefault, source.getStream()));
+				/*
+				DPCT1003:14: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T))), 0));
 				createAndRecordEvent();
 			}
 			else if (source.m_location == LocationGpu && location == LocationGpu)
 			{
-				cudaSafeCall(cudaMemcpyAsync(this->get(), source.get(), source.size() * sizeof(T), cudaMemcpyDefault, source.getStream()));
+				/*
+				DPCT1003:15: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T))), 0));
 				createAndRecordEvent();
 			}
 			else
 			{
-				cudaSafeCall(cudaMemcpyAsync(this->get(), source.get(), source.size() * sizeof(T), cudaMemcpyDefault, source.getStream()));
+				/*
+				DPCT1003:16: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((source.getStream()->memcpy(this->get(), source.get(), source.size() * sizeof(T))), 0));
 				createAndRecordEvent();
 			}
 			if (waitFinished)
@@ -132,15 +156,18 @@ namespace supra
 		~Container()
 		{
 #ifdef HAVE_CUDA
-			auto ret = cudaStreamQuery(m_associatedStream);
-			if (ret != cudaSuccess && ret != cudaErrorNotReady && ret != cudaErrorCudartUnloading)
+			/*
+			DPCT1027:3: The call to cudaStreamQuery was replaced with 0, because DPC++ currently does not support query operations on queues.
+			*/
+			auto ret = 0;
+			if (ret != 0 && ret != 600 && ret != 4)
 			{
 				cudaSafeCall(ret);
 			}
 			// If the driver is currently unloading, we cannot free the memory in any way. Exit will clean up.
-			else if(ret != cudaErrorCudartUnloading)
+			else if (ret != 4)
 			{
-				if (ret == cudaSuccess)
+				if (ret == 0)
 				{
 					ContainerFactoryContainerInterface::returnMemory(reinterpret_cast<uint8_t*>(m_buffer), m_numel * sizeof(T), m_location);
 				}
@@ -149,7 +176,7 @@ namespace supra
 					auto buffer = m_buffer;
 					auto numel = m_numel;
 					auto location = m_location;
-					addCallbackStream([buffer, numel, location](cudaStream_t s, cudaError_t e) -> void {
+					addCallbackStream([ buffer, numel, location ](sycl::queue* s, int e) -> void {
 						ContainerFactoryContainerInterface::returnMemory(reinterpret_cast<uint8_t*>(buffer), numel * sizeof(T), location);
 					});
 				}
@@ -173,12 +200,18 @@ namespace supra
 			}
 			else if(m_location == LocationGpu)
 			{
-				cudaSafeCall(cudaMemcpyAsync(ret, this->get(), this->size() * sizeof(T), cudaMemcpyDeviceToHost, getStream()));
+				/*
+				DPCT1003:17: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((getStream()->memcpy(ret, this->get(), this->size() * sizeof(T))), 0));
 				cudaSafeCall(cudaStreamSynchronize(getStream()));				
 			}
 			else 
 			{
-				cudaSafeCall(cudaMemcpy(ret, this->get(), this->size() * sizeof(T), cudaMemcpyDefault));
+				/*
+				DPCT1003:18: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((dpct::get_default_queue().memcpy(ret, this->get(), this->size() * sizeof(T)).wait(), 0));
 			}
 			return ret;
 #else
@@ -190,7 +223,10 @@ namespace supra
 		{
 #ifdef HAVE_CUDA
 			assert(maxSize >= this->size());
-			cudaSafeCall(cudaMemcpy(dst, this->get(), this->size() * sizeof(T), cudaMemcpyDefault));
+			/*
+			DPCT1003:19: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((dpct::get_default_queue().memcpy(dst, this->get(), this->size() * sizeof(T)).wait(), 0));
 #endif
 		}
 
@@ -199,8 +235,14 @@ namespace supra
 #ifdef HAVE_CUDA
 			if (m_creationEvent)
 			{
-				cudaSafeCall(cudaEventSynchronize(m_creationEvent));
-				cudaSafeCall(cudaEventDestroy(m_creationEvent));
+				/*
+				DPCT1003:4: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+				*/
+				cudaSafeCall((m_creationEvent.wait_and_throw(), 0));
+				/*
+				DPCT1027:5: The call to cudaEventDestroy was replaced with 0, because this call is redundant in DPC++.
+				*/
+				cudaSafeCall(0);
 				m_creationEvent = nullptr;
 			}
 #endif
@@ -226,26 +268,54 @@ namespace supra
 			if (!m_creationEvent)
 			{
 				//cudaSafeCall(cudaEventCreateWithFlags(&m_creationEvent, cudaEventBlockingSync | cudaEventDisableTiming));
-				cudaSafeCall(cudaEventCreateWithFlags(&m_creationEvent, cudaEventDisableTiming));
+				/*
+				DPCT1027:6: The call to cudaEventCreateWithFlags was replaced with 0, because this call is redundant in DPC++.
+				*/
+				cudaSafeCall(0);
 			}
-			cudaSafeCall(cudaEventRecord(m_creationEvent, m_associatedStream));
+			/*
+			DPCT1012:7: Detected kernel execution time measurement pattern and generated an initial code for time measurements in SYCL. You can change the way time is measured depending on your goals.
+			*/
+			/*
+			DPCT1024:8: The original code returned the error code that was further consumed by the program logic. This original code was replaced with 0. You may need to rewrite the program logic
+			consuming the error code.
+			*/
+			/*
+			DPCT1024:26: The original code returned the error code that was further consumed by the program logic. This original code was replaced with 0. You may need to rewrite the program logic
+			consuming the error code.
+			*/
+			/*
+			DPCT1024:29: The original code returned the error code that was further consumed by the program logic. This original code was replaced with 0. You may need to rewrite the program logic
+			consuming the error code.
+			*/
+			/*
+			DPCT1024:33: The original code returned the error code that was further consumed by the program logic. This original code was replaced with 0. You may need to rewrite the program logic
+			consuming the error code.
+			*/
+			m_creationEvent_ct1 = clock();
+			cudaSafeCall(0);
 #endif
 		}
 
 #ifdef HAVE_CUDA
-		void addCallbackStream(std::function<void(cudaStream_t, cudaError_t)> func)
+		void addCallbackStream(std::function<void(sycl::queue, *int)> func)
 		{
-			auto funcPointer = new std::function<void(cudaStream_t, cudaError_t)>(func);
-			cudaSafeCall(cudaStreamAddCallback(m_associatedStream, &(Container<T>::cudaDeleteCallback), funcPointer, 0));
+			auto funcPointer = new std::function<void(sycl::queue, *int)>(func);
+			/*
+			DPCT1003:9: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((std::async([ & ]() {
+							  m_associatedStream->wait();
+							  &(Container<T>::cudaDeleteCallback)(m_associatedStream, 0, funcPointer);
+						  }),
+						  0));
 		}
 #endif
 
 #ifdef HAVE_CUDA
-		static void CUDART_CB cudaDeleteCallback(cudaStream_t stream, cudaError_t status, void* userData)
+		static void CUDART_CB cudaDeleteCallback(sycl::queue* stream, int status, void* userData)
 		{
-			std::unique_ptr<std::function<void(cudaStream_t, cudaError_t)> > func =
-				std::unique_ptr<std::function<void(cudaStream_t, cudaError_t)> >(
-					reinterpret_cast<std::function<void(cudaStream_t, cudaError_t)>*>(userData));
+			std::unique_ptr<std::function<void(sycl::queue, *int)>> func = std::unique_ptr<std::function<void(sycl::queue, *int)>>(reinterpret_cast<std::function<void(sycl::queue, *int)>*>(userData));
 			(*func)(stream, status);
 		}
 #endif
@@ -257,7 +327,8 @@ namespace supra
 		T* m_buffer;
 
 #ifdef HAVE_CUDA
-		cudaEvent_t m_creationEvent;
+		sycl::event m_creationEvent;
+		clock_t		m_creationEvent_ct1;
 #endif
 	};
 }
diff --git a/src/SupraLib/ContainerFactory.cpp.dp.cpp b/src/SupraLib/ContainerFactory.cpp.dp.cpp
new file mode 100644
index 0000000..18f428d
--- /dev/null
+++ b/src/SupraLib/ContainerFactory.cpp.dp.cpp
@@ -0,0 +1,290 @@
+// ================================================================================================
+// 
+// If not explicitly stated: Copyright (C) 2017, all rights reserved,
+//      Rüdiger Göbl 
+//		Email r.goebl@tum.de
+//      Chair for Computer Aided Medical Procedures
+//      Technische Universität München
+//      Boltzmannstr. 3, 85748 Garching b. München, Germany
+// 
+// ================================================================================================
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "ContainerFactory.h"
+
+#include <utilities/Logging.h>
+#include <utilities/utility.h>
+
+#include <sstream>
+#include <cassert>
+using namespace std;
+
+namespace supra
+{
+	ContainerFactory::ContainerStreamType ContainerFactory::getNextStream()
+	{
+		std::lock_guard<std::mutex> streamLock(sm_streamMutex);
+
+		if (sm_streams.size() == 0)
+		{
+			initStreams();
+		}
+
+		size_t streamIndex = sm_streamIndex;
+		sm_streamIndex = (sm_streamIndex + 1) % sm_numberStreams;
+		return sm_streams[streamIndex];
+	}
+	uint8_t* ContainerFactory::acquireMemory(size_t numBytes, ContainerLocation location)
+	{
+		assert(location < LocationINVALID);
+		
+		// Check whether the queue for this location and size has a buffer left
+		uint8_t* buffer = nullptr;
+		{
+			// by directly accessing the desired length in the map sm_bufferMaps[location],
+			// the map entry is created if it does not already exist. That means the map is
+			// modified here
+			tbb::concurrent_queue<std::pair<uint8_t*, double> >* queuePointer =
+				&(sm_bufferMaps[location][numBytes]);
+
+			std::pair<uint8_t*, double> queueEntry;
+			if (queuePointer->try_pop(queueEntry))
+			{
+				// If yes, just return this already allocated buffer
+				buffer = queueEntry.first;
+			}
+		}
+
+		// If the queue did not contain a buffer, allocate a new one
+		if (!buffer)
+		{
+			// Check whether there is enough free space for the requested buffer. 
+			size_t memoryFree;
+#ifdef HAVE_CUDA
+			size_t memoryTotal;
+			if (location == LocationGpu || location == LocationBoth)
+			{
+				cudaSafeCall(cudaMemGetInfo(&memoryFree, &memoryTotal));
+				memoryFree = static_cast<size_t>(std::max(static_cast<double>(memoryFree) - (static_cast<double>(memoryTotal) * 0.02), 0.0));
+			}
+			else
+#endif
+			{
+				// For the host memory we just rely on the 
+				memoryFree = numBytes;
+			}
+
+			// If not, relase enough unused buffers, starting with the ones that have been returned the longest time ago.
+			if (memoryFree < numBytes)
+			{
+				freeBuffers(numBytes, location);
+			}
+
+			// additionaly, release memory that has been returned over XX (e.g. 30) seconds ago
+			freeOldBuffers();
+
+			// Now that we have made the required memory available, we can allocate the buffer
+			buffer = allocateMemory(numBytes, location);
+		}
+
+		return buffer;
+	}
+
+	void ContainerFactory::returnMemory(uint8_t* pointer, size_t numBytes, ContainerLocation location)
+	{
+		assert(location < LocationINVALID);
+
+		// do not free here, just put it back to the queues with the time it was returned at
+		double returnTime = getCurrentTime();
+
+		// Put buffer back to queue
+		{
+			tbb::concurrent_queue<std::pair<uint8_t*, double> >* queuePointer =
+				&(sm_bufferMaps[location][numBytes]);
+
+			queuePointer->push(std::make_pair(pointer, returnTime));
+		}
+	}
+	void ContainerFactory::initStreams()
+	{
+		logging::log_log("ContainerFactory: Initializing ", sm_numberStreams, " streams.");
+		sm_streamIndex = 0;
+#ifdef HAVE_CUDA
+		sm_streams.resize(sm_numberStreams);
+		for (size_t k = 0; k < sm_numberStreams; k++)
+		{
+			/*
+			DPCT1003:37: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			/*
+			DPCT1025:38: The SYCL queue is created ignoring the flag/priority options.
+			*/
+			cudaSafeCall(((sm_streams[ k ]) = dpct::get_current_device().create_queue(), 0));
+		}
+#else
+		sm_streams.resize(sm_numberStreams, 0);
+#endif
+	}
+
+	uint8_t * ContainerFactory::allocateMemory(size_t numBytes, ContainerLocation location)
+	{
+		dpct::device_ext& dev_ct1 = dpct::get_current_device();
+		sycl::queue&	  q_ct1 = dev_ct1.default_queue();
+		uint8_t* buffer = nullptr;
+		switch (location)
+		{
+		case LocationGpu:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:39: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((buffer = ( uint8_t* )sycl::malloc_device(numBytes, q_ct1), 0));
+#endif
+			break;
+		case LocationBoth:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:40: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((buffer = ( uint8_t* )sycl::malloc_shared(numBytes, q_ct1), 0));
+#endif
+			break;
+		case LocationHost:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:41: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			cudaSafeCall((buffer = ( uint8_t* )sycl::malloc_host(numBytes, q_ct1), 0));
+#else
+			buffer = new uint8_t[numBytes];
+#endif
+			break;
+		default:
+			throw std::runtime_error("invalid argument: Container: Unknown location given");
+		}
+		if (!buffer)
+		{
+			std::stringstream s;
+			s << "bad alloc: Container: Error allocating buffer of size " << numBytes << " in "
+				<< (location == LocationHost ? "LocationHost" : (location == LocationGpu ? "LocationGpu" : "LocationBoth"));
+			throw std::runtime_error(s.str());
+		}
+
+		return buffer;
+	}
+
+	void ContainerFactory::freeBuffers(size_t numBytesMin, ContainerLocation location)
+	{
+		size_t numBytesFreed = 0;
+		size_t numBuffersFreed;
+		do 
+		{
+			numBuffersFreed = 0;
+			// by traversing the map sm_bufferMaps[location] we never create new entries, but only modifiy those already present.
+			for (auto mapIterator = sm_bufferMaps[location].begin(); mapIterator != sm_bufferMaps[location].end(); mapIterator++)
+			{
+				size_t numBytesBuffer = mapIterator->first;
+				std::pair<uint8_t*, double> queueEntry;
+				if(mapIterator->second.try_pop(queueEntry))
+				{
+					// If there is an element in this queue, remove it and free the memory
+					freeMemory(queueEntry.first, numBytesBuffer, location);
+					numBytesFreed += numBytesBuffer;
+					numBuffersFreed++;
+				}
+			}
+		} while (numBytesFreed < numBytesMin && numBuffersFreed > 0);
+	}
+
+	void ContainerFactory::freeOldBuffers()
+	{
+		double currentTime = getCurrentTime();
+		double deleteTime = currentTime - sm_deallocationTimeout;
+		for (ContainerLocation location = LocationHost; location < LocationINVALID; location = static_cast<ContainerLocation>(location + 1))
+		{
+			for (auto mapIterator = sm_bufferMaps[location].begin(); mapIterator != sm_bufferMaps[location].end(); mapIterator++)
+			{
+				size_t numBytesBuffer = mapIterator->first;
+
+				double lastTime = 0.0;
+				while(!mapIterator->second.empty() && lastTime < deleteTime)
+				{
+					// If there is an element in this queue, remove it and free the memory
+					std::pair<uint8_t*, double> bufferPair;
+					if (mapIterator->second.try_pop(bufferPair))
+					{
+						lastTime = bufferPair.second;
+						if (lastTime < deleteTime)
+						{
+							freeMemory(bufferPair.first, numBytesBuffer, location);
+						}
+						else
+						{
+							// oops, we should not have taken that element from the queue. Let's just put it back.
+							// Yes, it will be in the wrong temporal order, but that will be solved in a while on its own
+							mapIterator->second.push(bufferPair);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	void ContainerFactory::garbageCollectionThreadFunction()
+	{
+		sm_garbageCollectionThread.detach();
+		while (true)
+		{
+			ContainerFactory::freeOldBuffers();
+			std::this_thread::sleep_for(std::chrono::duration<double>(sm_deallocationTimeout));
+		}
+	}
+
+	void ContainerFactory::freeMemory(uint8_t * pointer, size_t numBytes, ContainerLocation location)
+	{
+		dpct::device_ext& dev_ct1 = dpct::get_current_device();
+		sycl::queue&	  q_ct1 = dev_ct1.default_queue();
+		switch (location)
+		{
+		case LocationGpu:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:42: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			(sycl::free(pointer, q_ct1), 0);
+#endif
+			break;
+		case LocationBoth:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:43: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			(sycl::free(pointer, q_ct1), 0);
+#endif
+			break;
+		case LocationHost:
+#ifdef HAVE_CUDA
+			/*
+			DPCT1003:44: Migrated API does not return error code. (*, 0) is inserted. You may need to rewrite this code.
+			*/
+			(sycl::free(pointer, q_ct1), 0);
+#else
+			delete[] pointer;
+#endif
+			break;
+		default:
+			break;
+		}
+	}
+
+	std::vector<ContainerFactory::ContainerStreamType> ContainerFactory::sm_streams = {};
+	size_t ContainerFactory::sm_streamIndex = 0;
+	std::mutex ContainerFactory::sm_streamMutex;
+
+	constexpr double ContainerFactory::sm_deallocationTimeout;
+
+	std::array<tbb::concurrent_unordered_map<size_t, tbb::concurrent_queue<std::pair<uint8_t*, double> > >, LocationINVALID> ContainerFactory::sm_bufferMaps;
+
+	std::thread ContainerFactory::sm_garbageCollectionThread(&ContainerFactory::garbageCollectionThreadFunction);
+}
diff --git a/src/SupraLib/ContainerFactory.h b/src/SupraLib/ContainerFactory.h
index 855558a..e39c914 100644
--- a/src/SupraLib/ContainerFactory.h
+++ b/src/SupraLib/ContainerFactory.h
@@ -13,6 +13,8 @@
 #define __CONTAINERFACTORY_H__
 
 #ifdef HAVE_CUDA
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include "utilities/cudaUtility.h"
 #endif
 
@@ -36,7 +38,7 @@ namespace supra
 	{
 	public:
 #ifdef HAVE_CUDA
-		typedef cudaStream_t ContainerStreamType;
+		typedef sycl::queue* ContainerStreamType;
 #else
 		typedef int ContainerStreamType;
 #endif
diff --git a/src/SupraLib/RecordObject.h b/src/SupraLib/RecordObject.h
index 3f1519e..7c4ad1f 100644
--- a/src/SupraLib/RecordObject.h
+++ b/src/SupraLib/RecordObject.h
@@ -1,7 +1,9 @@
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 // ================================================================================================
-// 
+//
 // If not explicitly stated: Copyright (C) 2011-2016, all rights reserved,
-//      Christoph Hennersperger 
+//      Christoph Hennersperger
 //		EmaiL christoph.hennersperger@tum.de
 //      Chair for Computer Aided Medical Procedures
 //      Technische Universität München
diff --git a/src/SupraLib/USImageProperties.h b/src/SupraLib/USImageProperties.h
index f20a021..26b2f87 100644
--- a/src/SupraLib/USImageProperties.h
+++ b/src/SupraLib/USImageProperties.h
@@ -27,6 +27,8 @@
 #ifndef __USIMAGEPROPERTIES_H__
 #define __USIMAGEPROPERTIES_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include <memory>
 #include <vector>
 #include <map>
diff --git a/src/SupraLib/utilities/DataType.h b/src/SupraLib/utilities/DataType.h
index 005fb51..6a97bba 100644
--- a/src/SupraLib/utilities/DataType.h
+++ b/src/SupraLib/utilities/DataType.h
@@ -12,12 +12,13 @@
 #ifndef __DATATYPE_H__
 #define __DATATYPE_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include <stdint.h>
 #include <string>
 #include "utilities/utility.h"
 
 #ifdef HAVE_CUDA
-#include <cuda_fp16.h>
 #endif
 
 namespace supra
@@ -69,8 +70,7 @@ namespace supra
 	template <>
 	DataType DataTypeGet<uint64_t>();
 #ifdef HAVE_CUDA
-	template<>
-	DataType DataTypeGet<__half>();
+	template <> DataType DataTypeGet<sycl::half>();
 #endif
 	template <>
 	DataType DataTypeGet<float>();
diff --git a/src/SupraLib/utilities/FirFilterFactory.h b/src/SupraLib/utilities/FirFilterFactory.h
index 5b68392..3ebfe74 100644
--- a/src/SupraLib/utilities/FirFilterFactory.h
+++ b/src/SupraLib/utilities/FirFilterFactory.h
@@ -27,9 +27,12 @@
 #ifndef __FIRFILTERFACTORY_H__
 #define __FIRFILTERFACTORY_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include <memory>
 #include <functional>
 #include "Container.h"
+#include <cmath>
 
 namespace supra
 {
@@ -133,9 +136,7 @@ namespace supra
 						return static_cast<ElementType>(2.0 * omegaBandwidth / M_PI);
 					}
 					else {
-						return static_cast<ElementType>(
-							2.0 * cos(omega * n - halfWidth) *
-							omegaBandwidth / M_PI * sin(omegaBandwidth * (n - halfWidth)) / (omegaBandwidth * (n - halfWidth)));
+						return static_cast<ElementType>(2.0 * cos(omega * n - halfWidth) * omegaBandwidth / M_PI * sin(omegaBandwidth * (n - halfWidth)) / (omegaBandwidth * (n - halfWidth)));
 					}
 				};
 				break;
@@ -172,16 +173,16 @@ namespace supra
 			switch (window)
 			{
 			case FilterWindowHann:
-				windowFunction = [maxN](int n) -> ElementType { return static_cast<ElementType>(
-					0.50 - 0.50*cos(2 * M_PI * n / maxN)); };
+				windowFunction = [maxN](int n) -> ElementType {
+					return static_cast<ElementType>(0.50 - 0.50 * cos(2 * M_PI * n / maxN)); };
 				break;
 			case FilterWindowHamming:
-				windowFunction = [maxN](int n) -> ElementType { return static_cast<ElementType>(
-					0.54 - 0.46*cos(2 * M_PI * n / maxN)); };
+				windowFunction = [maxN](int n) -> ElementType {
+					return static_cast<ElementType>(0.54 - 0.46 * cos(2 * M_PI * n / maxN)); };
 				break;
 			case FilterWindowKaiser:
 				windowFunction = [maxN, beta](int n) -> ElementType {
-					double argument = beta * sqrt(1.0 - pow(2 * ((ElementType)n - maxN / 2) / maxN, 2.0));
+					double argument = beta * sqrt(1.0 - sycl::pow(( double )(2 * (( ElementType )n - maxN / 2) / maxN), 2.0));
 					return static_cast<ElementType>(bessel0_1stKind(argument) / bessel0_1stKind(beta)); };
 				break;
 			case FilterWindowRectangular:
@@ -205,10 +206,10 @@ namespace supra
 
 			for (int k = 0; k < filter->size(); k++)
 			{
-				gainR += filter->get()[k] * cos(omega * (ElementType)k);
-				gainI += filter->get()[k] * sin(omega * (ElementType)k);
+				gainR += filter->get()[ k ] * cos(omega * ( ElementType )k);
+				gainI += filter->get()[ k ] * sin(omega * ( ElementType )k);
 			}
-			ElementType gain = sqrt(gainR*gainR + gainI*gainI);
+			ElementType gain = sqrt(gainR * gainR + gainI * gainI);
 			for (int k = 0; k < filter->size(); k++)
 			{
 				filter->get()[k] /= gain;
@@ -223,9 +224,9 @@ namespace supra
 			static const int factorial[9] = { 1, 2, 6, 24, 120, 720, 5040, 40320, 362880 };
 			for (int k = 1; k < 10; k++)
 			{
-				T xPower = pow(x / (T)2.0, (T)k);
+				T xPower = pow(x / ( T )2.0, ( T )k);
 				// 1, 2, 6, 24, 120, 720, 5040, 40320, 362880
-				sum += pow(xPower / (T)factorial[k-1], (T)2.0);
+				sum += pow(xPower / ( T )factorial[ k - 1 ], ( T )2.0);
 			}
 			return (T)1.0 + sum;
 		}
diff --git a/src/SupraLib/utilities/Logging.h b/src/SupraLib/utilities/Logging.h
index fac819b..d845ac7 100644
--- a/src/SupraLib/utilities/Logging.h
+++ b/src/SupraLib/utilities/Logging.h
@@ -12,6 +12,8 @@
 #ifndef __LOGGING_H__
 #define __LOGGING_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include <mutex>
 #include <iostream>
 #include <fstream>
@@ -235,7 +237,7 @@ namespace supra
 		{
 			if (cond)
 			{
-				Base::log(Severity::log, o...);
+				log(Severity::log, o) log(Severity::log, o, o, o);
 			}
 		}
 
@@ -268,7 +270,7 @@ namespace supra
 		{
 			if (cond)
 			{
-				Base::log(Severity::error, red, o..., reset);
+				log(Severity::error, red, o, reset);
 			}
 		}
 		/// Log entry containing profiling details
diff --git a/src/SupraLib/utilities/cudaUtility.h b/src/SupraLib/utilities/cudaUtility.h
index 5dcde51..646f649 100644
--- a/src/SupraLib/utilities/cudaUtility.h
+++ b/src/SupraLib/utilities/cudaUtility.h
@@ -12,9 +12,10 @@
 #ifndef __CUDAUTILITY_H__
 #define __CUDAUTILITY_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include <cmath>
 #ifdef HAVE_CUDA
-#include <cuda_runtime_api.h>
 #ifdef HAVE_CUFFT
 #include <cufft.h>
 #endif
@@ -27,7 +28,7 @@
 
 namespace supra
 {
-#ifdef __CUDACC__
+#ifdef CL_SYCL_LANGUAGE_VERSION
 	using ::max;
 	using ::min;
 	using ::round;
@@ -59,12 +60,33 @@ namespace supra
 
 	/// Verifies a cuda call returned "cudaSuccess". Prints error message otherwise.
 	/// returns true if no error occured, false otherwise. Calles by cudaSafeCall
-	inline bool cudaSafeCall2(cudaError err, const char* file, int line, const char* func) {
+	inline bool cudaSafeCall2(int err, const char* file, int line, const char* func) {
 
 		//#ifdef CUDA_ERROR_CHECK
-		if (cudaSuccess != err) {
+		/*
+		DPCT1000:1: Error handling if-stmt was detected but could not be rewritten.
+		*/
+		if (0 != err) {
 			char buf[1024];
-			sprintf(buf, "CUDA Error (in \"%s\", Line: %d, %s): %d - %s\n", file, line, func, err, cudaGetErrorString(err));
+			/*
+			DPCT1001:0: The statement could not be removed.
+			*/
+			/*
+			DPCT1009:2: SYCL uses exceptions to report errors and does not use the error codes. The original code was commented out and a warning string was inserted. You need to rewrite this code.
+			*/
+			/*
+			DPCT1009:25: SYCL uses exceptions to report errors and does not use the error codes. The original code was commented out and a warning string was inserted. You need to rewrite this code.
+			*/
+			/*
+			DPCT1009:28: SYCL uses exceptions to report errors and does not use the error codes. The original code was commented out and a warning string was inserted. You need to rewrite this code.
+			*/
+			/*
+			DPCT1009:32: SYCL uses exceptions to report errors and does not use the error codes. The original code was commented out and a warning string was inserted. You need to rewrite this code.
+			*/
+			/*
+			DPCT1009:36: SYCL uses exceptions to report errors and does not use the error codes. The original code was commented out and a warning string was inserted. You need to rewrite this code.
+			*/
+			sprintf(buf, "CUDA Error (in \"%s\", Line: %d, %s): %d - %s\n", file, line, func, err, "cudaGetErrorString not supported" /*cudaGetErrorString(err)*/);
 			printf("%s", buf);
 			logging::log_error(buf);
 			return false;
@@ -99,7 +121,7 @@ namespace supra
 
 	/// Returns the square of x. CUDA constexpr version
 	template <typename T>
-	__device__ constexpr inline T squ(const T& x)
+	constexpr inline T squ(const T& x)
 	{
 		return x*x;
 	}
@@ -112,43 +134,43 @@ namespace supra
 	class LimitProxy
 	{
 	public:
-		inline __host__ __device__ static T max();
-		inline __host__ __device__ static T min();
+		inline static T max();
+		inline static T min();
 	};
 
 	template <>
 	class LimitProxy<float>
 	{
 	public:
-		inline __host__ __device__ static float max() { return FLT_MAX; }
-		inline __host__ __device__ static float min() { return -FLT_MAX; }
+		inline static float max() { return FLT_MAX; }
+		inline static float min() { return -FLT_MAX; }
 	};
 
 	template <>
 	class LimitProxy<int16_t>
 	{
 	public:
-		inline __host__ __device__ static int16_t max() { return 32767; }
-		inline __host__ __device__ static int16_t min() { return -32767; }
+		inline static int16_t max() { return 32767; }
+		inline static int16_t min() { return -32767; }
 	};
 
 	template <>
 	class LimitProxy<uint8_t>
 	{
 	public:
-		inline __host__ __device__ static uint8_t max() { return 255; }
-		inline __host__ __device__ static uint8_t min() { return 0; }
+		inline static uint8_t max() { return 255; }
+		inline static uint8_t min() { return 0; }
 	};
 
 	template <typename ResultType, typename InputType>
-	__host__ __device__ ResultType clampCast(const InputType& x)
+	ResultType clampCast(const InputType& x)
 	{
-		return static_cast<ResultType>(min(max(x, static_cast<InputType>(LimitProxy<ResultType>::min())), static_cast<InputType>(LimitProxy<ResultType>::max())));
+		return static_cast<ResultType>(sycl::min(sycl::max(x, static_cast<InputType>(LimitProxy<ResultType>::min())), static_cast<InputType>(LimitProxy<ResultType>::max())));
 	}
 
 	template <typename ResultType, typename InputType>
 	struct clampCaster {
-		__host__ __device__ ResultType operator()(const InputType& a) const
+		ResultType operator()(const InputType& a) const
 		{
 			return clampCast<ResultType>(a);
 		}
diff --git a/src/SupraLib/utilities/utility.h b/src/SupraLib/utilities/utility.h
index af80e0f..729de80 100644
--- a/src/SupraLib/utilities/utility.h
+++ b/src/SupraLib/utilities/utility.h
@@ -12,6 +12,8 @@
 #ifndef __UTILITY_H__
 #define __UTILITY_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include <cctype>
 #include <algorithm>
 #include <vector>
diff --git a/src/SupraLib/vec.h b/src/SupraLib/vec.h
index 9def0e5..62cece3 100644
--- a/src/SupraLib/vec.h
+++ b/src/SupraLib/vec.h
@@ -12,8 +12,11 @@
 #ifndef __VEC_H__
 #define __VEC_H__
 
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
 #include "utilities/utility.h"
 #include "utilities/cudaUtility.h"
+#include <cmath>
 
 namespace supra
 {
@@ -35,7 +38,7 @@ namespace supra
 
 		/// Explicit numeric conversion operator. Casts both elements seperately to NewElementType
 		template <typename NewElementType>
-		__host__ __device__ explicit operator vec2T<NewElementType>() const
+		explicit operator vec2T<NewElementType>() const
 		{
 			return vec2T<NewElementType>{
 				static_cast<NewElementType>(this->x),
@@ -43,13 +46,13 @@ namespace supra
 		}
 
 		/// Equality operator. Compares this and b elementwise for equality
-		__host__ __device__ bool operator==(const vec2T<ElementType>& b) const
+		bool operator==(const vec2T<ElementType>& b) const
 		{
 			return x == b.x && y == b.y;
 		}
 
 		/// Inequality operator. Compares this and b elementwise for inequality
-		__host__ __device__ bool operator!=(const vec2T<ElementType>& b) const
+		bool operator!=(const vec2T<ElementType>& b) const
 		{
 			return x != b.x || y != b.y;
 		}
@@ -67,16 +70,16 @@ namespace supra
 		ElementType z;
 
 		/// Conversion of a 3-vector representing a POINT to homogeneous coordinates
-		__host__ __device__ vec4T<ElementType> pointToHom() const { return vec4T<ElementType>({ this->x, this->y, this->z, 1 }); }
+		vec4T<ElementType> pointToHom() const { return vec4T<ElementType>({ this->x, this->y, this->z, 1 }); }
 		/// Explicit conversion of a 3-vector representing a POINT to homogeneous coordinates
-		__host__ __device__ explicit operator vec4T<ElementType>() const { return pointToHom(); };
+		explicit operator vec4T<ElementType>() const { return pointToHom(); };
 
 		/// Conversion of a 3-vector representing a VECTOR to homogeneous coordinates
-		__host__ __device__ vec4T<ElementType> vectorToHom() const { return vec4T<ElementType>({ this->x, this->y, this->z, 0 }); }
+		vec4T<ElementType> vectorToHom() const { return vec4T<ElementType>({ this->x, this->y, this->z, 0 }); }
 
 		/// Explicit numeric conversion operator. Casts both elements seperately to NewElementType
 		template <typename NewElementType>
-		__host__ __device__ explicit operator vec3T<NewElementType>() const
+		explicit operator vec3T<NewElementType>() const
 		{
 			return vec3T<NewElementType>{
 				static_cast<NewElementType>(this->x),
@@ -85,13 +88,13 @@ namespace supra
 		}
 
 		/// Equality operator. Compares this and b elementwise for equality
-		__host__ __device__ bool operator==(const vec3T<ElementType>& b) const
+		bool operator==(const vec3T<ElementType>& b) const
 		{
 			return x == b.x && y == b.y && z == b.z;
 		}
 
 		/// Inequality operator. Compares this and b elementwise for inequality
-		__host__ __device__ bool operator!=(const vec3T<ElementType>& b) const
+		bool operator!=(const vec3T<ElementType>& b) const
 		{
 			return x != b.x || y != b.y || z != b.z;
 		}
@@ -175,107 +178,104 @@ namespace supra
 
 	/// Element-wise sum of a two-vector and a scalar
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator+(const vec2T<Ta>& a, const Tb& b) {
+	inline vec2T<Ta> operator+(const vec2T<Ta>& a, const Tb& b) {
 		return vec2T<Ta>({ a.x + b, a.y + b });
 	}
 	/// Negation of a two-vector
 	template <typename Ta>
-	__host__ __device__ inline vec2T<Ta> operator-(const vec2T<Ta>& a) {
+	inline vec2T<Ta> operator-(const vec2T<Ta>& a) {
 		return vec2T<Ta>({ -a.x, -a.y });
 	}
 	/// Element-wise subtraction of a two-vector and a scalar
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator-(const vec2T<Ta>& a, const Tb& b) {
+	inline vec2T<Ta> operator-(const vec2T<Ta>& a, const Tb& b) {
 		return vec2T<Ta>({ a.x - b, a.y - b });
 	}
 	/// Product of a two-vector and a scalar
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator*(const vec2T<Ta>& a, const Tb& b) {
+	inline vec2T<Ta> operator*(const vec2T<Ta>& a, const Tb& b) {
 		return vec2T<Ta>({ a.x * b, a.y * b });
 	}
 	/// Element-wise division of a two-vector and a scalar
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator/(const vec2T<Ta>& a, const Tb& b) {
+	inline vec2T<Ta> operator/(const vec2T<Ta>& a, const Tb& b) {
 		return vec2T<Ta>({ a.x / b, a.y / b });
 	}
 	/// Element-wise sum of a scalar and a two-vector
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator+(const Tb& b, const vec2T<Ta>& a) {
+	inline vec2T<Ta> operator+(const Tb& b, const vec2T<Ta>& a) {
 		return vec2T<Ta>({ a.x + b, a.y + b });
 	}
 	/// Element-wise difference of a scalar and a two-vector
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator-(const Tb& b, const vec2T<Ta>& a) {
+	inline vec2T<Ta> operator-(const Tb& b, const vec2T<Ta>& a) {
 		return vec2T<Ta>({ b - a.x, b - a.y });
 	}
 	/// Product of a scalar and a two-vector
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator*(const Tb& b, const vec2T<Ta>& a) {
+	inline vec2T<Ta> operator*(const Tb& b, const vec2T<Ta>& a) {
 		return vec2T<Ta>({ a.x * b, a.y * b });
 	}
 	/// Element-wise division of two-vectors
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator/(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+	inline vec2T<Ta> operator/(const vec2T<Ta>& a, const vec2T<Tb>& b) {
 		return vec2T<Ta>({ a.x / b.x, a.y / b.y });
 	}
 	/// Sum of two-vectors
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator+(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+	inline vec2T<Ta> operator+(const vec2T<Ta>& a, const vec2T<Tb>& b) {
 		return vec2T<Ta>({ a.x + b.x, a.y + b.y });
 	}
 	/// Difference of two-vectors
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator-(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+	inline vec2T<Ta> operator-(const vec2T<Ta>& a, const vec2T<Tb>& b) {
 		return vec2T<Ta>({ a.x - b.x, a.y - b.y });
 	}
 	/// Element-wise product of two-vectors
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec2T<Ta> operator*(const vec2T<Ta>& a, const vec2T<Tb>& b) {
+	inline vec2T<Ta> operator*(const vec2T<Ta>& a, const vec2T<Tb>& b) {
 		return vec2T<Ta>({ a.x * b.x, a.y * b.y });
 	}
 	/// Euclidean norm of a two-vector
 	template <typename Ta>
-	__host__ __device__ inline Ta norm(const vec2T<Ta>& a)
+	inline Ta norm(const vec2T<Ta>& a)
 	{
 		return sqrt(a.x*a.x + a.y*a.y);
 	}
 	/// Normalization of a two-vector
 	template <typename Ta>
-	__host__ __device__ inline vec2T<Ta> normalize(const vec2T<Ta>& a)
+	inline vec2T<Ta> normalize(const vec2T<Ta>& a)
 	{
 		return a / norm(a);
 	}
 
 	/// Element-wise round of a two-vector
 	template <typename Ta>
-	__host__ __device__ inline vec2T<Ta> round(const vec2T<Ta>& a)
+	inline vec2T<Ta> round(const vec2T<Ta>& a)
 	{
 		return{ round(a.x), round(a.y) };
 	}
 	/// Element-wise floor of a two-vector
 	template <typename Ta>
-	__host__ __device__ inline vec2T<Ta> floor(const vec2T<Ta>& a)
+	inline vec2T<Ta> floor(const vec2T<Ta>& a)
 	{
-		return{ floor(a.x), floor(a.y) };
+		return { sycl::floor(( double )(a.x)), sycl::floor(( double )(a.y)) };
 	}
 	/// Element-wise ceil of a two-vector
 	template <typename Ta>
-	__host__ __device__ inline vec2T<Ta> ceil(const vec2T<Ta>& a)
+	inline vec2T<Ta> ceil(const vec2T<Ta>& a)
 	{
-		return{ ceil(a.x), ceil(a.y) };
+		return { sycl::ceil(( double )(a.x)), sycl::ceil(( double )(a.y)) };
 	}
 	/// Element-wise minimum of two-vectors
 	template <typename Ta>
-	__host__ __device__ inline vec2T<Ta> min(const vec2T<Ta>& a, const vec2T<Ta>& b)
+	inline vec2T<Ta> min(const vec2T<Ta>& a, const vec2T<Ta>& b)
 	{
-		return{
-			min(a.x, b.x),
-			min(a.y, b.y)
-		};
+		return { min(a.x, b.x), min(a.y, b.y) };
 	}
 	/// Element-wise maximum of two-vectors
 	template <typename Ta>
-	__host__ __device__ inline vec2T<Ta> max(const vec2T<Ta>& a, const vec2T<Ta>& b)
+	inline vec2T<Ta> max(const vec2T<Ta>& a, const vec2T<Ta>& b)
 	{
 		return{
 			max(a.x, b.x),
@@ -285,86 +285,86 @@ namespace supra
 
 	/// Element-wise sum of a three-vector and a scalar
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator+(const vec3T<Ta>& a, const Tb& b) {
+	inline vec3T<Ta> operator+(const vec3T<Ta>& a, const Tb& b) {
 		return vec3T<Ta>({ a.x + b, a.y + b, a.z + b });
 	}
 	/// Negation of a three-vector
 	template <typename Ta>
-	__host__ __device__ inline vec3T<Ta> operator-(const vec3T<Ta>& a) {
+	inline vec3T<Ta> operator-(const vec3T<Ta>& a) {
 		return vec3T<Ta>({ -a.x, -a.y, -a.z });
 	}
 	/// Element-wise subtraction of a three-vector and a scalar
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator-(const vec3T<Ta>& a, const Tb& b) {
+	inline vec3T<Ta> operator-(const vec3T<Ta>& a, const Tb& b) {
 		return vec3T<Ta>({ a.x - b, a.y - b, a.z - b });
 	}
 	/// Product of a three-vector and a scalar
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator*(const vec3T<Ta>& a, const Tb& b) {
+	inline vec3T<Ta> operator*(const vec3T<Ta>& a, const Tb& b) {
 		return vec3T<Ta>({ a.x * b, a.y * b, a.z * b });
 	}
 	/// Element-wise division of a three-vector and a scalar
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator/(const vec3T<Ta>& a, const Tb& b) {
+	inline vec3T<Ta> operator/(const vec3T<Ta>& a, const Tb& b) {
 		return vec3T<Ta>({ a.x / b, a.y / b, a.z / b });
 	}
 	/// Element-wise sum of a scalar and a three-vector
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator+(const Tb& b, const vec3T<Ta>& a) {
+	inline vec3T<Ta> operator+(const Tb& b, const vec3T<Ta>& a) {
 		return vec3T<Ta>({ a.x + b, a.y + b, a.z + b });
 	}
 	/// Element-wise difference of a scalar and a three-vector
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator-(const Tb& b, const vec3T<Ta>& a) {
+	inline vec3T<Ta> operator-(const Tb& b, const vec3T<Ta>& a) {
 		return vec3T<Ta>({ b - a.x, b - a.y, b - a.z });
 	}
 	/// Product of a scalar and a three-vector
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator*(const Tb& b, const vec3T<Ta>& a) {
+	inline vec3T<Ta> operator*(const Tb& b, const vec3T<Ta>& a) {
 		return vec3T<Ta>({ a.x * b, a.y * b, a.z * b });
 	}
 	/// Element-wise division of three-vectors
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator/(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+	inline vec3T<Ta> operator/(const vec3T<Ta>& a, const vec3T<Tb>& b) {
 		return vec3T<Ta>({ a.x / b.x, a.y / b.y, a.z / b.z });
 	}
 	/// Sum of three-vectors
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator+(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+	inline vec3T<Ta> operator+(const vec3T<Ta>& a, const vec3T<Tb>& b) {
 		return vec3T<Ta>({ a.x + b.x, a.y + b.y, a.z + b.z });
 	}
 	/// Difference of three-vectors
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator-(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+	inline vec3T<Ta> operator-(const vec3T<Ta>& a, const vec3T<Tb>& b) {
 		return vec3T<Ta>({ a.x - b.x, a.y - b.y, a.z - b.z });
 	}
 	/// Element-wise product of three-vectors
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<Ta> operator*(const vec3T<Ta>& a, const vec3T<Tb>& b) {
+	inline vec3T<Ta> operator*(const vec3T<Ta>& a, const vec3T<Tb>& b) {
 		return vec3T<Ta>({ a.x * b.x, a.y * b.y, a.z * b.z });
 	}
 
 	/// Euclidean norm of a three-vector
 	template <typename Ta>
-	__host__ __device__ inline Ta norm(const vec3T<Ta>& a)
+	inline Ta norm(const vec3T<Ta>& a)
 	{
-		return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);
+		return sycl::sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
 	}
 	/// Normalization of a three-vector
 	template <typename Ta>
-	__host__ __device__ inline vec3T<Ta> normalize(const vec3T<Ta>& a)
+	inline vec3T<Ta> normalize(const vec3T<Ta>& a)
 	{
 		return a / norm(a);
 	}
 	/// Dot-product of two three-vectors
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline typename std::common_type<Ta, Tb>::type dot(const vec3T<Ta>& a, const vec3T<Tb>& b)
+	inline typename std::common_type<Ta, Tb>::type dot(const vec3T<Ta>& a, const vec3T<Tb>& b)
 	{
 		return a.x*b.x + a.y*b.y + a.z*b.z;
 	}
 	/// Cross-product of two three-vectors
 	template <typename Ta, typename Tb>
-	__host__ __device__ inline vec3T<typename std::common_type<Ta, Tb>::type > cross(const vec3T<Ta>& a, const vec3T<Tb>& b)
+	inline vec3T<typename std::common_type<Ta, Tb>::type > cross(const vec3T<Ta>& a, const vec3T<Tb>& b)
 	{
 		return{
 			a.y*b.z - a.z*b.y,
@@ -374,56 +374,48 @@ namespace supra
 	}
 	/// Determinant of matric \f$[a, b, c]\f$
 	template <typename Ta, typename Tb, typename Tc>
-	__host__ __device__ inline typename std::common_type<Ta, Tb, Tc>::type det(const vec3T<Ta>& a, const vec3T<Tb>& b, const vec3T<Tc>& c)
+	inline typename std::common_type<Ta, Tb, Tc>::type det(const vec3T<Ta>& a, const vec3T<Tb>& b, const vec3T<Tc>& c)
 	{
-		return abs(dot(a, cross(b, c)));
+		return sycl::fabs(dot(a, cross(b, c)));
 	}
 	/// Element-wise round of a three-vector
 	template <typename Ta>
-	__host__ __device__ inline vec3T<Ta> round(const vec3T<Ta>& a)
+	inline vec3T<Ta> round(const vec3T<Ta>& a)
 	{
 		return{ round(a.x), round(a.y), round(a.z) };
 	}
 	/// Element-wise floor of a three-vector
 	template <typename Ta>
-	__host__ __device__ inline vec3T<Ta> floor(const vec3T<Ta>& a)
+	inline vec3T<Ta> floor(const vec3T<Ta>& a)
 	{
-		return{ floor(a.x), floor(a.y), floor(a.z) };
+		return { sycl::floor(( double )(a.x)), sycl::floor(( double )(a.y)), sycl::floor(( double )(a.z)) };
 	}
 	/// Element-wise ceil of a three-vector
 	template <typename Ta>
-	__host__ __device__ inline vec3T<Ta> ceil(const vec3T<Ta>& a)
+	inline vec3T<Ta> ceil(const vec3T<Ta>& a)
 	{
-		return{ ceil(a.x), ceil(a.y), ceil(a.z) };
+		return { sycl::ceil(( double )(a.x)), sycl::ceil(( double )(a.y)), sycl::ceil(( double )(a.z)) };
 	}
 
 	/// Element-wise minimum of three-vectors
 	template <typename Ta>
-	__host__ __device__ inline vec3T<Ta> min(const vec3T<Ta>& a, const vec3T<Ta>& b)
+	inline vec3T<Ta> min(const vec3T<Ta>& a, const vec3T<Ta>& b)
 	{
-		return{
-			min(a.x, b.x),
-			min(a.y, b.y),
-			min(a.z, b.z)
-		};
+		return { min(a.x, b.x), min(a.y, b.y), min(a.z, b.z) };
 	}
 
 	/// Element-wise maximum of three-vectors
 	template <typename Ta>
-	__host__ __device__ inline vec3T<Ta> max(const vec3T<Ta>& a, const vec3T<Ta>& b)
+	inline vec3T<Ta> max(const vec3T<Ta>& a, const vec3T<Ta>& b)
 	{
-		return{
-			max(a.x, b.x),
-			max(a.y, b.y),
-			max(a.z, b.z)
-		};
+		return { max(a.x, b.x), max(a.y, b.y), max(a.z, b.z) };
 	}
 
 	/// Spherical Linear Interpolation (SLERP) of two three-vectors
 	template <typename T>
-	__host__ __device__ vec3T<T> inline slerp3(const vec3T<T>& a, const vec3T<T>& b, const T& t)
+	vec3T<T> inline slerp3(const vec3T<T>& a, const vec3T<T>& b, const T& t)
 	{
-		T omega = acos(dot(a, b));
+		T omega = sycl::acos(( double )(dot(a, b)));
 		if (omega < M_EPS)
 		{
 			return a;
@@ -438,8 +430,7 @@ namespace supra
 			ret = b;
 		}
 		else {
-			ret = (sin(((T)1.0 - t)*omega) / sin(omega))*a +
-				(sin(t *omega) / sin(omega))*b;
+			ret = (sycl::sin((( T )1.0 - t) * omega) / sycl::sin(omega)) * a + (sycl::sin(t * omega) / sycl::sin(omega)) * b;
 		}
 		return ret;
 	}
-- 
2.17.1

